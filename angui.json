{
  "1": {
    "q": "()是从(多条)信息中发现的共性规律、模式、模型、理论、方法。",
    "t": "single",
    "a": "知识"
  },
  "2": {
    "q": "DIKW金字塔模型中，顶层与底层的名称分别为()",
    "t": "single",
    "a": "智慧与数据"
  },
  "3": {
    "q": "大数据中的小数据可能缺失、冗余、存在垃圾数据，但不影响大数据的可信数据，是大数据的()的表现形式。",
    "t": "single",
    "a": "质量涌现"
  },
  "4": {
    "q": "数据科学基本原则中，基于数据的智能的主要特点是（）。",
    "t": "single",
    "a": "数据复杂，但算法简单"
  },
  "5": {
    "q": "下列关于描述性分析与探索性分析的描述正确的是（）。",
    "t": "single",
    "a": "探索性分析是相对于验证性分析的一种提法"
  },
  "6": {
    "q": "BASE原则的含义不包括（）。",
    "t": "single",
    "a": "基础条件"
  },
  "7": {
    "q": "（）是实现数据战略的重要保障。",
    "t": "single",
    "a": "数据治理"
  },
  "8": {
    "q": "()是数据库管理系统运行的基本工作单位。",
    "t": "single",
    "a": "事务"
  },
  "9": {
    "q": "()是指对于数据局部不良行为的非敏感性，是探索性分析追求的主要目标之一。",
    "t": "single",
    "a": "耐抗性"
  },
  "10": {
    "q": "下列关于数据的描述错误的是()。",
    "t": "single",
    "a": "数据与数值是一个概念"
  },
  "11": {
    "q": "()认为，大数据时代的数据管理目标不一定理想和完美，一致性、可用性和分区容错性中的任何两个特征的保证(争取)可能导致另一个特征的损失(放弃)。",
    "t": "single",
    "a": "CAP理论"
  },
  "12": {
    "q": "2003年，Tableau在斯坦福大学诞生，它起源于一种改变数据使用方式的新技术,即( )。",
    "t": "single",
    "a": "VizQL语言"
  },
  "13": {
    "q": "目前，多数NoSQL数据库是针对特定应用场景研发出来的，其设计遵循（）原则，更强调读写效率、数据容量以及系统可扩展性。",
    "t": "single",
    "a": "BASE"
  },
  "14": {
    "q": "PageRank是一个函数，它对Web中的每个网页赋予一个实数值。它的意图在于网页的PageRank越高，那么它就（）。",
    "t": "single",
    "a": "越重要"
  },
  "15": {
    "q": "从数据到智慧的转换依次递进过程是（）。",
    "t": "single",
    "a": "数据、信息、知识、理解、智慧"
  },
  "16": {
    "q": "大数据参考架构的水平轴和垂直轴分别为（）。",
    "t": "single",
    "a": "信息（活动）价值链和信息技术价值链"
  },
  "17": {
    "q": "大数据的“4V”特性不包括（）。",
    "t": "single",
    "a": "Visual"
  },
  "18": {
    "q": "具有体量大、来源多样、生成极快和多变等特征并且难以用传统数据体系机构有效处理的包含大量数据集的数据是（）。",
    "t": "single",
    "a": "大数据"
  },
  "19": {
    "q": "大数据涌现现象的形式有多种，不属于大数据涌现形式的是（）。",
    "t": "single",
    "a": "物质涌现"
  },
  "20": {
    "q": "在数据科学项目的活动流程中，主要用于回答“我们用什么方式记录和展现数据结果”问题的是（）。",
    "t": "single",
    "a": "结果的可视化与文档化"
  },
  "21": {
    "q": "关系云的一个重要功能是提供（）。",
    "t": "single",
    "a": "数据库即服务"
  },
  "22": {
    "q": "下列关于数据创新的说法正确的是（）。",
    "t": "single",
    "a": "数据只有开放价值才可以得到真正释放"
  },
  "23": {
    "q": "在著名管理学家Thomas • H.Davernport在《哈佛商业论坛》上发表的题为《第三代分析学（Analytics3.0）》的经典论文中，Analytics3.0时代是指（）。",
    "t": "single",
    "a": "数据富足供给时代"
  },
  "24": {
    "q": "下列不属于可视化视觉下的数据类型的是（）。",
    "t": "single",
    "a": "定宽数据"
  },
  "25": {
    "q": "决定事务对数据对象加锁后拥有何种控制权的是锁的（）。",
    "t": "single",
    "a": "类型"
  },
  "26": {
    "q": "下列不属于视觉通道表现力评价指标的是（）。",
    "t": "single",
    "a": "可转换性"
  },
  "27": {
    "q": "数据的可用性取决于（）。",
    "t": "single",
    "a": "数据质量"
  },
  "28": {
    "q": "数据的原始内容及其备份数据是数据产品研发的（）。",
    "t": "single",
    "a": "零次数据"
  },
  "29": {
    "q": "数据科学处于（）三大领域的重叠之处。",
    "t": "single",
    "a": "数学与统计知识、黑客精神与技能、领域实务知识"
  },
  "30": {
    "q": "数据科学是一门以（）为主要研究任务的独立学科。",
    "t": "single",
    "a": "数据驱动、数据业务化、数据洞见、数据产品研发和（或）数据生态系统的建设"
  },
  "31": {
    "q": "下列关于数据科学的描述错误的是（）。",
    "t": "single",
    "a": "数据科学不包括理论知识，只包括领域实务经验"
  },
  "32": {
    "q": "数据可视化的本质是（）。",
    "t": "single",
    "a": "将数据转换为知识"
  },
  "33": {
    "q": "数据科学中，人们开始注意到传统数据处理方式中普遍存在的信息丢失现象，进而数据处理范式变为(）",
    "t": "single",
    "a": "从模式在先，数据在后范式转向数据在先，模式在后范式或无模式"
  },
  "34": {
    "q": "数据可视化的方法论基础是()。",
    "t": "single",
    "a": "视觉编码"
  },
  "35": {
    "q": "下列不属于现阶段的大数据技术体系主要类型的是( )。",
    "t": "single",
    "a": "Hadoop"
  },
  "36": {
    "q": "在数据科学中，通常下载R的包的服务器是（）。",
    "t": "single",
    "a": "CRAN"
  },
  "37": {
    "q": "不属于Mayer-Schonberger V 和Cukier K.在其著名论著《BigData:A Revolution That Will Transform How We Live,Work,and Think）中提出了大数据时代统计的思维变革的是（）。",
    "t": "single",
    "a": "不是描述性分析，而是预测性分析"
  },
  "38": {
    "q": "关系数据库中存储、计算和管理的数据是（）。",
    "t": "single",
    "a": "结构化数据"
  },
  "39": {
    "q": "图灵奖获得者JimGray提岀的科学研究第四范式的全称为（）。",
    "t": "single",
    "a": "数据密集型科学发现"
  },
  "40": {
    "q": "表示数据分布是否为对称性的统计量是()。",
    "t": "single",
    "a": "偏态"
  },
  "41": {
    "q": "下列不属于数据科学开源工具的是()。",
    "t": "single",
    "a": "ERP"
  },
  "42": {
    "q": "下列不属于数据科学跨平台基础设施和分析工具的是()。",
    "t": "single",
    "a": "Adobe photoshop"
  },
  "43": {
    "q": "下列关于数据交易市场的说法错误的是()。",
    "t": "single",
    "a": "数据交易市场通过生产、研发和分析数据，为数据交易提供帮助"
  },
  "44": {
    "q": "下列关于数据科学流程与方法的描述错误的是（）。",
    "t": "single",
    "a": "对于数据形态不符合要求的乱数据，要通过清洗成为规整数据"
  },
  "45": {
    "q": "集群的最主要“瓶颈”通常是（）。",
    "t": "single",
    "a": "磁盘I/O"
  },
  "46": {
    "q": "下列判断错误的是（）。",
    "t": "single",
    "a": "JSON文件属于非结构化数据"
  },
  "47": {
    "q": "下列不属于大数据平台安全管理组件提供的功能的是（）。",
    "t": "single",
    "a": "路由代理"
  },
  "48": {
    "q": "新兴数据管理技术主要包括NoSQL技术、NewSQL技术和（）。",
    "t": "single",
    "a": "关系云"
  },
  "49": {
    "q": "一般将原始业务数据分为多个部分，用于构建模型的是（）。",
    "t": "single",
    "a": "训练集"
  },
  "50": {
    "q": "一切皆可连，任何数据之间逻辑上都有可能存在联系，这体现了大数据思维维度中的（）。",
    "t": "single",
    "a": "相关思维"
  },
  "51": {
    "q": "下列属于NoSQL数据库中Key.Value缺点的是（）。",
    "t": "single",
    "a": "不记录结构信息"
  },
  "52": {
    "q": "下列不是NoSQL数据库的是（ ）。",
    "t": "single",
    "a": "Access"
  },
  "53": {
    "q": "下列不是开源工具特点的是（）。",
    "t": "single",
    "a": "用户可以修改源代码并不加说明用于自己的软件中"
  },
  "54": {
    "q": "下列不属于大数据在社会活动中的典型应用的是（）。",
    "t": "single",
    "a": "供电公司提供电费账单查询"
  },
  "55": {
    "q": "下列不属于大数据重要意义的是（）。",
    "t": "single",
    "a": "大数据会增加经济发展的成本"
  },
  "56": {
    "q": "下列不属于数据科学与统计学区别的是（）。",
    "t": "single",
    "a": "数据科学和统计学中的计算一样，仅仅是加减乘除"
  },
  "57": {
    "q": "有研究发现“页面的显示速度每延迟1s,网站访问量就会降低11%,从而导致营业额或者注册量减少7%,顾客满意度下降16%”。该项研究表明了在数据产品开发中更加重要的是（）。",
    "t": "single",
    "a": "用户体验"
  },
  "58": {
    "q": "数据分析的第一步是（）。",
    "t": "single",
    "a": "描述性分析"
  },
  "59": {
    "q": "诊断性分析主要釆取的分析方法是（）。",
    "t": "single",
    "a": "关联分析法和因果分析法"
  },
  "60": {
    "q": "从行为目的与思维方式看，下列属于描述性统计分析的是（）。",
    "t": "single",
    "a": "相关分析"
  },
  "61": {
    "q": "第一数字定律中使用概率最大的数字是（）。",
    "t": "single",
    "a": "1"
  },
  "62": {
    "q": "对于数据3,3,2,3,6,3,10,3,6,3,2,得出以下结论:①这组数据的众数是3;②这组数据的众数与中位数的数值不相等；③这组数据的中位数与平均数的数值不相等；④这组数据的平均数与众数的数值相等。其中结论正确的个数为（）。",
    "t": "single",
    "a": "2"
  },
  "63": {
    "q": "某工厂共有100名员工，他们的月工资方差是s,现在给每个员工的月工资增加3000元，那么他们的新工资的方差（）。",
    "t": "single",
    "a": "不变"
  },
  "64": {
    "q": "下列不属于数据脱敏要求的是（）。",
    "t": "single",
    "a": "双向性"
  },
  "65": {
    "q": "下列不是目前机器学习所面临的问题是（）。",
    "t": "single",
    "a": "测试集的规模"
  },
  "66": {
    "q": "在空间维度上刻画数据连续性是数据的（）。",
    "t": "single",
    "a": "可关联性"
  },
  "67": {
    "q": "下列不属于数据预处理方法的是（）。",
    "t": "single",
    "a": "数据统计"
  },
  "68": {
    "q": "数据探索是指针对目标可变、持续、多角度的搜索或分析任务，下列不是其搜索过程特点的是（）。",
    "t": "single",
    "a": "有目标"
  },
  "69": {
    "q": "将观测值分为相同数目的两部分，当统计结果为非对称分布时经常使用的是()。",
    "t": "single",
    "a": "中位数"
  },
  "70": {
    "q": "()的本质是将低层次数据转换为高层次数据的过程。",
    "t": "single",
    "a": "数据加工"
  },
  "71": {
    "q": "与其他观测值的差别较大，以至于怀疑它是由不同的机制产生的观测值是()。",
    "t": "single",
    "a": "离群点"
  },
  "72": {
    "q": "在比较模型的拟合效果时，甲、乙、丙三个模型的相关指数R2的值分别约为0.71、0.85、0.90,则拟合效果较好的模型是()。",
    "t": "single",
    "a": "丙"
  },
  "73": {
    "q": "常用的数据归约方法可以分为()。",
    "t": "single",
    "a": "维归约、值归约"
  },
  "74": {
    "q": "从复杂度及价值高低两个维度，可以将数据分析分为（）。",
    "t": "single",
    "a": "描述性分析、诊断性分析、预测性分析、规范性分析"
  },
  "75": {
    "q": "在抽样方法中，当合适的样本容量很难确定时，可以使用的抽样方法是（）。",
    "t": "single",
    "a": "渐进抽样"
  },
  "76": {
    "q": "大数据是指不用随机分析法这样的捷径，而采用（",
    "t": "single",
    "a": "所有数据"
  },
  "77": {
    "q": "大数据应用需依托的新技术有（）。",
    "t": "single",
    "a": "三个选项都是"
  },
  "78": {
    "q": "下列关于OLAP和OLTP的区别描述不正确的是（）。",
    "t": "single",
    "a": "OLAP的特点在于事务量大，但事务内容比较简单且重复率高"
  },
  "79": {
    "q": "下列关于混合模型聚类算法的优、缺点的说法正确的是（）。",
    "t": "single",
    "a": "混合模型比K均值或模糊C均值更一般，因为它可以使用各种类型的分布"
  },
  "80": {
    "q": "下列关于基本元数据描述正确的是（ ）。",
    "t": "single",
    "a": "基本元数据包括关于装载和更新处理、分析处理以及管理方面的信息"
  },
  "81": {
    "q": "下列关于缺失值填补的说法不正确的是（）。",
    "t": "single",
    "a": "Pandas.dropna可以用来填补缺失值"
  },
  "82": {
    "q": "下列关于数据分析的说法正确的是（ ）。",
    "t": "single",
    "a": "预测性分析是规范性分析的基础"
  },
  "83": {
    "q": "下列关于数据清洗的说法不正确的是（）。",
    "t": "single",
    "a": "连续型数据不存在冗余问题"
  },
  "84": {
    "q": "下列关于数据相关性的说法错误的是（）。",
    "t": "single",
    "a": "相关性关注事物的因果关系"
  },
  "85": {
    "q": "下列不属于脏数据的是（）。",
    "t": "single",
    "a": "不规则形态数据"
  },
  "86": {
    "q": "下列关于在回归分析中解释变量与非解释变量的说法正确的是（）。",
    "t": "single",
    "a": "解释变量为非随机变量，被解释变量为随机变量"
  },
  "87": {
    "q": "异常检测中，检测一元正态分布中的离群点基于的技术是（）。",
    "t": "single",
    "a": "统计方法"
  },
  "88": {
    "q": "建立在相关关系分析法基础上的预测是大数据的（）。",
    "t": "single",
    "a": "核心"
  },
  "89": {
    "q": "下列关于OLAP的特性的描述:①快速性；②可分析性；③多维性；④信息性;⑤共享性。正确的是（）。",
    "t": "single",
    "a": "①②③④⑤"
  },
  "90": {
    "q": "在一些算法中，为了进行属性之间的比较或运算，需要把不同属性的不同变量取值范围变换成同一范围，以免使得结果发生扭曲，偏向取值范围大的变量。这一过程称为（）。",
    "t": "single",
    "a": "归一化"
  },
  "91": {
    "q": "离散程度的测度值愈大，则（）。",
    "t": "single",
    "a": "反映变量值愈分散，算术平均数代表性愈差"
  },
  "92": {
    "q": "利用到每个聚类中心和的远近判断离群值的方法，可以基于的算法为（）。",
    "t": "single",
    "a": "K-means"
  },
  "93": {
    "q": "美国海军军官莫里通过对前人航海日志的分析，绘制了新的航海路线图，标明了大风与洋流可能发生的地点。这体现了大数据分析理念中的（）。",
    "t": "single",
    "a": "在分析方法上更注重相关分析而不是因果分析"
  },
  "94": {
    "q": "平滑图像处理可以采用RGB彩色（）。",
    "t": "single",
    "a": "加权均值滤波模型"
  },
  "95": {
    "q": "相关关系是一种与函数关系区别的非确定性关系，而相关分析就是研究事物或现象之间是否存在这种非确定性关系的统计方法，下列不属于相关性分析方法的是( )。",
    "t": "single",
    "a": "傅里叶系数"
  },
  "96": {
    "q": "数据变换的策略包括( )。",
    "t": "single",
    "a": "平滑处理、特征构造、聚集、标准化、离散化"
  },
  "97": {
    "q": "下列关于数据仓库最终目的的描述正确的是()。",
    "t": "single",
    "a": "为用户和业务部门提供决策支持"
  },
  "98": {
    "q": "下列关于数据仓库随时间变化的描述不正确的是( )。",
    "t": "single",
    "a": "数据仓库随时间变化不断删去旧的数据内容"
  },
  "99": {
    "q": "下列关于计算机存储容量单位的说法错误的是（）。",
    "t": "single",
    "a": "一个汉字需要一个字节的存储空间"
  },
  "100": {
    "q": "数据集成的基本类型是（）。",
    "t": "single",
    "a": "内容集成、结构集成"
  },
  "101": {
    "q": "数据科学家可能会同时使用多个算法（模型）进行预测，并且把这些算法的结果集成起来进行最后的预测（集成学习）,下列关于集成学习的说法正确的是（ ）。",
    "t": "single",
    "a": "单个模型之间具有低相关性"
  },
  "102": {
    "q": "下列属于无监督学习的是（）。",
    "t": "single",
    "a": "K-means"
  },
  "103": {
    "q": "下列描述中不属于数据预处理方法的是（）。",
    "t": "single",
    "a": "数据转化:把连续数据转换为离散数据"
  },
  "104": {
    "q": "下列关于数据整合和分组的说法不正确的是（）。",
    "t": "single",
    "a": "数据分组可以使用mean函数"
  },
  "105": {
    "q": "已知一组数据的协方差矩阵，下列关于主分量说法的错误的是（）。",
    "t": "single",
    "a": "主分量分析就是K-L变换"
  },
  "106": {
    "q": "探索性分析与验证性分析的不同点是（ ）",
    "t": "single",
    "a": "探索性分析在前"
  },
  "107": {
    "q": "下列不能作为数据科学数据源的是（ ）。",
    "t": "single",
    "a": "个人电脑中用于备忘的日记"
  },
  "108": {
    "q": "下列关于等距离散化和等频离散化的叙述不正确的是（）。",
    "t": "single",
    "a": "等距离散化对数据离群值不敏感"
  },
  "109": {
    "q": "因子分析把每个原始变量分解为（）两部分因素。",
    "t": "single",
    "a": "公共因子和特殊因子"
  },
  "110": {
    "q": "下列关于大数据的分析理念的说法错误的是（）。",
    "t": "single",
    "a": "在数据规模上强调相对数据而不是绝对数据"
  },
  "111": {
    "q": "下列关于可视化方法体系的说法不正确的是（）。",
    "t": "single",
    "a": "领域方法在所属领域内其可视化的信度和效果往往低于基础方法的直接应用"
  },
  "112": {
    "q": "下列关于数据重组的说法错误的是（）。",
    "t": "single",
    "a": "数据重组是数据的重新生产和重新采集"
  },
  "113": {
    "q": "下列关于数据转换的说法正确的是（）。",
    "t": "single",
    "a": "可以通过Python将CSV文件转换成Excel格式"
  },
  "114": {
    "q": "下列关于特征编码的叙述不正确的是（）。",
    "t": "single",
    "a": "数字编码与特征的排序无关"
  },
  "115": {
    "q": "下列关于误差的说法正确的是（）。",
    "t": "single",
    "a": "过拟合可以通过减少模型参数数量解决"
  },
  "116": {
    "q": "下列关于线性回归分析中的残差的说法正确的是（）。",
    "t": "single",
    "a": "残差均值总是为零"
  },
  "117": {
    "q": "下列关于缺失值的说法错误的是（）。",
    "t": "single",
    "a": "只要有缺失值就必须把对应记录删除"
  },
  "118": {
    "q": "下列描述中不属于向量空间模型缺陷的是（）。",
    "t": "single",
    "a": "无法计算文本相似度"
  },
  "119": {
    "q": "一位母亲记录了儿子3~9岁的身高，由此建立的身高与年龄的回归直线方程为y=7.19x+73.93,据此可以预测这个孩子10岁时的身高，则下列叙述正确的是()。",
    "t": "single",
    "a": "身高在145.83cm左右"
  },
  "120": {
    "q": "下列关于数据仓库开发特点的描述不正确的是()。",
    "t": "single",
    "a": "数据仓库开发要从数据出发"
  },
  "121": {
    "q": "下列关于数据产品开发关键环节的描述正确的是()。",
    "t": "single",
    "a": "数据加工"
  },
  "122": {
    "q": "()是一个组织机构的数据管理的愿景、目标以及功能蓝图的统一管理。",
    "t": "single",
    "a": "数据战略"
  },
  "123": {
    "q": "()是指理解挖掘项目的目标业务需求。",
    "t": "single",
    "a": "业务理解"
  },
  "124": {
    "q": "()是指针对用户非常明确的数据查询和处理任务，以高性能和高吞吐量的方式实现大众化的服务，是数据价值最重要也是最直接的发现方式。",
    "t": "single",
    "a": "数据服务"
  },
  "125": {
    "q": "下列情景中不属于数据故事化的是()。",
    "t": "single",
    "a": "统计情景"
  },
  "126": {
    "q": "下列关于数据产品的说法错误的是( )。",
    "t": "single",
    "a": "数据产品的存在形式是数据集"
  },
  "127": {
    "q": "下列不属于数据科学项目主要角色的是（）。",
    "t": "single",
    "a": "验收人员"
  },
  "128": {
    "q": "数据安全不只是技术问题，还涉及（）。",
    "t": "single",
    "a": "管理问题"
  },
  "129": {
    "q": "下列描述中不属于数据安全技术保护与信息系统“三同步”原则的是（）。",
    "t": "single",
    "a": "同步运维"
  },
  "130": {
    "q": "数据产品的定义是（）。",
    "t": "single",
    "a": "数据产品是可以发挥数据价值去辅助用户更优地做决策（甚至行动）的一种产品形式"
  },
  "131": {
    "q": "下列基本活动中不属于数据产品开发工作之中需要特别注意的是（）。",
    "t": "single",
    "a": "个性化描述"
  },
  "132": {
    "q": "数据管理成熟度模型—DMM将一个机构的数据管理工作抽象成6个关键过程域，即数据战略、（ ）、数据质量、平台与架构、数据操作以及辅助性程。",
    "t": "single",
    "a": "数据治理"
  },
  "133": {
    "q": "数据管理成熟度模型中成熟度等级最高的是（）。",
    "t": "single",
    "a": "已优化级"
  },
  "134": {
    "q": "数据科学项目应遵循一般项目管理的原则和方法，涉及（）。",
    "t": "single",
    "a": "整体、范围、时间、成本、质量、人力资源、沟通、风险、采购"
  },
  "135": {
    "q": "数据使用环节的安全技术措施除防火墙、（）、防病毒、防DDOS、漏洞检测等网络安全防护技术措施外，还需实现以下安全技术能力:账号权限管理、数据安全域、数据脱敏、日志管理和审计、异常行为实时监控和终端数据防泄漏。",
    "t": "single",
    "a": "入侵检测"
  },
  "136": {
    "q": "数据销毁环节的安全技术措施有通过软件或物理方式保障磁盘中存储数据的（）、不可恢复，如数据销毁软件、硬盘消磁机、硬盘粉碎机等。",
    "t": "single",
    "a": "永久删除"
  },
  "137": {
    "q": "数据资产维护是指为保证数据质量，对数据进行（）等处理的过程。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "138": {
    "q": "数据资产应用以安全可控为前提，按照（）的原则，落实安全与保密责任。",
    "t": "single",
    "a": "谁经手，谁使用，谁负责"
  },
  "139": {
    "q": "下列关于DMM（数据管理成熟度模型）中已管理级基本特点的描述正确的是（）。",
    "t": "single",
    "a": "M给出的关键过程，而缺乏机构层次的统筹与管理<br>D.\t组织机构的数据管理工作超出了项目管理的范畴，由组织机构统一管理其数据管理关键过程"
  },
  "140": {
    "q": "下列描述中属于DMM（数据管理成熟度模型）中的关键过程域数据战略的是（ ）。",
    "t": "single",
    "a": "数据战略制定"
  },
  "141": {
    "q": "下列描述中不属于规整数据（TidyData）三个基本原则的是（）。",
    "t": "single",
    "a": "每个观察占且仅占一个关系（表）"
  },
  "142": {
    "q": "下列描述中不属于数据治理内容的是（）。",
    "t": "single",
    "a": "获得更多的数据"
  },
  "143": {
    "q": "（）反映数据的精细化程度，越细化的数据，价值越高。",
    "t": "single",
    "a": "颗粒度"
  },
  "144": {
    "q": "（）是指个体对视觉感知信息的进一步加工处理过程，包括视觉信息的抽取、转换、存储、简化、合并、理解和决策加工活动。",
    "t": "single",
    "a": "视觉认知"
  },
  "145": {
    "q": "()是指给目标用户产生的错误或不准确的视觉感知，而这种感知与数据可视化者的意图或数据本身的真实情况不一致。",
    "t": "single",
    "a": "视觉假象"
  },
  "146": {
    "q": "数据的故事化描述是指为了提升数据的(),将数据还原成关联至特定的情景的过程。",
    "t": "single",
    "a": "可理解性、可记忆性、可体验性"
  },
  "147": {
    "q": "大数据环境下的隐私担忧，主要表现为()。",
    "t": "single",
    "a": "人信息的被识别与暴露"
  },
  "148": {
    "q": "下列关于组织机构的数据管理成熟度等级划分中的已执行级的描述错误的是()。",
    "t": "single",
    "a": "DMM关键过程的执行不仅仅局限于特定业务范畴，存在跨越不同业务领域的关键过程"
  },
  "149": {
    "q": "根据数据管理计划，设计或选择具体方法实行计划中的工作内容，属于数据治理的（）过程。",
    "t": "single",
    "a": "执行"
  },
  "150": {
    "q": "将原始数据进行集成、变换、维度规约、数值规约是下列步骤中（）的任务。",
    "t": "single",
    "a": "数据预处理"
  },
  "151": {
    "q": "（）是指几组不同的数据中均存在一种趋势，但当这些数据组组合在一起后，这种趋势将消失或反转。",
    "t": "single",
    "a": "辛普森悖论"
  },
  "152": {
    "q": "在数据科学中，通常可以采用（）有效避免数据加工和数据备份的偏见。",
    "t": "single",
    "a": "A/B测试"
  },
  "153": {
    "q": "Analytics 1.0的主要特点有（）。",
    "t": "muti",
    "a": "分析活动滞后于数据的生成 | 重视结构化数据的分析 | 以对历史数据的理解为主要目的 | 注重描述性分析"
  },
  "154": {
    "q": "以数据为中心是数据产品区别于其他类型产品的本质特征，表现方面有()。",
    "t": "muti",
    "a": "数据驱动 | 数据密集型 | 数据范式"
  },
  "155": {
    "q": "传统关系数据库的优点包括(）。",
    "t": "muti",
    "a": "数据一致性高 | 数据冗余度低 | 产品成熟度高"
  },
  "156": {
    "q": "大数据处理流程可以概括为()。",
    "t": "muti",
    "a": "数据分析与挖掘 | 数据采集 | 数据储存 | 结果展示"
  },
  "157": {
    "q": "算法“歧视”现象可能岀现的过程有()。",
    "t": "muti",
    "a": "算法设计 | 算法实现 | 算法投入使用"
  },
  "158": {
    "q": "数据增值存在的过程有()。",
    "t": "muti",
    "a": "数据对象的封装 | 数据系统的研发 | 数据的集成应用 | 基于数据的创新"
  },
  "159": {
    "q": "大数据参考架构的三个层次包含()。",
    "t": "muti",
    "a": "角色 | 活动 | 功能组件"
  },
  "160": {
    "q": "分布式列式存储的功能有( )。",
    "t": "muti",
    "a": "支持在线快速读写 | 支持线性扩展 | 具备节点监控管理"
  },
  "161": {
    "q": "下列关于现阶段大数据技术体系的说法正确的有()",
    "t": "muti",
    "a": "基础设施提供数据计算、数据存储、数据加工(Data Wrangling或Data Munging) 等服务 | 数据流处理、统计工具、日志分析都属于常用的开源工具 | 数据资源代表的是生成数据的机构 | 数据源与App为数据科学和大数据产业生态系统提供数据内容"
  },
  "162": {
    "q": "可视分析学是一门以可视交互为基础,综合运用()等技术等多个学科领域的知识，以实现人机协同完成可视化任务为主要目的的分析推理学科。",
    "t": "muti",
    "a": "图形学 | 数据挖掘 | 人机交互"
  },
  "163": {
    "q": "可视分析学的特点包含（）。",
    "t": "muti",
    "a": "强调数据到知识的转换过程 | 强调可视化分析与自动化建模之间的相互作用 | 强调数据映射和数据挖掘的重要性 | 强调数据加工（Data Wrangling或Data Munging ）工作的必要性 | 强调人机交互的重要性"
  },
  "164": {
    "q": "区块链是（）等计算机技术的新型应用模式。",
    "t": "muti",
    "a": "[{\"A\":\"分布式数据存储\"},{\"B\":\"点对点传输<br>共识机制\tD.加密算法\"}] | ！题错！选A,B,C,D"
  },
  "165": {
    "q": "数据科学项目主要涉及的活动包括（）。",
    "t": "muti",
    "a": "模式/模型的应用及维护 | 模式/模型的洞见 | 结果的可视化与文档化 | 模式/模型的验证和优化"
  },
  "166": {
    "q": "数据科学以数据尤其是大数据为研究对象，主要研究内容包括（）。",
    "t": "muti",
    "a": "数据加工 | 数据管理 | 数据计算 | 数据产品开发"
  },
  "167": {
    "q": "数据科学基本原则中，“三世界\"原则指的是（）。",
    "t": "muti",
    "a": "精神世界 | 数据世界 | 物理世界"
  },
  "168": {
    "q": "完整性约束通常包括（）。.",
    "t": "muti",
    "a": "实体完整性 | 域完整性 | 参照完整性 | 用户定义完整性"
  },
  "169": {
    "q": "在数据安全领域常用的P2DR模型中，P、D和R代表的是（）。",
    "t": "muti",
    "a": "策略 | 防护 | 检测 | 响应"
  },
  "170": {
    "q": "下列说法中正确的有（）。",
    "t": "muti",
    "a": "大数据是多源、异构、动态的复杂数据，即具有4V特征的数据 | 大数据是数据科学的研究对象之一 | MapReduce是采用云计算这种新的计算模式研发出的具体工具软件（或算法）"
  },
  "171": {
    "q": "下列描述中属于Analytics2.0主要特点的有（）。",
    "t": "muti",
    "a": "重视非结构化数据的分析 | 以决策支持为主要目的 | 注重解释性分析和预测性分析"
  },
  "172": {
    "q": "下列描述中正确的有（）",
    "t": "muti",
    "a": "统计学是数据科学的理论基础之一 | 机器学习是数据科学的理论基础之一"
  },
  "173": {
    "q": "大数据偏见包括（）。",
    "t": "muti",
    "a": "数据源的选择偏见 | 算法与模型偏见 | 结果解读方法的偏见 | 数据呈现方式的偏见"
  },
  "174": {
    "q": "在数据科学中，计算模式发生了根本性的变化——从集中式计算、分布式计算、网格计算等传统计算过渡至云计算，有一定的代表性的是Google云计算三大技术， 这三大技术包括()。",
    "t": "muti",
    "a": "GFS分布式存储系统 | MapRedue分布式处理技术 | BigTable分布式数据库"
  },
  "175": {
    "q": "假设一个随机变量服从正态分布，则与随机变量的概率分布有关的有()。",
    "t": "muti",
    "a": "平均值 | 方差"
  },
  "176": {
    "q": "下列关于总体和样本的说法正确的有()。",
    "t": "muti",
    "a": "总体也就是研究对象的全体 | 如果总体是某一条生产线上生产的全部产品，那么样本可以是每间隔10s抽取的产品 | 样本是从总体的随机抽样"
  },
  "177": {
    "q": "噪声是指测量变量中的随机错误或偏差，噪声数据的主要表现形式有()。",
    "t": "muti",
    "a": "错误数据 | 假数据 | 异常数据"
  },
  "178": {
    "q": "下列既可以用于分类，又可以用于回归的机器学习算法有（）。",
    "t": "muti",
    "a": "k近邻 | 决策树"
  },
  "179": {
    "q": "EDA （探索性数据分析）方法与传统统计学的验证性分析方法的区别有（）。",
    "t": "muti",
    "a": "EDA中采用的方法往往比验证性分析简单 | 在一瘢1数据科学项目中，探索性分析在先，验证性分析在后 | EDA更为简单、易学和易用"
  },
  "180": {
    "q": "NoSQL数据库常用的数据模型包括（）。",
    "t": "muti",
    "a": "Key-Value | Key-Document | Key-Column | 图存储"
  },
  "181": {
    "q": "ETL包含的过程有（）",
    "t": "muti",
    "a": "数据抽取 | 数据转换 | 数据加载"
  },
  "182": {
    "q": "常用的数据审计方法可以分为（）。",
    "t": "muti",
    "a": "预定义审计 | 自定义审计 | 可视化审计"
  },
  "183": {
    "q": "参数估计可以分为（）",
    "t": "muti",
    "a": "点估计 | 区间估计"
  },
  "184": {
    "q": "下列关于CAP理论说法正确的有（）。",
    "t": "muti",
    "a": "一个分布式系统不能同时满足一致性、可用性和分区容错性等需求 | 一致性主要指强一致性 | 一致性、可用性和分区容错性中的任何两个特征的保证（争取）可能导致另一个 特征的损失（放弃） | 可用性指每个操作总是在给定时间之内得到返回所需要的结果"
  },
  "185": {
    "q": "下列关于降维说法正确的有（）。",
    "t": "muti",
    "a": "PA是据方差这一属性降维的 | 降维降低了数据集特征的维度 | 降维方法有PLA等"
  },
  "186": {
    "q": "下列关于分析学习和归纳学习的比较的说法正确的有（）。",
    "t": "muti",
    "a": "归纳学习拟合数据假设，分析学习拟合领域理论的假设 | 归纳学习论证方式为统计推理，分析学习为演绎推理 | 归纳学习不需要先验知识 | 训练数据不足时归纳学习可能会失败"
  },
  "187": {
    "q": "假设检验中，首先需要提出零假设和备择假设，下列关于零假设和备择假设的描述正确的有（）。",
    "t": "muti",
    "a": "零假设是希望推翻的结论；备择假设是希望证明的结论 | 零假设是只有出现的概率小于阈值才会被拒绝的；备择假设是只有零假设出现的 概率小于阈值才会被承认的"
  },
  "188": {
    "q": "可视化高维展示技术在展示数据之间的关系以及数据分析结果方面能够（）。",
    "t": "muti",
    "a": "直观反映多维数据之间的空间关系 | 动态演化事物的变化及变化的规律<br>E,提供高性能并行计算技术的强力支撑"
  },
  "189": {
    "q": "列式数据库（如BigTable和HBase ）以表的形式存储数据，表结构包含的元素（ ）",
    "t": "muti",
    "a": "关键字 | 时间戳 | 列簇"
  },
  "190": {
    "q": "主要用来实现实时计算类应用的组件有（）。",
    "t": "muti",
    "a": "流计算组件 | 内存计算组件"
  },
  "191": {
    "q": "下列为离散型变量的有（）。",
    "t": "muti",
    "a": "过去数月的总销售额 | 公司每年的红利"
  },
  "192": {
    "q": "下列关于数据流转和应用的说法正确的有（）。",
    "t": "muti",
    "a": "数据流转和应用过程中应确保可追溯、可复查 | 前序环节应保证数据的真实、完整 | 前序环节应及时传递到后序环节 | 前后环节数据应保持衔接一致"
  },
  "193": {
    "q": "下列描述中属于特征选择的优点有（）。",
    "t": "muti",
    "a": "减少过拟合 | 提升模型的性能 | 增强模型的泛化能力"
  },
  "194": {
    "q": "数据挖掘算法的组件包括（）。",
    "t": "muti",
    "a": "模型或模型结构 | 评分函数 | 优化和搜索方法 | 数据管理策略"
  },
  "195": {
    "q": "特征工程一般需要做的工作包含（）。",
    "t": "muti",
    "a": "特征处理 | 特征选择"
  },
  "196": {
    "q": "下列关于数据科学中常用统计学知识的说法错误的有（）。",
    "t": "muti",
    "a": "从行为目的与思维方式看，数据统计方法可以分为基本分析方法和元分析方法 | 从方法论角度看，基于统计的数据分析方法又可分为描述统计和推断统计 | 描述统计可分为集中趋势分析、离散趋势分析、参数估计和假设检验 | 推断统计包括采样分布和相关分析"
  },
  "197": {
    "q": "下列关于探索型数据分析常用图表的说法正确的有（）。",
    "t": "muti",
    "a": "探索型数据分析常用的图表包括条形图、直方图、饼图、折线图、散点图、箱型图等 | 在探索型数据分析时应该尽量避免使用饼图，然而在数据报告中可以使用饼图达到更加美观的效果 | 直方图和箱型图都可以用来展示数据的分布情况"
  },
  "198": {
    "q": "下列为传统RDBMS缺点的有（）。",
    "t": "muti",
    "a": "表结构schema扩展不方便 | 全文搜索功能较弱 | 大数据场景下I/O较高 | 存储和处理复杂关系型数据功能较弱"
  },
  "199": {
    "q": "下列为RDBMS中事务遵循原则的有()。",
    "t": "muti",
    "a": "原子性(Atomicity ) | —致性(Consistency ) | 隔离性(Isolation ) | 持久性(Durability )"
  },
  "200": {
    "q": "下列关于单样本/检验的说法错误的有()。",
    "t": "muti",
    "a": "当单样本t检验的自由度越来越大时，正态分布越来越趋向于t分布 | 单样本t检验适用于样本量比较多(n&gt;30 )的情况 | t分布的不确定性比正态分布小，其原因是样本数量比较小"
  },
  "201": {
    "q": "下列关于连续型随机变量以及连续型概率密度函数的说法正确的有()。",
    "t": "muti",
    "a": "正态分布是一种连续型随机变量的概率分布 | 可以使用概率密度函数来描述连续型随机变量的概率分布 | 连续型概率密度函数曲线下方的面积之和为1"
  },
  "202": {
    "q": "下列关于单样本Z检验的说法正确的有( )",
    "t": "muti",
    "a": "单样本Z检验适用于样本量较大的情况 | 单样本Z检验假设要检验的统计量(近似)满足正态分布 | 单样本Z检验常用于检验总体平均值是否等于某个常量"
  },
  "203": {
    "q": "下列关于中心极限定理的说法正确的有（）。",
    "t": "muti",
    "a": "中心极限定理说明，对于大量相互独立的随机变量，其均值的分布以正态分布 为极限 | 中心极限定理为Z检验提供了理论支持 | 中心极限定理是数理统计学和误差分析的基础"
  },
  "204": {
    "q": "下列关于随机变量及其概率分布的说法正确的有（)",
    "t": "muti",
    "a": "随机变量可以分为离散型随机变量和连续型随机变量 | 随机变量的概率分布指的是一个随机变量所有取值的可能性 | 扔5次硬币,正面朝上次数的可能取值是0、1、2、3、4、5,其中正面朝上次数为0与正面朝上次数为5的概率是一样的"
  },
  "205": {
    "q": "下列关于数据维度的描述正确的有（）。",
    "t": "muti",
    "a": "采用列表表示一维数据，不同数据类型的元素是可以的 | JSON格式可以表示比二维数据还复杂的高维数据 | 二维数据可以看成是一维数据的组合形式"
  },
  "206": {
    "q": "下列属于卷积神经网络组成部分的有（ ）。",
    "t": "muti",
    "a": "卷积层 | 池化层 | 全连接层"
  },
  "207": {
    "q": "数据安全不仅包括数据保密性，还包括()",
    "t": "muti",
    "a": "完整性 | 可用性 | 不可否认性 | 可审计性"
  },
  "208": {
    "q": "在网络爬虫的爬行策略中，应用最为常见的有()",
    "t": "muti",
    "a": "深度优先遍历策略 | 广度优先遍历策略"
  },
  "209": {
    "q": "异常值的检测方法有()。",
    "t": "muti",
    "a": "直接通过数据可视化进行观察 | 通过统计分布进行判断 | 通过相对距离进行度量 | 通过相对密度进行度量"
  },
  "210": {
    "q": "在建立模型时，需要用到的数据有()。",
    "t": "muti",
    "a": "训练数据 | 测试数据 | 验证数据"
  },
  "211": {
    "q": "在假设检验中，当原假设为伪，但数据分析人员没有拒绝它时犯的错误叫(",
    "t": "muti",
    "a": "β错误 | 取伪错误"
  },
  "212": {
    "q": "在数据缺失严重时，会对分析结果造成较大的影响，因此对于剔除的异常值和缺失值，要采用合理的方法进行填补。常用的填补方法有()",
    "t": "muti",
    "a": "平均值填充 | K最近邻距高法 | 回归法 | 极大似然估计 | 多重插补法"
  },
  "213": {
    "q": "主要面向或关注过去的数据分析过程有（）。",
    "t": "muti",
    "a": "描述性分析 | 诊断性分析"
  },
  "214": {
    "q": "噪声数据的产生原因主要有（）。",
    "t": "muti",
    "a": "数据采集设备有问题 | 在数据录入过程中发生了人为或计算机错误 | 数据传输过程中发生错误 | 由于命名规则或数据代码不同而引起的不一致"
  },
  "215": {
    "q": "数据故事化描述应遵循的基本原则有（）。",
    "t": "muti",
    "a": "忠于原始数据原则 | 设定共同场景原则 | 有效性利用原则 | 3C精神原则"
  },
  "216": {
    "q": "使用极大似然估计的前提条件有（）。",
    "t": "muti",
    "a": "数据服从某种已知的特定数据分布型 | 已经得到了 一部分数据集"
  },
  "217": {
    "q": "DGI定义的数据治理任务包括（）。",
    "t": "muti",
    "a": "主动定义或序化规则 | 为数据利益相关者提供持续跨职能的保护与服务 | 应对并解决因不遵守规则而产生的问题"
  },
  "218": {
    "q": "下列属于大数据的资产属性体现的方面有（）。",
    "t": "muti",
    "a": "具有劳动增值 | 涉及法律权属 | 具有财务价值 | 涉及道德与伦理"
  },
  "219": {
    "q": "下列关于数据产品研发的说法错误的有（）。",
    "t": "muti",
    "a": "从加工程度看，可以将数据分为一次数据、二次数据和三次数据 | 一次数据中往往存在缺失值、噪声、错误或虚假数据等质量问题 | 三次数据是对二次数据进行洞察与分析后得到的、可以直接用于决策支持的洞见数据"
  },
  "220": {
    "q": "数据来源和目标用户已定的情况下，不同视觉通道的表现力不同。视觉通道的表现力的评价指标包括()。",
    "t": "muti",
    "a": "精确性 | 可辨认性 | 可分离性 | 视觉突出性"
  },
  "221": {
    "q": "已定义级(Defined Level)的主要特点包括()。",
    "t": "muti",
    "a": "组织机构已明确给出了关键过程的标准定义，并定期对其进行改进 | 已提供了关键过程的测量与预测方法 | 关键过程的执行过程并不是简单或死板地执行组织机构给出的标准定义，而是根据具体业务进行了一定的裁剪工作 | 数据的重要性已成为组织机构层次的共识，将数据当作成功实现组织机构使命的 关键因素之一"
  },
  "222": {
    "q": "已测量级(Measured Level)的主要特点包括()。",
    "t": "muti",
    "a": "已构建了关键过程矩阵 | 已定义了变革管理的正式流程 | 已实现用定量化方式计算关键过程的质量和效率 | 关键过程的质量和效率的管理涉及整个生命周期"
  },
  "223": {
    "q": "数据管理包含的管理活动有（）。",
    "t": "muti",
    "a": "识别 | 度量 | 监控 | 预警"
  },
  "224": {
    "q": "数据从产生到终结共包含的环节有（）。",
    "t": "muti",
    "a": "数据产生 | 数据传输 | 数据使用 | 数据共享 | 数据销毁"
  },
  "225": {
    "q": "下列属于数据统计分析工具的有（）。",
    "t": "muti",
    "a": "Weka | SAS | SPSS | Matlab"
  },
  "226": {
    "q": "数据科学流程的特殊性在于需要将科学家的3C精神融入业务流程之中。()",
    "t": "judge",
    "a": "正确"
  },
  "227": {
    "q": "半结构化数据是经过一定转换处理后可以用传统关系数据库存储和管理的数据。()",
    "t": "judge",
    "a": "正确"
  },
  "228": {
    "q": "数据挖掘的目的是发现数据集中的模式或规律，数据挖掘有监督学习和无监督学习两种方式。（）",
    "t": "judge",
    "a": "正确"
  },
  "229": {
    "q": "数据预处理在实际的数据挖掘项目中是花费时间最长也是最为烦琐的步骤。（）",
    "t": "judge",
    "a": "正确"
  },
  "230": {
    "q": "数据体现业务本质和内涵，遵从业务的逻辑和关联关系，依据业务才能更好实现对数据的全寿命周期统一管理。（）",
    "t": "judge",
    "a": "正确"
  },
  "231": {
    "q": "数据产品的存在形式为数据集。（）",
    "t": "judge",
    "a": "错误"
  },
  "232": {
    "q": "数据已成为公司的战略核心资产，各类数据在公司生产运行、经营管理、客户服务等领域发挥重要作用，同时，网站门户、在线业务应用和通信群组的内容安全已成 为国家网络意识形态安全的重要组成部分。()",
    "t": "judge",
    "a": "正确"
  },
  "233": {
    "q": "非结构化数据是可以直接用传统关系数据库存储和管理的数据。()",
    "t": "judge",
    "a": "错误"
  },
  "234": {
    "q": "数据类型的多样性往往导致数据的同质性，进而加大数据处理的复杂性。（）",
    "t": "judge",
    "a": "错误"
  },
  "235": {
    "q": "建立数据仓库的过程一般包括清洗、抽取数据操作，统一数据格式，设定自动程序以定时抽取操作数据并自动更新数据仓库，预先执行合计计算等步骤。（）",
    "t": "judge",
    "a": "正确"
  },
  "236": {
    "q": "对遗漏数据的处理方法主要有忽略该条记录，手工填补遗漏值，利用默认值填补遗漏值，利用均值填补遗漏值，利用同类别均值填补遗漏值，利用最可能的值填充遗漏值。（）",
    "t": "judge",
    "a": "正确"
  },
  "237": {
    "q": "数据质量管理工作是指建立数据质量检查规则并运用数据质量检查规则与技术手段，对数据质量问题进行跟踪、检查、分析、评价、督促整改并定期进行数据质量 通报评价等工作。（）",
    "t": "judge",
    "a": "正确"
  },
  "238": {
    "q": "数据产品不仅包括数据科学项目的最终产品，而且也包括其中间产品以及副产品。（）",
    "t": "judge",
    "a": "正确"
  },
  "239": {
    "q": "数据产品的存在形式为数据集。（）",
    "t": "judge",
    "a": "错误"
  },
  "240": {
    "q": "数据产品开发涉及数据科学项目流程的部分活动。（）",
    "t": "judge",
    "a": "错误"
  },
  "241": {
    "q": "非结构化数据的管理往往采用NoSQL, NewSQL或关系云技术。()",
    "t": "judge",
    "a": "正确"
  },
  "242": {
    "q": "分布式数据库是指物理上分散在不同的地点，但在逻辑上是统一的数据库。因此，分布式数据库具有物理上的独立性、逻辑上的一体性、性能上的可扩展性等特点。()",
    "t": "judge",
    "a": "正确"
  },
  "243": {
    "q": "数据科学是根据数据世界的分析结果，对现实世界进行预测、洞见、解释或决策的新兴科学。（）",
    "t": "judge",
    "a": "正确"
  },
  "244": {
    "q": "大数据分析是对总体数据，尤其是针对传统手段捕捉到的数据之外的非结构化数据进行分析。（）",
    "t": "judge",
    "a": "正确"
  },
  "245": {
    "q": "基于大数据的数据真实性分析技术能够提高垃圾信息的鉴别能力。（）",
    "t": "judge",
    "a": "正确"
  },
  "246": {
    "q": "二次指数平滑法有多期预测能力，短期预测效果较好。（）",
    "t": "judge",
    "a": "错误"
  },
  "247": {
    "q": "通常把分类错误的样本数量与分类正确样本数量的比例称为错误率。（）",
    "t": "judge",
    "a": "错误"
  },
  "248": {
    "q": "信息嫡是度量样本集合纯度最常用的一种指标，其值越小，表明样本集合的纯度越高。（）",
    "t": "judge",
    "a": "正确"
  },
  "249": {
    "q": "类别不平衡就是指分类任务中相同类别的训练样例数目差别很大的情况。（）",
    "t": "judge",
    "a": "错误"
  },
  "250": {
    "q": "数据分析一般指用统计分析方法对收集来的少量数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。（）",
    "t": "judge",
    "a": "错误"
  },
  "251": {
    "q": "从数据流的视角看，数据产品的开发过程是一个数据加工（Data Wrangling或Data Munging）的过程。（）",
    "t": "judge",
    "a": "正确"
  },
  "252": {
    "q": "数据管理是指通过管理数据实现组织机构的某种业务目的。而数据治理则指的是如何确保数据管理的顺利、科学、有效进行。（）",
    "t": "judge",
    "a": "正确"
  },
  "253": {
    "q": "数据科学家需要拥有数据产品的研发能力，不需要团队合作与协同工作。（）",
    "t": "judge",
    "a": "错误"
  },
  "254": {
    "q": "数据科学家应该学会数据科学的基础理论，尤其是其主要理念、原则、理论和方法。（）",
    "t": "judge",
    "a": "正确"
  },
  "255": {
    "q": "数据服务是指针对用户不太明确的数据查询和处理任务，以高性能和高吞吐量的方式实现大众化的服务，是数据价值最重要也是最直接的发现方式。（）",
    "t": "judge",
    "a": "错误"
  },
  "256": {
    "q": "大数据的存储方案通常对一份数据在不同节点上存储多份副本，以提高系统容错性。()",
    "t": "judge",
    "a": "正确"
  },
  "257": {
    "q": "机器学习为数据科学中充分发挥计算机的自动数据处理能力，拓展人的数据处理能力以及实现人机协同数据处理提供了重要手段。（）",
    "t": "judge",
    "a": "正确"
  },
  "258": {
    "q": "特征提取技术并不依赖于特定的领域。（）",
    "t": "judge",
    "a": "错误"
  },
  "259": {
    "q": "诊断性分析是描述性分析的基础。（）",
    "t": "judge",
    "a": "错误"
  },
  "260": {
    "q": "离群点可以是合法的数据对象或者值。（）",
    "t": "judge",
    "a": "正确"
  },
  "261": {
    "q": "基于集中式架构，融合结构化、非结构化、海量历史/准实时和电网地理信息四类数据中心，整合、优化公司现有技术组件，构建公司级大数据平台。（）",
    "t": "judge",
    "a": "错误"
  },
  "262": {
    "q": "数据加工（Data Wrangling或Data Mtmging ）的本质是将高层次数据转化为低层次数据的过程。（）",
    "t": "judge",
    "a": "错误"
  },
  "263": {
    "q": "___ 是一个高可靠性、髙性能、面向列、可伸缩的系统，可在廉价PC服务器上搭建起大规模结构化存储集群。",
    "t": "fill",
    "a": "HBase&分布式"
  },
  "264": {
    "q": "从学科定位看，数据科学处于___、___和___三大领域的重叠之处。",
    "t": "fill",
    "a": "数学与统计知识|黑客精神与技能|领域实务知识"
  },
  "265": {
    "q": "___ 是一种意识，认为公开的数据一旦处理得当就能为千百万人急需解决的问题提供答案。",
    "t": "fill",
    "a": "大数据思维"
  },
  "266": {
    "q": "数据科学领域常用的工具之一——___是统计学家发明的语言。",
    "t": "fill",
    "a": "R语言"
  },
  "267": {
    "q": "___ 的目的是缩小数据的取值范围，使其更适合数据挖掘算法的需要，并且能够得到和原始数据相同的分析结果。",
    "t": "fill",
    "a": "数据归约"
  },
  "268": {
    "q": "___ 是指将物理或抽象对象的集合分组成为由类似的对象组成的多个类的过程。",
    "t": "fill",
    "a": "聚类"
  },
  "269": {
    "q": "根据能否清晰地表述和有效地转移，将知识分为___和___两种。",
    "t": "fill",
    "a": "显性知识|隐性知识"
  },
  "270": {
    "q": "大数据是以容量大、类型多、存取速度快、 ___ 为主要特征的数据集合。",
    "t": "fill",
    "a": "应用价值高"
  },
  "271": {
    "q": "___ 可以便于人们对数据的理解。",
    "t": "fill",
    "a": "数据可视化"
  },
  "272": {
    "q": "大数据包括结构化、半结构化和非结构化数据，其中 ___ 为数据的主要部分。",
    "t": "fill",
    "a": "非结构化数据"
  },
  "273": {
    "q": "下列关于MapReduce说法不正确的是（）。",
    "t": "single",
    "a": "MapReduce程序只能用java语言编写"
  },
  "274": {
    "q": "MapReduce 计算框架的输入数据结构是（）。",
    "t": "single",
    "a": "key-value"
  },
  "275": {
    "q": "解决Master故障的方法是设置检查点，当Master失效时，从（ ）检查点开始启动另一个Master进程。",
    "t": "single",
    "a": "最后一个"
  },
  "276": {
    "q": "在MapReduce中，reduce （）函数可以将（）值相同的输入进行合并处理。",
    "t": "single",
    "a": "key"
  },
  "277": {
    "q": "MapReduce中，Shuffle操作的作用是（）。",
    "t": "single",
    "a": "排序"
  },
  "278": {
    "q": "为了降低MapReduce两个阶段之间的数据传递量，一般采用()函数对map阶段的输岀进行处理。",
    "t": "single",
    "a": "combiner ()"
  },
  "279": {
    "q": "下列业务场景中,不能直接使用Reducer充当Combiner的是()。",
    "t": "single",
    "a": "avg求平均"
  },
  "280": {
    "q": "在MapReduce中，通常将Map拆分成M个片段、Reduce拆分成R个片段，下列描述错误的是()",
    "t": "single",
    "a": "Master在内存中保存O (M+R )个状态"
  },
  "281": {
    "q": "通常落伍者是影响MapReduce总执行时间的主要影响因素之一，为此MapReduce采用()机制来解决。",
    "t": "single",
    "a": "推测性执行的任务备份"
  },
  "282": {
    "q": "下列组件中MapReduce编程模型中最后执行的是（）。",
    "t": "single",
    "a": "Reducer"
  },
  "283": {
    "q": "下列操作中MapReduce的Shuflfle阶段最后做的是（）",
    "t": "single",
    "a": "合并"
  },
  "284": {
    "q": "在MapReduce中，下列组件中用户不指定也不会有默认的是（）。",
    "t": "single",
    "a": "Combiner"
  },
  "285": {
    "q": "执行一个job、如果这个job的输岀路径已经存在，那么程序会（）。",
    "t": "single",
    "a": "抛出一个异常，然后退出"
  },
  "286": {
    "q": "<br>在MapReduce中，下列描述错误的是（）。",
    "t": "single",
    "a": "map （）函数是确定的，用户不可自定义"
  },
  "287": {
    "q": "在MapReduce中,下列描述错误的是( )",
    "t": "single",
    "a": "Map和Reduce的处理结果都存储在本地文件系统"
  },
  "288": {
    "q": "在MapReduce中，为了发现Worker故障，Master周期性进行的操作是( )。",
    "t": "single",
    "a": "Ping"
  },
  "289": {
    "q": "MapReduce使用（）来记录不同时间的发生次数。",
    "t": "single",
    "a": "[{\"A\":\"日志\"},{\"B\":\"事件触发器<br>B.状态列表D.计数器\"}] | ！题错！选D"
  },
  "290": {
    "q": "MapReduce对map ()函数的返回值进行处理后再返回给reduce ( )函数的目的是( )。",
    "t": "single",
    "a": "减少map ()函数和reduce ()函数之间的数据传输"
  },
  "291": {
    "q": "一个MapReduce程序中的MapTask的个数由()决定。",
    "t": "single",
    "a": "FilelnputFormat.getSplits ( JobContextjob )计算出的逻辑切片的数量"
  },
  "292": {
    "q": "下列关于新旧MapReduceAPI的描述错误的是()。",
    "t": "single",
    "a": "新API倾向于使用接口方式，而旧API倾向于使用抽象类"
  },
  "293": {
    "q": "()计算框架源自一种分布式计算模型，其输入和输出值均为键值对结构。",
    "t": "single",
    "a": "MapReduce"
  },
  "294": {
    "q": "MapReduce 适用于()。",
    "t": "single",
    "a": "[{\"A\":\"任意应用程序\"},{\"B\":\"任意可在 Windows Servet 2008上运行的程序<br>D.\t可以串行处理的应用程序<br>D.\t可以并行处理的应用程序\"}] | ！题错！选D"
  },
  "295": {
    "q": "下列关于MapReduce计算框架中生成键值对的说法正确的是（）。",
    "t": "single",
    "a": "可以有相同的键，也可以有相同的值"
  },
  "296": {
    "q": "在MapReduce计算架构中,（）组件运行在DataNode上，具体管理本节点计算任务的执行。",
    "t": "single",
    "a": "TaskTracker"
  },
  "297": {
    "q": "MapReduce编程模型,键值对＜key, value＞的key必须实现（）接口。",
    "t": "single",
    "a": "WritableComparable"
  },
  "298": {
    "q": "MapReduce里面的query、sort和limit等都是针对（）的操作。",
    "t": "single",
    "a": "map ()之前"
  },
  "299": {
    "q": "在 Hadoop MapReduce 中,( ）是客户端需要执行的一个工作单元。",
    "t": "single",
    "a": "Job"
  },
  "300": {
    "q": "下列关于SecondaryNameNode的说法正确的是（）。",
    "t": "single",
    "a": "它的目的是帮助NameNode合并编辑日志，减少NameNode的负担和冷启动时的 加载时间"
  },
  "301": {
    "q": "（）通常与NameNode在一个节点启动。",
    "t": "single",
    "a": "JobTracker"
  },
  "302": {
    "q": "（）负责MapReduce任务调度。",
    "t": "single",
    "a": "Jobtracker"
  },
  "303": {
    "q": "下列关于DataNode的描述错误的是（）。",
    "t": "single",
    "a": "文件的副本系数由DataNode储存"
  },
  "304": {
    "q": "Hadoop MapReduce 2.0中，()负责资源的管理和调度。",
    "t": "single",
    "a": "YARN"
  },
  "305": {
    "q": "Hadoop 中 partition ()函数代表的是()。",
    "t": "single",
    "a": "分区函数"
  },
  "306": {
    "q": "下列关于Hadoop中MapReduce的说法正确的是()。",
    "t": "single",
    "a": "可以没有Reduce任务"
  },
  "307": {
    "q": "MapReduce任务Map输出结果将被写入( )",
    "t": "single",
    "a": "磁盘(Linux文件系统)"
  },
  "308": {
    "q": "Hadoop中,Reducer的三个步骤是()。",
    "t": "single",
    "a": "Shuffle—Sort—Reduce"
  },
  "309": {
    "q": "MapReduce默认的分区函数是（）。",
    "t": "single",
    "a": "hash"
  },
  "310": {
    "q": "相对于 HadoopMapReducel.0, Spark 的特点不包括（）。",
    "t": "single",
    "a": "并发多"
  },
  "311": {
    "q": "Hadoop生态系统中，HBase是一种（）。",
    "t": "single",
    "a": "实时分布式数据库"
  },
  "312": {
    "q": "<br>HBase依靠（）存储底层数据。",
    "t": "single",
    "a": "HDFS"
  },
  "313": {
    "q": "HBase作为数据存储组件封装于大数据平台，用于（）。",
    "t": "single",
    "a": "非关系型数据库存储"
  },
  "314": {
    "q": "HBase依靠（）提供消息通信机制。",
    "t": "single",
    "a": "ZooKeeper"
  },
  "315": {
    "q": "HBase依靠（）提供强大的计算能力。",
    "t": "single",
    "a": "MapReduce"
  },
  "316": {
    "q": "HBase是一种可伸缩、高可靠、高性能、分布式和面向（）的动态模式数据库。",
    "t": "single",
    "a": "列"
  },
  "317": {
    "q": "HBase的一个典型应用是Webtable,它是一个以网页（）为主键的表。",
    "t": "single",
    "a": "URL<br>D.内容\tD.类别"
  },
  "318": {
    "q": "HBase使用一个（）节点协调管理一个或多个RegionServer从属机。",
    "t": "single",
    "a": "Master"
  },
  "319": {
    "q": "HDFS是基于流数据模式访问和处理超大文件的需求而开发的，具有高容错、高可靠性、高可扩展性、高吞吐率等特征，适合的读写任务是（）。",
    "t": "single",
    "a": "一次写入、多次读取"
  },
  "320": {
    "q": "下列关于 HDFS 特征的说法错误的是（）",
    "t": "single",
    "a": "低吞吐量"
  },
  "321": {
    "q": "如果我们现有一个安装2.6.5版本的 Hadoop集群，在不修改默认配置的情况下存储200个200M的文本文件，那么最终会在集群中产生（）个数据块（包括副本）。",
    "t": "single",
    "a": "1200"
  },
  "322": {
    "q": "下列进程中不是 HDFS 的守护进程的是（)。",
    "t": "single",
    "a": "MRAppMaster / YarnChild"
  },
  "323": {
    "q": "下列描述中不属于 HDFS 集群中的 NameNode 职责的是（）<br>",
    "t": "single",
    "a": "负责保存客户端上传的数据"
  },
  "324": {
    "q": "HDFS是 Hadoop 平台上的分布式文件系统，它是由（）组成的。",
    "t": "single",
    "a": "一个NameNode、一个SecondaryNameNode 和多个DataNode"
  },
  "325": {
    "q": "(）不是 HDFS 的设计目标。",
    "t": "single",
    "a": "多次写入，多次读取的文件访问模型"
  },
  "326": {
    "q": "(）负责 HDFS 数据存储。",
    "t": "single",
    "a": "DataNode"
  },
  "327": {
    "q": "Hadoop 环境下 HDFS 系统中的 NameNode 实现的功能是（）",
    "t": "single",
    "a": "管理文件系统的命名空间"
  },
  "328": {
    "q": "<br>客户端从HDFS上读取数据时会（ ）。",
    "t": "single",
    "a": "从NameNode上获取Block位置"
  },
  "329": {
    "q": "下列关于HDFS的描述正确的是（）。",
    "t": "single",
    "a": "NameNode磁盘元数据不保存Block的位置信息"
  },
  "330": {
    "q": "在HDFS中，（）是文件系统的工作节点。",
    "t": "single",
    "a": "DataNode"
  },
  "331": {
    "q": "（）与HDFS类似，均为分布式文件系统。",
    "t": "single",
    "a": "GFS"
  },
  "332": {
    "q": "在Hadoop生态系统中，（ ）可以将结构化的数据文件映射成一张数据库表，并提供简单的查询语言。",
    "t": "single",
    "a": "Hive"
  },
  "333": {
    "q": "Hive的数据最终存储在（ ）中。",
    "t": "single",
    "a": "HDFS"
  },
  "334": {
    "q": "下列关于Hive说法正确的是（）。",
    "t": "single",
    "a": "一种数据仓库工具"
  },
  "335": {
    "q": "下列数据类型Hive不支持的是（）。",
    "t": "single",
    "a": "Long"
  },
  "336": {
    "q": "DataFrame和RDD最大的区别是（ ）",
    "t": "single",
    "a": "DataFrame 多了schema"
  },
  "337": {
    "q": "（）是Spark的核心数据结构。",
    "t": "single",
    "a": "弹性分布式数据集"
  },
  "338": {
    "q": "Spark的（）组件用于支持实时计算需求。",
    "t": "single",
    "a": "SparkStreaming"
  },
  "339": {
    "q": "为了提高系统性能，Spark采取惰性计算模式。下列关于惰性计算模式的描述正确的是（）。",
    "t": "single",
    "a": "执行Transformation操作时不会提交，只有执行Action操作时才会被提交到集 群中开始被执行"
  },
  "340": {
    "q": "Spark Job默认的调度模式是（）。",
    "t": "single",
    "a": "FIFO"
  },
  "341": {
    "q": "Spark的集群管理模式不包含（）。",
    "t": "single",
    "a": "Message 模式"
  },
  "342": {
    "q": "Spark核心层主要关注的问题是()。",
    "t": "single",
    "a": "计算"
  },
  "343": {
    "q": "当( )时,可以不考虑RDD序列化处理。",
    "t": "single",
    "a": "实时性要求高"
  },
  "344": {
    "q": "在Spark中，()是指RDD的每个分区都只被子RDD的一个分区所依赖。",
    "t": "single",
    "a": "窄依赖"
  },
  "345": {
    "q": "RDD默认的存储级别是()。",
    "t": "single",
    "a": "MEMORY__ONLY"
  },
  "346": {
    "q": "（）是窄依赖操作。",
    "t": "single",
    "a": "filter"
  },
  "347": {
    "q": "（ ）不是RDD的缓存方法。",
    "t": "single",
    "a": "memory"
  },
  "348": {
    "q": "Spark的特点不包括( )。",
    "t": "single",
    "a": "单一操作性"
  },
  "349": {
    "q": "Spark的劣势是()。",
    "t": "single",
    "a": "需要更多机器内存"
  },
  "350": {
    "q": "（ ）属于Spark框架中的可扩展机器学习库。",
    "t": "single",
    "a": "MLib"
  },
  "351": {
    "q": "下列关于Spark的说法错误的是（）。",
    "t": "single",
    "a": "主要用于批处理"
  },
  "352": {
    "q": "（）不是Spark服务层的功能。",
    "t": "single",
    "a": "内存计算"
  },
  "353": {
    "q": "（ ）是Spark中的抽象数据模型。",
    "t": "single",
    "a": "RDD"
  },
  "354": {
    "q": "Spark中引入RDD概念的目的是()。",
    "t": "single",
    "a": "提升容错能力"
  },
  "355": {
    "q": "为提高计算性能，Spark中Transformation操作釆用的计算模式是()。",
    "t": "single",
    "a": "惰性计算模式"
  },
  "356": {
    "q": "()肯定是宽依赖操作。",
    "t": "single",
    "a": "reduceByKey"
  },
  "357": {
    "q": "RDD的特点不包括()",
    "t": "single",
    "a": "RDD可以增量更新"
  },
  "358": {
    "q": "下列不属于Action操作的是（）。",
    "t": "single",
    "a": "filter"
  },
  "359": {
    "q": "下列不属于Transformation操作的是（）。",
    "t": "single",
    "a": "count"
  },
  "360": {
    "q": "Spark中Job的划分依据是（）。",
    "t": "single",
    "a": "Action算子"
  },
  "361": {
    "q": "Spark比MapReduce快的原因不包括（）。",
    "t": "single",
    "a": "Spark支持交互式处理，MapReduce善于处理流计算"
  },
  "362": {
    "q": "（）主要提供内存计算框架。",
    "t": "single",
    "a": "Spark核心层"
  },
  "363": {
    "q": "Spark中Stage下Task的数量由()决定。",
    "t": "single",
    "a": "Partition"
  },
  "364": {
    "q": "DAGScheduler 的作用是()。",
    "t": "single",
    "a": "负责创建执行计划"
  },
  "365": {
    "q": "RDD中的数据被（）在集群中，使得任务可以并行执行。",
    "t": "single",
    "a": "[{\"A\":\"顺序存储\"},{\"B\":\"连续存储<br>D.分块存储\"},{\"C\":\"分区存储\"}] | ！题错！选D"
  },
  "366": {
    "q": "（）用于对RDD中的数据进行计算。",
    "t": "single",
    "a": "算子<br>D.日志\tD.数据块"
  },
  "367": {
    "q": "Spark可以处理的数据任务包括（）。",
    "t": "single",
    "a": "[{\"A\":\"数据流处理\"},{\"B\":\"交互式处理<br>D.图数据处理\tD以上都是\"}] | ！题错！选D"
  },
  "368": {
    "q": "大数据平台技术架构不包含（）。",
    "t": "single",
    "a": "[{\"A\":\"数据整合\"},{\"B\":\"数据存储<br>D.数据计算 D.数据溯源\"}] | ！题错！选D"
  },
  "369": {
    "q": "依托（）,结合应用推进数据归集，形成统一的数据资源中心。",
    "t": "single",
    "a": "全业务数据中心和数据平台"
  },
  "370": {
    "q": "在Hadoop生态系统中，（）建立在MapReduce之上，主要用来弥补MapReduce<br>编程的复杂性。",
    "t": "single",
    "a": "Pig"
  },
  "371": {
    "q": "（）的主要目标是提供可扩展的机器学习算法及其实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。",
    "t": "single",
    "a": "Mahout"
  },
  "372": {
    "q": "在Hadoop生态系统中，（）主要解决的是日志类数据的收集和处理问题。",
    "t": "single",
    "a": "Flume"
  },
  "373": {
    "q": "在Hadoop生态系统中，（ ）的主要设计目的是在Hadoop与传统数据库之间进行数据的ETL操作。",
    "t": "single",
    "a": "Sqoop"
  },
  "374": {
    "q": "下列关于ZooKeeper特点的描述错误的是（）。",
    "t": "single",
    "a": "复杂性"
  },
  "375": {
    "q": "在Hadoop中,（）执行文件系统命名空间操作。",
    "t": "single",
    "a": "NameNode"
  },
  "376": {
    "q": "分布式应用程序可以基于分布式应用程序协调服务实现同步服务，配置维护和命 名服务等的工具是（ ）",
    "t": "single",
    "a": "Zookeeper"
  },
  "377": {
    "q": "下列关于Sqoop的说法不正确的是（）。",
    "t": "single",
    "a": "Sqoop的Reduce操作速度更快"
  },
  "378": {
    "q": "下列关于Hadoop的说法错误的是（）。",
    "t": "single",
    "a": "它是最好的实时流式数据处理框架"
  },
  "379": {
    "q": "在Hadoop的分区阶段，默认的Partitioner是（ ）。",
    "t": "single",
    "a": "HashPartitioner"
  },
  "380": {
    "q": "在Hadoop中，（）是默认的InputFormat类型，它将每行内容作为新值，而将字节偏移量作为key。",
    "t": "single",
    "a": "TextlnputFormat"
  },
  "381": {
    "q": "大数据平台核心分布式存储与计算组件采用Hadoop技术体系中的分布式存储、分布式计算框架及Spark等开源产品和技术，实现对数据的安全控制和管理功能，其中分布式存储不包括（）。",
    "t": "single",
    "a": "Postgresql"
  },
  "382": {
    "q": "大数据平台构建分布式文件系统、分布式数据仓库、非关系型数据库、关系型数据库，实现各类数据的集中存储与统一管理，满足（）存储需求。",
    "t": "single",
    "a": "多样化数据"
  },
  "383": {
    "q": "HBase中KeyValue数据的存储格式是（）。",
    "t": "single",
    "a": "HFile"
  },
  "384": {
    "q": "在数据科学中，计算模式发生了根本性的变化——从集中式计算、分布式计算、网格计算等传统计算过渡至云计算，有一定的代表性的是Google云计算三大技术包括（）。",
    "t": "muti",
    "a": "GFS分布式存储系统 | MapReduce分布式处理技术 | BigTable分布式术语库"
  },
  "385": {
    "q": "MapReduce对map （ ）函数的返回值处理后才传给reduce（ ）函数，其中涉及的操作有（）。",
    "t": "muti",
    "a": "合并 | 排序 | 分区"
  },
  "386": {
    "q": "下列中属于MapReduce特征的有（ ）。",
    "t": "muti",
    "a": "以主从结构的形式运行 | 容错机制的复杂性 | 任务备份机制的必要性"
  },
  "387": {
    "q": "MapReduce中运行程序副本程序的机器有（）",
    "t": "muti",
    "a": "Master服务器 | Worker服务器"
  },
  "388": {
    "q": "在 MapReducel.O 版本中，JobTracker 功能有（）。",
    "t": "muti",
    "a": "资源管理 | 作业控制<br>D.作业存储\tD.作业审核"
  },
  "389": {
    "q": "下列关于MapReducel.O版本的说法正确的有（）。",
    "t": "muti",
    "a": "扩展性差 | 可靠性差 | 资源利用率低 | 无法支持多种计算框架"
  },
  "390": {
    "q": "下列服务中可以用于存储数据的有（）。",
    "t": "muti",
    "a": "HBase | HDFS"
  },
  "391": {
    "q": "下列有关MapReduce计算框架的描述正确的有（）。",
    "t": "muti",
    "a": "MapReduce可以计算任务的划分和调度 | MapReduce可完成数据的分布存储和划分 | MapReduce可以实现处理系统节点出错检测和失效恢复 | MapReduce可实现处理数据与计算任务的同步"
  },
  "392": {
    "q": "Hadoop MapReduce 是 MapReduce 的具体实现之一。Hadoop MapReduce 数据处理过程涉及四个独立的实体，包括（）。",
    "t": "muti",
    "a": "Client | JobTracker | TaskTracker | HDFS"
  },
  "393": {
    "q": "下列关于MapReduce与HBase关系的描述正确的有( )",
    "t": "muti",
    "a": "两者不是强关联关系，没有MapReduce, HBase可以正常运行 | MapReduce可以直接访问HBase"
  },
  "394": {
    "q": "下列关于Hadoop MapReduce的描述正确的有()。",
    "t": "muti",
    "a": "reduce ()函数将最终结果写到HDFS系统中 | 用户可以自己定义reduce ( )函数 | reduce ()函数的输入数据是经过map ( )函数处理之后的数据"
  },
  "395": {
    "q": "从Hadoop实现角度看，Hadoop MapReduce 1.0主要由()组成。",
    "t": "muti",
    "a": "编程模型 | 数据处理引擎 | 运行时环境"
  },
  "396": {
    "q": "下列关于Hadoop中map输出结果的说法正确的有（）。",
    "t": "muti",
    "a": "<key,value>&lt;key, value&gt; 键值对</key,value> | 输出中间临时结果"
  },
  "397": {
    "q": "下列关于HBase的说法正确的有（）。",
    "t": "muti",
    "a": "面向列的数据库 | 非结构化的数据库 | 支持大规模的随机、实时读写 | 采用松散数据模型"
  },
  "398": {
    "q": "下列属于HBase性能优化的有（）。",
    "t": "muti",
    "a": "读优化 | 写优化 | 配置优化 | JVM优化"
  },
  "399": {
    "q": "Hadoop的HDFS是一种分布式文件系统，其适合（）的数据存储和管理。",
    "t": "muti",
    "a": "高容错、高吞吐量 | 流式数据访问"
  },
  "400": {
    "q": "基于Hadoop开源大数据平台主要提供了针对数据分布式计算和存储能力，如下属于分布式存储组件的有（）。",
    "t": "muti",
    "a": "HDFS | HBase"
  },
  "401": {
    "q": "下列关于HDFS文件写入的描述正确的有（）。",
    "t": "muti",
    "a": "不支持多用户对同一文件的写操作 | 用户不可以在文件任意位置进行修改 | 默认将文件复制成三份存放 | 复制的文件块默认不存在同一机架上"
  },
  "402": {
    "q": "下列关于Hive的说法正确的有（）。",
    "t": "muti",
    "a": "Hive是基于Hadoop的数据仓库工具 | Hive可以将结构化的数据文件映射为一张数据库表 | Hive的主要应用场景是离线分析"
  },
  "403": {
    "q": "在Hive架构中，支持的数据操作有（）。",
    "t": "muti",
    "a": "查询 | 分析"
  },
  "404": {
    "q": "Spark2.0提供的应用库包括（）。",
    "t": "muti",
    "a": "SparkSQL | SparkStreaming | MLib | GraphX"
  },
  "405": {
    "q": "Spark的组件包括（）。",
    "t": "muti",
    "a": "SparkStreaming | MLib | GraphX"
  },
  "406": {
    "q": "在Spark中，弹性分布式数据集的特点包括（）。",
    "t": "muti",
    "a": "可分区 | 可序列化 | 可持久化"
  },
  "407": {
    "q": "SparkRDD的依赖机制包括（）。",
    "t": "muti",
    "a": "宽依赖 | 窄依赖"
  },
  "408": {
    "q": "Spark的部署模式包括（）。",
    "t": "muti",
    "a": "本地模式 | Standalone 模式 | Spark on YARN模式 | Spark on Mesos 丰莫式"
  },
  "409": {
    "q": "Spark的基本流程主要涉及（）等角色。",
    "t": "muti",
    "a": "DriverProgram | ClusterManager | WorkerNode | Executor"
  },
  "410": {
    "q": "大数据平台的计算组件主要有（）。",
    "t": "muti",
    "a": "Storm | Spark | MapReduce"
  },
  "411": {
    "q": "Spark提交工作的方式有（）。",
    "t": "muti",
    "a": "Client | Cluster"
  },
  "412": {
    "q": "RDD的特征有（）。",
    "t": "muti",
    "a": "可容错性 | 并行数据结构"
  },
  "413": {
    "q": "Spark容错性的方式有（）。",
    "t": "muti",
    "a": "数据检查点 | 记录数据的更新"
  },
  "414": {
    "q": "下列关于Spark中RDD的描述正确的有（）。",
    "t": "muti",
    "a": "RDD(ResilientDistributedDataset)叫作弹性分布式数据集，是Spark中最基本的数据抽象 | Resilient:表示弹性的 | Destributed:分布式，可以并行在集群计算 | Dataset:就是一个集合，用于存放数据"
  },
  "415": {
    "q": "Spark组件包含（）两个算子。",
    "t": "muti",
    "a": "Action | Transformation"
  },
  "416": {
    "q": "Spark支持的计算模型有（）。",
    "t": "muti",
    "a": "批处理 | 实时计算 | 机器学习模型 | 交互式查询"
  },
  "417": {
    "q": "Spark比MapReduce计算快的原因有（）。",
    "t": "muti",
    "a": "基于内存的计算 | 基于DAG的调度框架 | 基于Lineage的容错机制"
  },
  "418": {
    "q": "Spark的技术架构可以分为（）。",
    "t": "muti",
    "a": "资源管理层 | Spark核心层 | 服务层"
  },
  "419": {
    "q": "相对于HadoopMapReduce,Spark的特点有（）。",
    "t": "muti",
    "a": "通用性 | 易用性 | 速度快"
  },
  "420": {
    "q": "Spark的关键技术包括（）。",
    "t": "muti",
    "a": "RDD | Scheduler | Storage | Shuffle"
  },
  "421": {
    "q": "Spark中的Scheduler模块可以分为（）。",
    "t": "muti",
    "a": "DAGScheduler | TaskScheduler"
  },
  "422": {
    "q": "下列关于Pig的说法正确的有（）。",
    "t": "muti",
    "a": "弥补MapReduce编程复杂性 | 封装MapReduce处理过程 | PigLatin是一种数据分析语言 | 适用于并行处理"
  },
  "423": {
    "q": "Hadoop组件Zookeeper的设计目标和主要特点包括（）。",
    "t": "muti",
    "a": "简单性 | 自我复制 | 顺序访问 | 高速读取"
  },
  "424": {
    "q": "Hadoop运行的模式包括（）。",
    "t": "muti",
    "a": "单机版 | 伪分布式 | 分布式"
  },
  "425": {
    "q": "Apache Flume主要解决的是日志数据的收集和处理问题，Flume的主要设计目的和特征包括（）。",
    "t": "muti",
    "a": "高可靠性 | 可扩展性"
  },
  "426": {
    "q": "Hadoop的优点包括（）。",
    "t": "muti",
    "a": "可靠性 | 高效性 | 可伸缩性 | 成本低"
  },
  "427": {
    "q": "下列关于Pig的说法正确的有（）。",
    "t": "muti",
    "a": "Pig的主要目的是弥补MapReduce编程的复杂性 | Pig的核心是一种数据分析语言 | Pig主要包含PigLatin和Pig执行环境两部分"
  },
  "428": {
    "q": "ETL技术主要涉及操作有（）。",
    "t": "muti",
    "a": "抽取 | 转换 | 加载"
  },
  "429": {
    "q": "Flume的特点包括（）。",
    "t": "muti",
    "a": "分布式 | 高可靠 | 高容错 | 易于定制和扩展"
  },
  "430": {
    "q": "下列关于Flume的描述正确的有（）。",
    "t": "muti",
    "a": "Flume具有一定的容错性 | Flume使用Java编写 | Flume是一个分布式的轻量级工具，适应各种方式的数据收集"
  },
  "431": {
    "q": "下列关于Zookeeper的描述正确的有（）。",
    "t": "muti",
    "a": "Zookeeper维护着一个树形的层次结构 | Zookeeper的数据访问具有原子性 | Zookeeper被设计用来实现协调服务"
  },
  "432": {
    "q": "Hadoop框架的缺点有（）。",
    "t": "muti",
    "a": "MapReduce编程框架的限制 | 过多的磁盘操作,缺乏对分布式内存的支持 | 无法高效支持迭代式计算 | 不支持多用户写入和任意修改文件"
  },
  "433": {
    "q": "MapReduce为海量的数据提供了存储架构。（）",
    "t": "judge",
    "a": "错误"
  },
  "434": {
    "q": "MapReduce中的Shuffle更像是洗牌的逆过程，把一组无规则的数据尽量转换成一组具有一定规则的数据。（）",
    "t": "judge",
    "a": "正确"
  },
  "435": {
    "q": "Shuffle横跨Map端和Reduce端,在Map端包括Spill过程,在Reduce端包括copy和sort过程。（）",
    "t": "judge",
    "a": "正确"
  },
  "436": {
    "q": "Combiner运行0次、1次或多次，Reducer都会产生相同的输出结果。（）",
    "t": "judge",
    "a": "正确"
  },
  "437": {
    "q": "MapReduce性能优化的评估大部分都是基于Counter的数值表现出来的。（）",
    "t": "judge",
    "a": "正确"
  },
  "438": {
    "q": "NameNode负责管理元数据信息MetaDatA、Client端每次读写请求，它都会从磁盘中读取或写入MetaData信息并反馈给Client端。（）",
    "t": "judge",
    "a": "错误"
  },
  "439": {
    "q": "MapReduce的InputSplit一定是一个Blocko（）",
    "t": "judge",
    "a": "错误"
  },
  "440": {
    "q": "链式MapReduce计算中，对任意一个MapReduce作业,Map和Reduce阶段可以有无限个Mapper,但Reducer只能有一个。（）",
    "t": "judge",
    "a": "正确"
  },
  "441": {
    "q": "MapReduce计算过程中，相同的key默认会被发送到同一个ReduceTask处理。（）",
    "t": "judge",
    "a": "正确"
  },
  "442": {
    "q": "key和value可以是未经加工的字节数据。（）",
    "t": "judge",
    "a": "正确"
  },
  "443": {
    "q": "MapReduce计算框架的计算过程分为Map阶段和Reduce阶段两个阶段，并分别以两个函数map（）和reduce（）进行抽象。（）",
    "t": "judge",
    "a": "正确"
  },
  "444": {
    "q": "用户自定义的reduce（）函数接受一个中间key值和一个相关的value值的集合。（）",
    "t": "judge",
    "a": "正确"
  },
  "445": {
    "q": "Shuffle»:为了确保每个reduce（）函数的输入都按键排序。（）",
    "t": "judge",
    "a": "正确"
  },
  "446": {
    "q": "为了降低map（）函数与reduce（）函数之间的数据传递量，一般采用combiner（）函数对map（）函数的输岀结果进行合并处理。（）",
    "t": "judge",
    "a": "正确"
  },
  "447": {
    "q": "Partition（）函数/分区函数:MapReduce对map（）函数的输出的中间key值使用分区函数来对数据进行分区处理,为每个Reduce任务创建一个分区。（）",
    "t": "judge",
    "a": "正确"
  },
  "448": {
    "q": "对Master故障，一个简单的解决办法是让Master周期性地将输岀结果写入磁盘，并设置检查点。当Master任务失效时,可以从最后一个检查点开始启动另一个Master 进程。（）",
    "t": "judge",
    "a": "正确"
  },
  "449": {
    "q": "MapReduce在中间key值采用分区函数进行数据的分区,并将分区结果传给后续任务执行进程。（）",
    "t": "judge",
    "a": "正确"
  },
  "450": {
    "q": "MapReduce使用计数器统计不同事件发生次数。（）",
    "t": "judge",
    "a": "正确"
  },
  "451": {
    "q": "集群的最主要“瓶颈”是磁盘I/O。（）",
    "t": "judge",
    "a": "正确"
  },
  "452": {
    "q": "如果NameNode意外终止，SecondaryNameNode会接替它使集群继续工作。（）",
    "t": "judge",
    "a": "错误"
  },
  "453": {
    "q": "Hadoop是Java开发的，所以MapReduce只支持Java编写。（）",
    "t": "judge",
    "a": "错误"
  },
  "454": {
    "q": "HBase对于空（NULL）的列，不需要占用存储空间。（）",
    "t": "judge",
    "a": "正确"
  },
  "455": {
    "q": "HBase可以有列，可以没有列簇。（）",
    "t": "judge",
    "a": "错误"
  },
  "456": {
    "q": "HDFS对大文件的处理能力较强，但是对于小文件，尤其是大量的小文件的处理能力反而较弱。（）",
    "t": "judge",
    "a": "正确"
  },
  "457": {
    "q": "HDFS系统支持数据的修改。（）",
    "t": "judge",
    "a": "错误"
  },
  "458": {
    "q": "Hive定义了一种类似SQL的查询语言（HQL）,将HQL转化为MapReduce任务在Hadoop上执行，通常用于在线分析。（）",
    "t": "judge",
    "a": "错误"
  },
  "459": {
    "q": "Spark基于内存计算，本身可以直接读写Hadoop上任何格式数据，其应用程序在集群上以独立的进程集合的形式运行。（）",
    "t": "judge",
    "a": "正确"
  },
  "460": {
    "q": "Spark是以RDD概念为中心运行的。（）",
    "t": "judge",
    "a": "正确"
  },
  "461": {
    "q": "RDD中所有的操作都是Lazy模式进行，运行在编译中不会立即计算最终结果，而是记住所有操作步骤和方法，只有显示遇到启动命令才执行。（）",
    "t": "judge",
    "a": "正确"
  },
  "462": {
    "q": "Spark本身并没有提供分布式文件系统,因此Spark的分析大多依赖于Hadoop的分布式文件系统HDFS。（）",
    "t": "judge",
    "a": "正确"
  },
  "463": {
    "q": "Hadoop的MapReduce与Spark都可以进行数据计算，而相比于MapReduce,Spark的速度更快并且提供的功能更加丰富。（）",
    "t": "judge",
    "a": "正确"
  },
  "464": {
    "q": "在Spark中引入RDD概念的目的是实现Spark的串行操作和灵活的容错能力。（）",
    "t": "judge",
    "a": "错误"
  },
  "465": {
    "q": "数据采集与接入的范围包括一级部署业务系统、二级部署业务系统（含自建）和外部系统一手数据接入，满足大数据平台一手数据全的要求。（）",
    "t": "judge",
    "a": "正确"
  },
  "466": {
    "q": "数据存命者是大数据平台的根本，没有了存储平台，数据也就没有了载体。（）",
    "t": "judge",
    "a": "正确"
  },
  "467": {
    "q": "MapReduce中，运行程序副本程序的机器分为___和___两类。",
    "t": "fill",
    "a": "一个Master服务器|若干个Worker服务器"
  },
  "468": {
    "q": "MapReduce中，Master服务器负责将一个Map任务分派给 ___",
    "t": "fill",
    "a": "空闲的Worker服务器"
  },
  "469": {
    "q": "MapReduce中，被分派到Map任务的Worker程序读取相关的输入分片，从输入分片中解析出(key,value)然后把(key,value)传递给用户自定义的 ___ 。",
    "t": "fill",
    "a": "map()函数"
  },
  "470": {
    "q": "MapReduce中，通过分区函数将已缓存的(key,value)分成R个区城，并周期性地写入到 ___ 。",
    "t": "fill",
    "a": "本地磁盘"
  },
  "471": {
    "q": "MapReduce中，(key,value)在本地磁盘上的存储位置将传给Master,由Master负责把这些存储位置再传送给 ___ 。",
    "t": "fill",
    "a": "Reduce Worker"
  },
  "472": {
    "q": "MapReduce中，当Reduce Worker接收到Master发来的数据存储位置信息后，通过远程调用从MapWorker所在主机的磁盘上读取 ___ 输出的中间结果。",
    "t": "fill",
    "a": "map()函数"
  },
  "473": {
    "q": "MapReduce中，不需要将这R个输出文件合并成一个文件，主要原因在于在实际应用中这些文件往往作为 ___ 或者在处理多个分制文件的分布式应用中继续使用。",
    "t": "fill",
    "a": "另一个MapReduce的输入"
  },
  "474": {
    "q": "当Map任务完成时， ___ 接收到位置和大小的更新信息，并推送给Reduce任务。",
    "t": "fill",
    "a": "Master"
  },
  "475": {
    "q": "___负责资源管理和所有作业的控制,而___负责接收来自JobTracker的命令并执行它。",
    "t": "fill",
    "a": "JobTracker|TaskTracker"
  },
  "476": {
    "q": "Spark技术架构的资源层主要涉及两种角色，分别是 ___ 。",
    "t": "fill",
    "a": "ClusterManager(集群管理器)和WorkerNode(工作节点)"
  },
  "477": {
    "q": "在Spark中引人RDD概念的目的是实现 ___ 。",
    "t": "fill",
    "a": "Spark的并行操作和灵活的容错能力"
  },
  "478": {
    "q": "Spark是专为大规模数据处理而设计的快速通用的计算引擎，将Job中间输出结果可以保存在 ___ 中,从而不再需要读写HDFS。因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。",
    "t": "fill",
    "a": "内存"
  },
  "479": {
    "q": "某单位运用随机森林算法思想建立抢修热点模型，该模型主要预测下期台区工单数量，构建抢修热点。模型构建步骤如下：①将历史数据进行随机自助法重抽样,生成N个训练样本集；②将N个训练样本集分别做决策树，生成N棵决策树;③将N棵决策树随机构成随机森林；④未来根据预测样本气候环境、设备属性、设备工况进行随机森林决策投票，得岀针对该预测样本最优的决策树进行运算，并计算出最终结果。则上列模型算法构建步骤合理的顺序是（）",
    "t": "single",
    "a": "①②③④"
  },
  "480": {
    "q": "泛化误差可分解为偏差、方差与噪声之和，当学习器拟合程度不够强时，（）主导了泛化错误率。",
    "t": "single",
    "a": "偏差"
  },
  "481": {
    "q": "机器学习算法在学习过程中对某种类型假设的偏好称为（）。",
    "t": "single",
    "a": "归纳偏好"
  },
  "482": {
    "q": "假设使用一个较复杂的回归模型来拟合样本数据。使用Ridge回归，并调整正则化参数λ以降低模型复杂度。在λ非常小的情况下，下列关于偏差与方差的说法正确的是（）。",
    "t": "single",
    "a": "偏差低，方差髙"
  },
  "483": {
    "q": "假负率是指（）。",
    "t": "single",
    "a": "被预测为负的正样本结果数/正样本实际数"
  },
  "484": {
    "q": "（）可在保证训练精度的情况下降低模型的复杂度。",
    "t": "single",
    "a": "选择合适的正则化参数"
  },
  "485": {
    "q": "（）是交叉验证法的一种特例。",
    "t": "single",
    "a": "留一法"
  },
  "486": {
    "q": "下列说法中:①一个机器学习模型，如果有较高准确率，总是说明这个分类器是好的；②如果增加模型复杂度，那么模型的测试错误率总是会降低；③如果增加模型复杂度，那么模型的训练错误率总是会降低。正确的是（）。",
    "t": "single",
    "a": "②"
  },
  "487": {
    "q": "假如使用一个较复杂的回归模型来拟合样本数据，使用Ridge回归，调试正则化参数λ，来降低模型复杂度。在λ较大时，下列关于偏差（bias）和方差（variance）关系的说法正确的是（）。",
    "t": "single",
    "a": "偏差增大，方差减小"
  },
  "488": {
    "q": "机器学习中发生过拟合的主要原因不包括（）。",
    "t": "single",
    "a": "训练数据充足"
  },
  "489": {
    "q": "有N个样本，一半用于训练，一半用于测试。若N增大，则训练误差和测试误差之间的差距会（）。",
    "t": "single",
    "a": "减小"
  },
  "490": {
    "q": "在其他条件不变的前提下，()容易引起机器学习中的过拟合问题。",
    "t": "single",
    "a": "SVM算法中使用高斯核/RBF核代替线性核"
  },
  "491": {
    "q": "假设precision=TP/(TP+FP),recall=TP/(TP+FN),则在二分类问题中，当测试集的正例和负例数量不均衡时，下列评价方案中相对不合理的是()。",
    "t": "single",
    "a": "Accuracy:(TP+TN)/all"
  },
  "492": {
    "q": "()算法可以用于特征选择。",
    "t": "single",
    "a": "决策树"
  },
  "493": {
    "q": "下列不属于特征选择的标准方法的是()。",
    "t": "single",
    "a": "抽样"
  },
  "494": {
    "q": "()特征选择是直接把最终将要使用的学习器的性能作为特征子集的评价准则。",
    "t": "single",
    "a": "包裹式"
  },
  "495": {
    "q": "()情况下，LDA会失败。",
    "t": "single",
    "a": "如果有辨识性的信息不是平均值，而是数据的方差"
  },
  "496": {
    "q": "机器学习中L1正则化和L2正则化的区别是()。",
    "t": "single",
    "a": "使用L1可以得到稀疏的权值，使用L2可以得到平滑的权值"
  },
  "497": {
    "q": "如果建立一个5000个特征、100万个数据的机器学习模型，则有效地应对这样的大数据训练的方法是()。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "498": {
    "q": "多分类LDA将样本投影到N-l维空间，N-l通常远小于数据原有的属性数，可通过这个投影来减小样本点的维数，且投影过程中使用了类别信息，因此LDA也常被视为一种经典的（）技术。",
    "t": "single",
    "a": "监督降维"
  },
  "499": {
    "q": "特征工程的目的是（）。",
    "t": "single",
    "a": "得到最好的输入数据"
  },
  "500": {
    "q": "下列关于分类算法的准确率、召回率、F1值的描述错误的是（）。",
    "t": "single",
    "a": "正确率、召回率和F1值取值都在0和1之间，数值越接近0，查准率或查全率就越高"
  },
  "501": {
    "q": "下列关于L1正则化与L2正则化的描述错误的是（）。",
    "t": "single",
    "a": "L1范数正则化比L2范数正则化更易于获得稀疏解"
  },
  "502": {
    "q": "()算法指的是给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离。",
    "t": "single",
    "a": "LDA"
  },
  "503": {
    "q": "对参数进行L2正则，是机器学习常用的防止过拟合的方法。对参数做L2正则时,()是对参数本身做先验分布假设。",
    "t": "single",
    "a": "高斯分布"
  },
  "504": {
    "q": "()先对数据集进行特征选择，然后再训练学习器。",
    "t": "single",
    "a": "过滤式选择"
  },
  "505": {
    "q": "机器学习中做特征选择时，可能用到的方法有（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "506": {
    "q": "如果需要训练的特征维度成千上万，那么针对在高维情形下出现的数据样本稀疏、距离计算困难的问题，可以采取的缓解措施是()。",
    "t": "single",
    "a": "降维"
  },
  "507": {
    "q": "过滤式特征选择、包裹式特征选择与学习器的关系分别是()。",
    "t": "single",
    "a": "不相关，相关"
  },
  "508": {
    "q": "使用似然函数的目的是（）。",
    "t": "single",
    "a": "找到最适合数据的参数"
  },
  "509": {
    "q": "在线性回归问题中，用R2来衡量拟合的好坏。关于在线性回归模型中增加特征值并再训练同一模型，下列说法正确的是（）。",
    "t": "single",
    "a": "R2不能完全反映变量重要性，不能就此得出正确结论"
  },
  "510": {
    "q": "为了观察测试Y与X之间的线性关系，若X是连续变量，则使用（）比较适合。",
    "t": "single",
    "a": "散点图"
  },
  "511": {
    "q": "回归方程判定系数的计算公式R2=SSR/SST=1-SSE/SST,对判定系数描述错误的是（）。",
    "t": "single",
    "a": "SSR指总离差平方和"
  },
  "512": {
    "q": "线性回归的基本假设不包括()。",
    "t": "single",
    "a": "随机误差项彼此相关"
  },
  "513": {
    "q": "如果线性回归模型中的随机误差存在异方差性，那么参数的OLS估计量是()。",
    "t": "single",
    "a": "无偏的、非有效的"
  },
  "514": {
    "q": "假设一个线性回归模型完美适合训练数据(训练误差为0),则下列说法正确的是()。",
    "t": "single",
    "a": "测试集误差可能为0"
  },
  "515": {
    "q": "()试图学得一个通过属性的线性组合来进行预测的函数。",
    "t": "single",
    "a": "线性模型"
  },
  "516": {
    "q": "线性判别分析在二分类问题上也称为（）。",
    "t": "single",
    "a": "Fisher判别分析"
  },
  "517": {
    "q": "当训练样本近似线性可分时，（）。",
    "t": "single",
    "a": "通过软间隔最大化,学习一个线性支持向量机"
  },
  "518": {
    "q": "线性模型中的权重w可以看做各个属性x的（）。",
    "t": "single",
    "a": "对最终决策结果的贡献度"
  },
  "519": {
    "q": "下列关于线性模型的描述错误的是（）。",
    "t": "single",
    "a": "支持向量机的判别函数一定属于线性函数"
  },
  "520": {
    "q": "一元线性回归方程y=0.7+0.82x,判定系数等于0.64,则x与y的相关系数为（）。",
    "t": "single",
    "a": "0.8"
  },
  "521": {
    "q": "下列说法中:①R-Squared和Adjusted R-squared都是递增的；②R-Squared是常量的，Adjusted R-squared是递增的；③R-Squared是递减的，Adjusted R-squared也是递减的；④R-Squared是递减的，Adjusted R-squared是递增的。对于线性回归模型，包括附加变量在内，可能正确的是（）。",
    "t": "single",
    "a": "以上都不是"
  },
  "522": {
    "q": "在多元线性回归模型中，若某个解释变量对其余解释变量的判定系数接近于1,则表明模型中存在（）。",
    "t": "single",
    "a": "多重共线性"
  },
  "523": {
    "q": "假设使用原始的非线性可分版本的Soft-SVM目标函数作为最优化对象，则可通过（）来保证得到的模型是线性可分离的。",
    "t": "single",
    "a": "设C正无穷大"
  },
  "524": {
    "q": "如果说线性回归模型完美地拟合了训练样本（训练样本误差为零），则下列说法正确的是（）。",
    "t": "single",
    "a": "测试样本误差不一定为零"
  },
  "525": {
    "q": "在回归模型中，（）在权衡欠拟合（under-fitting）和过拟合（over-fitting）中影响最大。",
    "t": "single",
    "a": "多项式阶数"
  },
  "526": {
    "q": "在一个线性回归问题中，通常使用R平方（R-Squared）来判断拟合度。此时，如果增加一个特征，模型不变，则下面说法正确的是（）。",
    "t": "single",
    "a": "仅看R-Squared单一变量，无法确定这个特征是否有意义"
  },
  "527": {
    "q": "在一个简单的线性回归模型中（只有一个变量），如果将输入变量改变一个单位（增加或减少）,那么输出将改变（）。",
    "t": "single",
    "a": "回归模型的尺度因子"
  },
  "528": {
    "q": "假设有n组数据集，每组数据集中x的平均值都是9，x的方差都是11,y的平均值都是7.50,x与y的相关系数都是0.816，拟合的线性回归方程都是y=3.00+0.500x。那么这n组数据集（）。",
    "t": "single",
    "a": "无法确定是否一样"
  },
  "529": {
    "q": "如果使用线性回归模型，则下列说法正确的是（）。",
    "t": "single",
    "a": "检查异常值是很重要的，因为线性回归对离群效应很敏感"
  },
  "530": {
    "q": "在支持向量机中，软间隔支持向量机的目标函数比硬间隔支持向量机多了一个（）。",
    "t": "single",
    "a": "松弛变量"
  },
  "531": {
    "q": "假定使用SVM学习数据X,数据X里面有些点存在错误。现在如果使用一个二次核函数，多项式阶数为2,使用松弛变量C作为超参之一。当使用较大的C（C趋于无穷），则（）。",
    "t": "single",
    "a": "仍然能正确分类数据"
  },
  "532": {
    "q": "下列关于支持向量机优化性问题形式的说法正确的是（）。",
    "t": "single",
    "a": "它是一个凸二次规划问题"
  },
  "533": {
    "q": "（）属于SVM应用。",
    "t": "single",
    "a": "以上均是"
  },
  "534": {
    "q": "SVM在（）情况下表现糟糕。",
    "t": "single",
    "a": "含噪声数据与重叠数据点"
  },
  "535": {
    "q": "令N为数据集的大小［注:设训练样本（xi,yi），N即训练样本个数］,d是输入空间的维数（注:d即向量xi的维数）。则硬间隔SVM问题的原始形式［即在不等式约束［yi（wTxi+b）≥1］下最小化（1/2）wTw］在没有转化为拉格朗日对偶问题之前是（）。",
    "t": "single",
    "a": "一个含d+1个变量的二次规划问题"
  },
  "536": {
    "q": "在支持向量机中，（）允许支持向量机在一些样本上岀错。",
    "t": "single",
    "a": "软间隔"
  },
  "537": {
    "q": "缓解过拟合的一个办法是允许支持向量机在一些样本上出错，（）形式适合这种方法。",
    "t": "single",
    "a": "软间隔支持向量机"
  },
  "538": {
    "q": "假定训练了一个线性SVM并推断出这个模型出现了欠拟合现象，在下一次训练时，应该采取的措施是（）。",
    "t": "single",
    "a": "增加特征"
  },
  "539": {
    "q": "下列关于Logistic回归和SVM的描述不正确的是（）。",
    "t": "single",
    "a": "Logistic回归本质上是一种根据样本对权值进行极大似然估计的方法，用先验概率的乘积代替后验概率"
  },
  "540": {
    "q": "（）选择成为支持向量机的最大变数。",
    "t": "single",
    "a": "核函数"
  },
  "541": {
    "q": "已知一个数据集，n为特征数，m为训练样本数，如果n较小，而且m大小中等（例如n为1~1000,而m为10~10000）,则一般选择（）。",
    "t": "single",
    "a": "高斯核的支持向量机"
  },
  "542": {
    "q": "核矩阵是（）的。",
    "t": "single",
    "a": "半正定"
  },
  "543": {
    "q": "为了允许支持向量机在一些样本上出错，引入（）的概念。",
    "t": "single",
    "a": "软间隔"
  },
  "544": {
    "q": "任何一个核函数都隐式地定义了一个（）空间。",
    "t": "single",
    "a": "再生核希尔伯特空间"
  },
  "545": {
    "q": "对于SVM分类算法，待分样本集中的大部分样本不支持向量，下列说法正确的是（）。",
    "t": "single",
    "a": "移去或者减少这些样本对分类结果没有影响"
  },
  "546": {
    "q": "下列关于支持向量回归的说法错误的是（）。",
    "t": "single",
    "a": "与同分类算法不同的是，支持向量回归要最小化一个凹函数"
  },
  "547": {
    "q": "下列关于支持向量的说法正确的是（）。",
    "t": "single",
    "a": "到分类超平面的距离最近的且满足一定条件的几个训练样本点是支持向量"
  },
  "548": {
    "q": "如果一个SVM模型出现欠拟合，那么（）能解决这一问题。",
    "t": "single",
    "a": "增大惩罚参数C"
  },
  "549": {
    "q": "有两个样本点，第一个点为正样本，它的特征向量是（0,-1）;第二个点为负样本，它的特征向量是（2,3）。从这两个样本点组成的训练集构建一个线性SVM分类器的分类面方程是（）。",
    "t": "single",
    "a": "x+2y=3"
  },
  "550": {
    "q": "下列关于降维算法中主成分分析的说法错误的是（）。",
    "t": "single",
    "a": "有监督算法"
  },
  "551": {
    "q": "进行主成分分析的前提条件是各变量间（）。",
    "t": "single",
    "a": "低度相关"
  },
  "552": {
    "q": "采用主成分分析法映射到低维空间，将最小的d-d’个特征向量舍弃，产生的影响是（）。",
    "t": "single",
    "a": "使样本采样密度增大"
  },
  "553": {
    "q": "下列关于PCA的说法中:①我们须在使用PCA前标准化数据；②我们应该选择使得模型有最大variance的主成分；③我们应该选择使得模型有最小variance的主成分；④我们可以使用PCA在低维度上做数据可视化。正确的是（）。",
    "t": "single",
    "a": "①②④"
  },
  "554": {
    "q": "已知一组数据的协方差矩阵P，下列关于主分量的说法错误的是（）。",
    "t": "single",
    "a": "主分量分析就是K-L变换"
  },
  "555": {
    "q": "当特征值大致相等时，会发生的情况是（）。",
    "t": "single",
    "a": "PCA将表现不佳"
  },
  "556": {
    "q": "下列关于降维的表述错误的是（）。",
    "t": "single",
    "a": "降维过程中可以保留原始数据的所有信息"
  },
  "557": {
    "q": "如果两个变量相关，则它们之间的关系是（）。",
    "t": "single",
    "a": "不一定是线性关系"
  },
  "558": {
    "q": "下列描述中能反映岀X和Y之间的强相关性的是（）。",
    "t": "single",
    "a": "相关系数为0.9"
  },
  "559": {
    "q": "如果自变量X和因变量Y之间存在高度的非线性和复杂关系，那么树模型很可能优于经典回归方法。则以上说法（）。",
    "t": "single",
    "a": "正确"
  },
  "560": {
    "q": "假设你需要调整参数来最小化代价函数(costfunction),会使用()技术。",
    "t": "single",
    "a": "以上全是"
  },
  "561": {
    "q": "数据清洗的方法不包括()。",
    "t": "single",
    "a": "重复数据记录处理"
  },
  "562": {
    "q": "检测一元正态分布中的离群点，属于异常检测中的基于()的离群点检测。",
    "t": "single",
    "a": "统计方法"
  },
  "563": {
    "q": "与生成方法、半监督SVM、图半监督学习等基于单学习机器利用未标记数据不同，基于分歧的方法(disagreement-based methods)使用多学习器，而学习器之间的分歧(disagreement)对未标记数据的利用至关重要。()是此类方法的重要代表。",
    "t": "single",
    "a": "协同训练"
  },
  "564": {
    "q": "多分类学习中，最经典的三种拆分策略不包括()。",
    "t": "single",
    "a": "—对一"
  },
  "565": {
    "q": "下列算法中不属于外推法的是()。",
    "t": "single",
    "a": "回归分析法"
  },
  "566": {
    "q": "当合适的样本容量很难确定时，可以使用的抽样方法是()。",
    "t": "single",
    "a": "渐进抽样"
  },
  "567": {
    "q": "学习率对机器学习模型结果会产生影响，通常希望学习率()。",
    "t": "single",
    "a": "较小而迭代次数较多"
  },
  "568": {
    "q": "下列选项说法正确的是()。",
    "t": "single",
    "a": "KNN是有监督学习算法"
  },
  "569": {
    "q": "在训练的每一轮都要检查当前生成的基学习器是否满足基本条件的算法是()。",
    "t": "single",
    "a": "Boosting算法"
  },
  "570": {
    "q": "()算法要求基学习器能对特定的数据分布进行学习，在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。",
    "t": "single",
    "a": "Boosting"
  },
  "571": {
    "q": "()算法可以较好地避免样本的不平衡问题。",
    "t": "single",
    "a": "KNN"
  },
  "572": {
    "q": "（）的基本想法是适当考虑一部分属性间的相互依赖信息，从而既不需要进行完全联合概率计算,又不至于彻底忽略了比较强的属性依赖关系。",
    "t": "single",
    "a": "半朴素贝叶斯分类器"
  },
  "573": {
    "q": "Relief是为（）问题设计的。",
    "t": "single",
    "a": "二分类"
  },
  "574": {
    "q": "概率模型的训练过程就是（）过程。",
    "t": "single",
    "a": "参数估计"
  },
  "575": {
    "q": "下列不属于判别式模型的是（）。",
    "t": "single",
    "a": "贝叶斯"
  },
  "576": {
    "q": "线性判别分析（LDA）从贝叶斯决策理论阐释，当两类数据同先验且满足（）时，LDA达到最优分类。",
    "t": "single",
    "a": "高斯分布且协方差才目等"
  },
  "577": {
    "q": "支持向量回归与传统回归模型的差别是（）。",
    "t": "single",
    "a": "模型输出与真实值存在偏差"
  },
  "578": {
    "q": "在机器学习中，不属于常用的冲突消解策略是（）。",
    "t": "single",
    "a": "加权法"
  },
  "579": {
    "q": "通常来说，（）能够用来预测连续因变量。",
    "t": "single",
    "a": "线性回归"
  },
  "580": {
    "q": "选择哪一个解作为输出，将由学习算法的归纳偏好决定，常见的做法是引入（）。",
    "t": "single",
    "a": "正则化项"
  },
  "581": {
    "q": "下列关于机器学习模型的说法正确的是（）。",
    "t": "single",
    "a": "如果增加模型复杂度，那么模型的训练错误率总是会降低"
  },
  "582": {
    "q": "（）是指为最小化总体风险，只需在每个样本上选择能使特定条件风险最小的类别标记。",
    "t": "single",
    "a": "贝叶斯判定准则"
  },
  "583": {
    "q": "()不可以直接来对文本分类。",
    "t": "single",
    "a": "K-means"
  },
  "584": {
    "q": "()是基于规则的分类器。",
    "t": "single",
    "a": "C4.5"
  },
  "585": {
    "q": "下列机器学习算法中，不需要归一化处理的是()。",
    "t": "single",
    "a": "Decision Tree"
  },
  "586": {
    "q": "下列关于LI、L2正则化的说法正确的是()。",
    "t": "single",
    "a": "L1正则化得到的解更加稀疏"
  },
  "587": {
    "q": "下列说法错误的是()。",
    "t": "single",
    "a": "沿负梯度的方向一定是最优的方向"
  },
  "588": {
    "q": "一监狱人脸识别准入系统用来识别待进入人员的身份，此系统能识别狱警、小偷、送餐员、其他人员4种不同人员。下列学习方法最适合此种应用需求的是（）。",
    "t": "single",
    "a": "多分类问题"
  },
  "589": {
    "q": "机器学习中，基于样本分布的距离是（）。",
    "t": "single",
    "a": "马氏距离"
  },
  "590": {
    "q": "下列关于随机森林和GBDT的说法正确的是（）。",
    "t": "single",
    "a": "这两个模型都使用随机特征子集，来生成许多单个的树"
  },
  "591": {
    "q": "下列算法中更适合做时间序列建模的是（）。",
    "t": "single",
    "a": "LSTM"
  },
  "592": {
    "q": "（）算法是分类算法。",
    "t": "single",
    "a": "C4.5"
  },
  "593": {
    "q": "()不是k最近邻分类器的特点。",
    "t": "single",
    "a": "最近邻分类器基于全局信息进行预测"
  },
  "594": {
    "q": "KNN近邻算法在()的情况下效果较好。",
    "t": "single",
    "a": "样本较少但典型性好"
  },
  "595": {
    "q": "在k近邻学习算法中，随着k的增加，上界将逐渐降低，当k区域无穷大时，上界和下界碰到一起，k近邻法就达到了()。",
    "t": "single",
    "a": "贝叶斯错误率"
  },
  "596": {
    "q": "下列关于KNN算法的过程:①计算训练样本和测试样本中每个样本点的距离(常见的距离度量有欧式距离、马氏距离等)；②对上面所有的距离进行排序；③选前k个最小距离的样本；④根据这k个样本的标签进行投票，得到最后的分类类别。正确的排序为()。",
    "t": "single",
    "a": "①②③④"
  },
  "597": {
    "q": "可用作数据挖掘分析中的关联规则算法有（）。",
    "t": "single",
    "a": "Apriori算法、FP-Tree算法"
  },
  "598": {
    "q": "一般而言，在个体学习器性能相差较大与个体学习器性能相近时宜分别使用（）。",
    "t": "single",
    "a": "加权平均法，简单平均法"
  },
  "599": {
    "q": "点击率的预测是一个数据比例不平衡问题（如训练集中样本呈阴性的比例为99%，阳性的比例是1%）,如果用这种数据建立模型并使得训练集的准确率高达99%。则可以得岀结论是（）。",
    "t": "single",
    "a": "无法评价模型"
  },
  "600": {
    "q": "假如使用Lasso回归来拟合数据集，该数据集输入特征有100个（X1，X2，…,X100）。现在，把其中一个特征的值扩大10倍（如特征X1），然后用相同的正则化参数对Lasso回归进行修正。那么下列说法正确的是（）。",
    "t": "single",
    "a": "特征X1很可能还包含在模型之中"
  },
  "601": {
    "q": "采样分析的精确性随着釆样随机性的增加而（）,但与样本数量的增加关系不大。",
    "t": "single",
    "a": "提高"
  },
  "602": {
    "q": "随机试验所有可能出现的结果称为（）。",
    "t": "single",
    "a": "样本空间"
  },
  "603": {
    "q": "以等可能性为基础的概率是（）。",
    "t": "single",
    "a": "古典概率"
  },
  "604": {
    "q": "任一随机事件出现的概率P为（）。",
    "t": "single",
    "a": "0≤P≤1"
  },
  "605": {
    "q": "()是以样本统计量作为未知总体参数的估计量，并通过对样本单位的实际观察取得样本数据，计算样本统计量的取值作为被估计参数的估计值。",
    "t": "single",
    "a": "参数估计"
  },
  "606": {
    "q": "()是利用样本的实际资料计算统计量的取值，并引来以检验事先对总体某些数量特征的假设是否可信作为决策取舍依据的一种统计分析方法。",
    "t": "single",
    "a": "假设检验"
  },
  "607": {
    "q": "()是指数据减去一个总括统计量或模型拟合值时的残余部分。",
    "t": "single",
    "a": "残值"
  },
  "608": {
    "q": "()是表现数据分布对称性的指标。",
    "t": "single",
    "a": "偏斜度"
  },
  "609": {
    "q": "在方差分析中，()反映的是样本数据与其组平均值的差异。",
    "t": "single",
    "a": "组内误差"
  },
  "610": {
    "q": "若A与B是任意的两个事件，且P(AB)=P(A)·P(B)，则可称事件A与B()。",
    "t": "single",
    "a": "相互独立"
  },
  "611": {
    "q": "二项分布的数学期望为()。",
    "t": "single",
    "a": "np"
  },
  "612": {
    "q": "某篮运动员在三分线投球的命中率是1/2,他投球10次，恰好投进3个球的概率为()。",
    "t": "single",
    "a": "15/128"
  },
  "613": {
    "q": "参数估计可分为()和区间估计。",
    "t": "single",
    "a": "点估计"
  },
  "614": {
    "q": "（）是二维随机变量的分布。",
    "t": "single",
    "a": "边缘分布"
  },
  "615": {
    "q": "在抽样估计中，随着样本容量的增大，样本统计量接近总体参数的概率就越大，这一性质称为（）。",
    "t": "single",
    "a": "一致性"
  },
  "616": {
    "q": "（）和假设检验又可归结为统计推断的范畴，即对总体的数量特征做岀具有一定可靠程度的估计和判断。",
    "t": "single",
    "a": "参数估计"
  },
  "617": {
    "q": "异常检测过程查找基于（）组标准值偏差的异常个案。",
    "t": "single",
    "a": "聚类"
  },
  "618": {
    "q": "回归分析的任务就是根据（）和因变量的观察值，估计这个函数并讨论与之有关的种种统计推断的问题。",
    "t": "single",
    "a": "自变量"
  },
  "619": {
    "q": "在图集合中发现一组公共子结构，这样的任务称为（）。",
    "t": "single",
    "a": "频繁子图挖掘"
  },
  "620": {
    "q": "子集搜索中，逐渐增加相关特征的策略称为（）。",
    "t": "single",
    "a": "前向搜索"
  },
  "621": {
    "q": "如果规则集R中不存在两条规则被同一条记录触发，则称规则集R中的规则为（）。",
    "t": "single",
    "a": "互斥规则"
  },
  "622": {
    "q": "在Apriori算法中，候选项集划分为不同的桶，存放在（）中。",
    "t": "single",
    "a": "Hash树"
  },
  "623": {
    "q": "（）算法是一种挖掘关联规则的频繁项集算法，其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。",
    "t": "single",
    "a": "Apriori"
  },
  "624": {
    "q": "下列关于Apriori算法原理的叙述错误的是（）。",
    "t": "single",
    "a": "Apriori算法不可以用来发现频繁集"
  },
  "625": {
    "q": "priori算法的核心思想是（）。",
    "t": "single",
    "a": "通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集"
  },
  "626": {
    "q": "关联规则的评价指标是（）。",
    "t": "single",
    "a": "支持度、置信度"
  },
  "627": {
    "q": "（）算法是一种最有影响的挖掘关联规则频繁项目集的算法。",
    "t": "single",
    "a": "Apdori"
  },
  "628": {
    "q": "所有预测模型在广义上都可称为一个或一组（）。",
    "t": "single",
    "a": "规则"
  },
  "629": {
    "q": "下列方法中:①增加更多的数据；②使用数据扩增技术（data augmentation）；③使用归纳性更好的架构；④正规化数据；⑤降低架构的复杂度可以用来降低深度学习模型的过拟合问题的方法有（）。",
    "t": "single",
    "a": "所有项目都有用"
  },
  "630": {
    "q": "机器学习训练时，Mini-Batch的大小优选为2的幂，如256或512。它背后的原因是（）。",
    "t": "single",
    "a": "Mini-Batch设为2的幂，是为了符合CPU、GPU的内存要求，利于并行化处理"
  },
  "631": {
    "q": "评估完模型之后，发现模型存在高偏差（highbias）,应采取的解决方法是（）。",
    "t": "single",
    "a": "增加模型的特征数量"
  },
  "632": {
    "q": "下列不适合使用机器学习方法解决的是（）。",
    "t": "single",
    "a": "判断给定的图中是否有环"
  },
  "633": {
    "q": "在集成学习中，对于数据型输出，最常见的结合策略是（）。",
    "t": "single",
    "a": "平均法"
  },
  "634": {
    "q": "随机森林中的随机是指（）。",
    "t": "single",
    "a": "在构建每个树模型时随机选择样本和特征"
  },
  "635": {
    "q": "下列关于集成学习模型中弱学习者的描述错误的是（）。",
    "t": "single",
    "a": "通常会过拟合"
  },
  "636": {
    "q": "bootstrap是指（）。",
    "t": "single",
    "a": "有放回地从总共N个样本中抽样n个样本"
  },
  "637": {
    "q": "通过聚集多个分类器的预测来提高分类准确率的技术称为（）。",
    "t": "single",
    "a": "组合"
  },
  "638": {
    "q": "随机森林是在（）上的一个扩展变体。",
    "t": "single",
    "a": "Bagging"
  },
  "639": {
    "q": "主成分分析的优化目标是一个（）。",
    "t": "single",
    "a": "含有约束条件的二次规划问题"
  },
  "640": {
    "q": "随机森林与Bagging中基学习器多样性的区别是（）。",
    "t": "single",
    "a": "来自样本扰动和属性扰动"
  },
  "641": {
    "q": "绝对多数投票法的基本思想是（）。",
    "t": "single",
    "a": "不光要求获得最高票，还要求票过半数"
  },
  "642": {
    "q": "Adaboost的核心思想是（）。",
    "t": "single",
    "a": "针对同一个训练集训练不同的弱分类器并集合起来，构成一个强分类器"
  },
  "643": {
    "q": "下列关于Boosting算法的描述错误的是（）。",
    "t": "single",
    "a": "可将强学习器降为弱学习器"
  },
  "644": {
    "q": "下列关于随机森林的说法正确的是（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "645": {
    "q": "对分类任务来说，学习器从类别标记集合中预测出一个标记，最常见的结合策略是（）。",
    "t": "single",
    "a": "投票法"
  },
  "646": {
    "q": "对数值型输出，最常见的结合策略是（）。",
    "t": "single",
    "a": "平均法"
  },
  "647": {
    "q": "下列不属于模型集成方法的是（）。",
    "t": "single",
    "a": "递归法"
  },
  "648": {
    "q": "基于Boosting的集成学习代表算法不包含（）。",
    "t": "single",
    "a": "随机森林"
  },
  "649": {
    "q": "基于Bagging的集成学习代表算法有（）。",
    "t": "single",
    "a": "随机森林"
  },
  "650": {
    "q": "下列关于Boosting的说法错误的是（）。",
    "t": "single",
    "a": "训练基分类器时采用并行的方式"
  },
  "651": {
    "q": "下列关于Bagging的说法错误的是（）。",
    "t": "single",
    "a": "各基分类器之间有较强依赖，不可以进行并行训练"
  },
  "652": {
    "q": "随着集成中个体分类器（相互独立）数目T的增大，集成的错误率将呈（）下降，最终趋向于零。",
    "t": "single",
    "a": "指数级"
  },
  "653": {
    "q": "考虑这么一种情况:一个对象碰巧与另一个对象相对接近，但属于不同的类，因为这两个对象一般不会共享许多近邻，所以应该选择（）的相似度计算方法。",
    "t": "single",
    "a": "共享最近邻"
  },
  "654": {
    "q": "通过K-means算法进行聚类分析后得出的聚类结果的特征是（）。",
    "t": "single",
    "a": "同一聚类中的对象间相似度高，不同聚类中的对象间相似度低"
  },
  "655": {
    "q": "在IBMPASS中，聚类算法分为分层聚类、Kohonennetwork.K均值聚类和（）四种。",
    "t": "single",
    "a": "两步聚类"
  },
  "656": {
    "q": "聚类算法已经默认所有的记录都是（）的实体。",
    "t": "single",
    "a": "独立"
  },
  "657": {
    "q": "（）算法假设聚类结构能通过样本分布的紧密程度确定。",
    "t": "single",
    "a": "密度聚类"
  },
  "658": {
    "q": "（）是一种著名的密度聚类算法，它基于一组邻域参数来刻画样本的紧密程度。",
    "t": "single",
    "a": "DBSCAN"
  },
  "659": {
    "q": "（）采用概率模型来表达聚类原型。",
    "t": "single",
    "a": "高斯混合聚类"
  },
  "660": {
    "q": "在K均值算法中，（）可用于获得全局最小。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "661": {
    "q": "聚类算法的性能度量可称为（）。",
    "t": "single",
    "a": "有效性指标"
  },
  "662": {
    "q": "DBSCAN算法的MinPts参数的意义是（）。",
    "t": "single",
    "a": "密度i哥值"
  },
  "663": {
    "q": "AGNES 是一种采用（）策略的层次聚类算法。",
    "t": "single",
    "a": "自底向上"
  },
  "664": {
    "q": "下列关于K均值与DBSCAN比较的说法不正确的是（）。",
    "t": "single",
    "a": "K均值丢弃被它识别为噪声的对象，而DBSCAN—般聚类所有对象"
  },
  "665": {
    "q": "K-means++算法选择初始seeds的基本思想就是初始的聚类中心之间的相互距离要尽可能的远。对以下步骤:①从输入的数据点集合中随机选择一个点作为第一个聚类中心；②对于数据集中的每一个点x,计算它与最近聚类中心（指已选择的聚类中心）的距离D（x）；③选择一个新的数据点作为新的聚类中心，选择的原则是D（x）较大的点，被选取作为聚类中心的概率较大；④重复②和③直到个聚类中心被选出来；⑤利用这k个初始的聚类中心来运行标准的K-means算法。K-means++算法的正确流程为（）。",
    "t": "single",
    "a": "①②③④⑤"
  },
  "666": {
    "q": "下列关于层次聚类算法的过程:①不断重复直到达到预设的聚类簇数；②不断合并距离最近的聚类簇；③对初始聚类簇和相应的距离矩阵初始化；④对合并得到的聚类簇进行更新。正确的执行顺序为（）。",
    "t": "single",
    "a": "③②④①"
  },
  "667": {
    "q": "下列关于聚类挖掘技术的说法错误的是（）。",
    "t": "single",
    "a": "要求同类数据的内容相似度尽可能小"
  },
  "668": {
    "q": "下列说法正确的是（）。",
    "t": "single",
    "a": "数据挖掘的主要任务是从数据中发现潜在的规律，从而能更好地完成描述数据、预测数据等任务"
  },
  "669": {
    "q": "当不知道数据所带标签时，可以使用（）促使带同类标签的数据与带其他标签的数据相分离。",
    "t": "single",
    "a": "聚类"
  },
  "670": {
    "q": "聚类是一种典型的无监督学习任务，然而在现实聚类任务中我们往往能获得一些额外的监督信息，于是可通过（）来利用监督信息以获得更好的聚类效果。",
    "t": "single",
    "a": "半监督聚类"
  },
  "671": {
    "q": "K-Means算法无法聚（）样本。",
    "t": "single",
    "a": "螺旋分布"
  },
  "672": {
    "q": "划分聚类算法是一种简单的较为基本的重要聚类方法。它的主要思想是通过将数据点集分为（）个划分，并使用重复的控制策略使某个准则最优化，以达到最终的结果。",
    "t": "single",
    "a": "K"
  },
  "673": {
    "q": "（）不属于聚类性能度量外部指标。",
    "t": "single",
    "a": "DB指数"
  },
  "674": {
    "q": "下列聚类方法中采用概率模型来表达聚类的是（）。",
    "t": "single",
    "a": "高斯混合聚类"
  },
  "675": {
    "q": "变量的不确定性越大，相对应信息嫡的变化是（）。",
    "t": "single",
    "a": "熵变大"
  },
  "676": {
    "q": "决策树的基本流程遵循（）的策略。",
    "t": "single",
    "a": "分而治之"
  },
  "677": {
    "q": "训练样本集$含有天气、气温、人体感受、风力4个指标，已知天气的嫡为0.694,温度的炳为0.859,人体感受的嫡为0.952,风力的嫡为0.971,如使用ID3算法,选择（）为树'模型的分界点。",
    "t": "single",
    "a": "天气"
  },
  "678": {
    "q": "著名的C4.5决策树算法使用（）来选择最优划分属性。",
    "t": "single",
    "a": "增益率"
  },
  "679": {
    "q": "下列操作属于预剪枝的是（）。",
    "t": "single",
    "a": "限制树模型的深度"
  },
  "680": {
    "q": "信息嫡是度量（）的最常用的一种指标。",
    "t": "single",
    "a": "样本的纯度"
  },
  "681": {
    "q": "决策树中，同一路径上的所有属性之间是（）关系。",
    "t": "single",
    "a": "逻辑与"
  },
  "682": {
    "q": "决策树模型的规模应当是（）。",
    "t": "single",
    "a": "适当限制其复杂程度"
  },
  "683": {
    "q": "后剪枝是先从训练集生成一颗完整的决策树，然后（）对非叶结点进行考察。",
    "t": "single",
    "a": "自底向上"
  },
  "684": {
    "q": "CART决策树通常采用（）剪枝方法。",
    "t": "single",
    "a": "CCP（代价复杂度）"
  },
  "685": {
    "q": "决策树中的叶结点对应于（）。",
    "t": "single",
    "a": "决策结杲"
  },
  "686": {
    "q": "可用信息增益来进行决策树的（）。",
    "t": "single",
    "a": "划分属性选择"
  },
  "687": {
    "q": "信息增益、增益率分别对可取值数目（）的属性有所偏好。",
    "t": "single",
    "a": "较高，较低"
  },
  "688": {
    "q": "决策树中的叶节点对应于决策树结果，其他节点对应于",
    "t": "single",
    "a": "属性测试"
  },
  "689": {
    "q": "用决策树法训练大量数据集时，（）最节约时间。",
    "t": "single",
    "a": "减少数的深度"
  },
  "690": {
    "q": "决策树的父节点和子节点的嫡的大小关系是（）。",
    "t": "single",
    "a": "子节点的嫡更小"
  },
  "691": {
    "q": "下列关于决策树的说法错误的是（）。",
    "t": "single",
    "a": "决策树算法对于噪声的干扰非常敏感"
  },
  "692": {
    "q": "在大型数据集上训练决策树时，为了花费更少的时间来训练这个模型，下列做法正确的是（）。",
    "t": "single",
    "a": "减小树的深度"
  },
  "693": {
    "q": "（）在划分属性时是在当前结点的属性集合中选择一个最优属性。",
    "t": "single",
    "a": "传统决策树"
  },
  "694": {
    "q": "（）算法是决策树学习的基本算法，其他多数决策树学习方法都是它的变体。",
    "t": "single",
    "a": "ID3"
  },
  "695": {
    "q": "下列关于选择Logistic回归中的One-Vs-All方法的描述正确的是（）。",
    "t": "single",
    "a": "我们需要在n类分类问题中适合n个模型"
  },
  "696": {
    "q": "假设在庞大的数据集上使用Logistic回归模型，可能遇到一个问题，Logistic回归需要很长时间才能训练，如果对相同的数据进行逻辑回归，则花费更少的时间，并给岀比较相似的精度的方法是（）。",
    "t": "single",
    "a": "增加学习率，减少迭代次数"
  },
  "697": {
    "q": "（）的系数没有封闭形式(closed-form)的解。",
    "t": "single",
    "a": "Lasso"
  },
  "698": {
    "q": "逻辑回归将输出概率范围限定为[0,1],（）函数能起到这样的作用。",
    "t": "single",
    "a": "sigmoid（）函数"
  },
  "699": {
    "q": "假如使用逻辑回归对样本进行分类，得到训练样本的准确率和测试样本的准确率。现在，在数据中增加一个新的特征，其他特征保持不变。然后重新训练测试。则下列说法正确的是（）。",
    "t": "single",
    "a": "训练样本准确率一定增加或保持不变"
  },
  "700": {
    "q": "在逻辑回归输出与目标对比的情况下，下列评估指标不适用的是（）。",
    "t": "single",
    "a": "均方误差"
  },
  "701": {
    "q": "（）表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。",
    "t": "single",
    "a": "噪声"
  },
  "702": {
    "q": "当学习器将训练样本自身的特点作为所有潜在样本都具有的一般性质，这样会导致泛化性能下降，这种现象称为（）。",
    "t": "single",
    "a": "过拟合"
  },
  "703": {
    "q": "如果使用数据集的全部特征并且准确率能够达到100%,但在测试集上准确率仅能达到70%左右，这说明（）。",
    "t": "single",
    "a": "过拟合"
  },
  "704": {
    "q": "下列关于欠拟合(under-fitting)的说法正确的是（）。",
    "t": "single",
    "a": "训练误差较大，测试误差较大"
  },
  "705": {
    "q": "留出法直接将数据集划分为（）个互斥的集合。",
    "t": "single",
    "a": "二"
  },
  "706": {
    "q": "下列可分解为偏差、方差与噪声之和的是（）。",
    "t": "single",
    "a": "泛化误差(generalization error)"
  },
  "707": {
    "q": "下列能够直观显示岀学习器在样本总体上的查全率、查准率的是（）。",
    "t": "single",
    "a": "P-R 曲线<br>参考答案D"
  },
  "708": {
    "q": "当训练集特征非常多，而实例非常少的时候，可以采用（）。",
    "t": "single",
    "a": "不带核的支持向量机"
  },
  "709": {
    "q": "下列回归模型中最能影响过拟合与欠拟合之间平衡的步骤是（）。",
    "t": "single",
    "a": "多项式的阶数"
  },
  "710": {
    "q": "AUC是衡量（）模型优劣的一种评价指标。",
    "t": "single",
    "a": "二分类"
  },
  "711": {
    "q": "在留出法、交叉验证法和自助法三种评估方法中，（）更适用于数据集较小、难以划分训练集和测试集的情况。",
    "t": "single",
    "a": "自助法"
  },
  "712": {
    "q": "下列关于非频繁模式的说法正确的有（）。",
    "t": "muti",
    "a": "其支持度小于阈值 | 对异常数据项敏感"
  },
  "713": {
    "q": "影响Apriori算法的计算复杂度的有（）。",
    "t": "muti",
    "a": "支持度阈值 | 项数（维度） | 事务数 | 事务平均宽度"
  },
  "714": {
    "q": "下列关于范数规则化的描述正确的有（）。",
    "t": "muti",
    "a": "L1范数是指向量中各个元素绝对值之和 | L2范数向量元素绝对值的平方和再开平方 | L0是指向量中非0的元素的个数"
  },
  "715": {
    "q": "机器学习的三个关键组成要素包含（）。",
    "t": "muti",
    "a": "任务T | 性能指标P | 经验来源E"
  },
  "716": {
    "q": "下列对模型性能提高有帮助的有（）。",
    "t": "muti",
    "a": "数据预处理 | 特征工程 | 机器学习算法 | 模型集成"
  },
  "717": {
    "q": "假设目标遍历的类别非常不平衡，即主要类别占据了训练数据的99%,假设现在模型在训练集上表现为99%的准确度，那么下列说法正确的有（）。",
    "t": "muti",
    "a": "准确度并不适合衡量不平衡类别问题 | 精确度和召回率适合于衡量不平衡类别问题"
  },
  "718": {
    "q": "如果想要训练一个ML模型，样本数量为100万个，特征维度为5000个，面对如此大数据，那么有效地训练模型可以采取的措施有（）。",
    "t": "muti",
    "a": "对训练集随机采样，在随机采样的数据上建立模型 | 尝试使用在线机器学习算法 | 使用PCA算法减少特征维度"
  },
  "719": {
    "q": "下列关于机器学习的理解正确的有（）。",
    "t": "muti",
    "a": "监督学习和非监督学习的区别在于是否要求样本数据带标签 | 强化学习以输入数据作为对模型的反馈 | 卷积神经网络一般用于图像处理等局部特征相关的数据"
  },
  "720": {
    "q": "下列属于机器学习生成式模型的有（）。",
    "t": "muti",
    "a": "朴素贝叶斯 | 隐马尔科夫模型 | 深度信念网络"
  },
  "721": {
    "q": "集成学习中增强多样性的常见做法有（）。",
    "t": "muti",
    "a": "数据样本扰动 | 输入属性扰动 | 输出表示扰动 | 算法参数扰动"
  },
  "722": {
    "q": "常用的冲突消解策略包括（）。",
    "t": "muti",
    "a": "投票法 | 排序法 | 元规则法"
  },
  "723": {
    "q": "下列关于学习器结合的描述正确的有（）。",
    "t": "muti",
    "a": "避免单学习器可能因误选而导致泛化性能不佳 | 降低陷入局部极小点的风险 | 假设空间扩大有可能学得更好的近似"
  },
  "724": {
    "q": "随机森林在做数据处理方面的优势有（）。",
    "t": "muti",
    "a": "不需要做缺失值处理 | 不需要做特征选择 | 不需要平衡数据集"
  },
  "725": {
    "q": "随机森林的随机性主要体现在（）。",
    "t": "muti",
    "a": "数据集的随机性 | 待选特征的随机性"
  },
  "726": {
    "q": "下列关于集成学习的说法正确的有（）。",
    "t": "muti",
    "a": "随机森林是减少模型的方差，而GBDT是减少模型的偏差 | 组成随机森林的树可以并行生成，而GBDT是串行生成 | 随机森林的结果是多数表决的,而GBDT则是多棵树累加之和 | 随机森林对异常值不敏感，而GBDT对异常值比较敏感"
  },
  "727": {
    "q": "下列关于EM算法的描述正确的有（）。",
    "t": "muti",
    "a": "EM算法是常用的估计参数隐变量的利器 | EM算法即是期望最大化算法 | EM算法常被用来学习高斯混合模型的参数 | EM算法是一种迭代式的方法"
  },
  "728": {
    "q": "在监督式学习中使用聚类算法的方法有（）。",
    "t": "muti",
    "a": "首先可以创建聚类，然后分别在不同的集群上应用监督式学习算法 | 在应用监督式学习算法之前，可以将其类别ID作为特征空间中的一个额外的特征"
  },
  "729": {
    "q": "影响聚类算法效果的主要原因有（）。",
    "t": "muti",
    "a": "特征选取 | 模式相似性测度 | 分类准则"
  },
  "730": {
    "q": "K均值聚类算法和层次聚类算法在一些方面有重大差异，下列关于两种算法的说法正确的有（）。",
    "t": "muti",
    "a": "在K均值聚类算法中，必须在运行算法前选定想要的簇的个数 | 在层次聚类算法中，可以在运行算法后选定想要的簇的个数 | K均值聚类算法所需的计算量比层次聚类算法小得多"
  },
  "731": {
    "q": "聚类性能度量外部指标包括（）。",
    "t": "muti",
    "a": "Jaccard系数 | FM指数 | Rand指数"
  },
  "732": {
    "q": "聚类性能度量的指标主要分为外部指标和内部指标，其中属于内部指标的是（）。",
    "t": "muti",
    "a": "DB指数 | Dunn指数"
  },
  "733": {
    "q": "常见的原型聚类算法包括（）。",
    "t": "muti",
    "a": "K均值算法 | 学习向量量化 | 高斯混合聚类"
  },
  "734": {
    "q": "下列关于密度聚类的说法错误的有（）。",
    "t": "muti",
    "a": "密度聚类从样本数量的角度来考察样本之间的可连接性 | 密度聚类基于不可连接样本不断扩展聚类簇，以获得最终的聚类结果 | 密度直达关系通常满足对称性"
  },
  "735": {
    "q": "下列不属于聚类性能度量内部指标的有（）。",
    "t": "muti",
    "a": "Jaccard系数 | FM系数"
  },
  "736": {
    "q": "常见的聚类性能度量外部指标有（）。",
    "t": "muti",
    "a": "Jaccard系数 | FM指数"
  },
  "737": {
    "q": "决策树递归返回的条件有()",
    "t": "muti",
    "a": "所有的类标签完全相同 | 特征用完"
  },
  "738": {
    "q": "决策树的划分选择有()。",
    "t": "muti",
    "a": "信息增益 | 增益率 | 基尼系数"
  },
  "739": {
    "q": "决策树在()情况下会导致递归返回。",
    "t": "muti",
    "a": "当前节点包含的样本全属于同一类 | 当前属性集为空 | 当前节点包含的样本集合为空 | 所有样本在所有属性上取值相同"
  },
  "740": {
    "q": "下列关于决策树的优点的描述正确的有()。",
    "t": "muti",
    "a": "可读性强 | 分类速度快"
  },
  "741": {
    "q": "预剪枝使得决策树的很多分子都没有展开,则会导致的结果有()。",
    "t": "muti",
    "a": "显著减少训练时间开销 | 显著减少测试时间开销 | 降低过拟合风险 | 提高欠拟合风险"
  },
  "742": {
    "q": "可作为决策树选择划分属性的参数有（）。",
    "t": "muti",
    "a": "信息增益 | 信息增益率 | 基尼指数"
  },
  "743": {
    "q": "下列关于Ridge回归的说法正确的有（）。",
    "t": "muti",
    "a": "若λ=0,则等价于一般的线性回归 | 若λ=+∞,则得到的权重系数很小，接近于零"
  },
  "744": {
    "q": "一个监督观测值集合会被划分为（）。",
    "t": "muti",
    "a": "训练集 | 验证集 | 测试集"
  },
  "745": {
    "q": "做一个二分类预测问题，先设定阈值为0.5,概率不小于0.5的样本归入正例类（即1）,小于0.5的样本归入反例类（即0）。然后，用阈值n（n>0.5）重新划分样本到正例类和反例类。下列说法正确的有（）。",
    "t": "muti",
    "a": "增加阈值不会提高召回率 | 増加阈值不会降低查准率"
  },
  "746": {
    "q": "下列关于AUC面积的描述正确的有（）。",
    "t": "muti",
    "a": "AUC被定义为ROC曲线下与坐标轴围成的面积 | AUC面积的值等于0.5时，真实性最低，无应用价值 | AUC面积的值越接近1.0,检测方法真实性越高"
  },
  "747": {
    "q": "HighBias（高偏差）的解决方式有（）。",
    "t": "muti",
    "a": "Boosting | 复杂模型（非线性模型、增加神经网络中的层） | 更多特征"
  },
  "748": {
    "q": "关于特征向量的缺失值处理方式如下：缺失值较多，直接将该特征舍弃掉，否则可能会带入较大的noise，对结果造成不良影响；缺失值较少，其余的特征缺失值都在10%以内，可以采取的处理方式有（）。",
    "t": "muti",
    "a": "把NaN直接作为一个特征,假设用0表示 | 用均值填充 | 用随机森林等算法预测填充"
  },
  "749": {
    "q": "如果将",
    "t": "muti",
    "a": "C三个分类器的P-R曲线画在一个图中，其中A.B的P-R曲线可以完全包含住C的P-R曲线，A.B的P-R曲线有交点，A.B.C的平衡点分别为0.79、0.66、0.58,则下列说法中正确的有（）。A.学习器A的性能优于学习器CB.学习器A的性能优于学习器B | 学习器B的性能优于学习器C | 学习器C的性能优于学习器B"
  },
  "750": {
    "q": "下列可以用来评估线性回归模型的指标有（）。",
    "t": "muti",
    "a": "R-Squared | AdjustedR-Squared | FStatistics | RMSE/MSE/MAE"
  },
  "751": {
    "q": "如果希望减少数据集中的特征数量，则可以采取的措施有（）。",
    "t": "muti",
    "a": "使用正向选择法（ForwardSelection） | 使用反向消除法（BackwardElimination） | 逐步选择消除法（Stepwise） | 计算不同特征之间的相关系数，删去相关系数高的特征之一"
  },
  "752": {
    "q": "下列可以用于特征降维的方法有（）。",
    "t": "muti",
    "a": "主成分分析PCA | 线性判别分析LDA | 矩阵奇异值分解SVD"
  },
  "753": {
    "q": "下列关于L1和L2范数的描述正确的有()",
    "t": "muti",
    "a": "L1范数为x向量各个元素绝对值之和 | L2范数为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或Frobenius范数 | L1范数可以使权值稀疏，方便特征提取 | L2范数可以防止过拟合，提升模型的泛化能力"
  },
  "754": {
    "q": "下列属于范数规则化作用的有()。",
    "t": "muti",
    "a": "保证模型尽可能的简单，避免过拟合 | 约束模型特征"
  },
  "755": {
    "q": "针对维数灾难，主要釆用的降维方法有()。",
    "t": "muti",
    "a": "多维缩放 | 主成分分析 | 核化线性降维 | 流形学习 | 度量学习"
  },
  "756": {
    "q": "特征选择在子集生成与搜索方面引入了人工智能搜索技术和子集评价方法。其中人工智能搜索技术有()。",
    "t": "muti",
    "a": "分支界限法 | 浮动搜索法 | 信息熵 | AIC"
  },
  "757": {
    "q": "特征选择的目的有()。",
    "t": "muti",
    "a": "减少特征数量、降维 | 使模型泛化能力更强 | 减少过拟合。"
  },
  "758": {
    "q": "在正则化公式中，λ为正则化参数。下列关于λ的描述正确的有（）。",
    "t": "muti",
    "a": "若正则化参数λ过大，可能会导致出现欠拟合现象 | 若λ太大，则梯度下降可能不收敛 | 取一个合理的λ，可以更好地应用正则化 | 如果令λ很大的话，为了使CostFunction尽可能的小，所有θ（不包括θ0）都会在一定程度上减小"
  },
  "759": {
    "q": "下列关于特征数据归一化的说法正确的有（）。",
    "t": "muti",
    "a": "特征数据归一化加速梯度下降优化的速度 | 特征数据归一化有可能提高模型的精度 | 概率模型不需要做归一化处理"
  },
  "760": {
    "q": "下列关于LDA判别分析思想的描述正确的有（）。",
    "t": "muti",
    "a": "同类样例的投影点尽可能近 | 异类样例的投影点尽可能远"
  },
  "761": {
    "q": "下列方法中适合减少数据集中的特征数即降维的有（）。",
    "t": "muti",
    "a": "使用前向特征选择方法 | 使用后向特征排除方法 | 我们先把所有特征都使用，去训练一个模型，得到测试集上的表现。然后我们去掉一个特征，再去训练，用交叉验证看看测试集上的表现。如果表现比原来还要好，我们可以去除这个特征 | 查看相关性表，去除相关性最高的一些特征"
  },
  "762": {
    "q": "线性模型的基本形式有（）。",
    "t": "muti",
    "a": "线性回归 | 对数几率回归（二分类问题） | 线性判别分析（Fisher判别分析） | 多分类学习"
  },
  "763": {
    "q": "常见的回归分析的种类有（）",
    "t": "muti",
    "a": "线性回归 | 逻辑回归 | 曲线回归"
  },
  "764": {
    "q": "下列关于相关与线性关系的说法正确的有（）。",
    "t": "muti",
    "a": "相关不一定是线性关系，可能是非线性关系 | 相关时若有相关系数为0,说明两个变量之间不存在线性关系，仍可能存在非线性关系 | 相关系数为0是两个变量独立的必要不充分条件"
  },
  "765": {
    "q": "可以帮助解决训练集在特征空间中线性不可分的问题的方法有（）。",
    "t": "muti",
    "a": "软间隔 | 核函数"
  },
  "766": {
    "q": "当构造线性模型时，应注意变量间的相关性。在相关矩阵中搜索相关系数时，如果发现3对变量的相关系数是（Var1和Var2、Var2和Var3、Var3和Var1）,相关系数分别是-0.98、0.45、1.23,则可以得出的结论有（）",
    "t": "muti",
    "a": "Var1和Var2是非常相关的 | 因为Var1和Var2是非常相关的，可以去除其中一个 | Var3和Var1的相关系数1.23是不可能的"
  },
  "767": {
    "q": "许多功能更为强大的非线性模型可在线性模型基础上通过引入（）而得。",
    "t": "muti",
    "a": "层级结构 | 高维映射"
  },
  "768": {
    "q": "常见的核函数包括（）。",
    "t": "muti",
    "a": "多项式核 | 高斯核 | 线性核 | 拉普拉斯核 | Sigmoid核"
  },
  "769": {
    "q": "对于主成分分析方法，确定降维后低维空间的维数d的方法有（）。",
    "t": "muti",
    "a": "由用户事先指定 | 通过在d不同的低维空间中对开销较小的学习器进行交叉验证来选取 | 可从重构的角度设置一个重构阈值，选取使得特定公式成立的最小值"
  },
  "770": {
    "q": "下列关于PCA的说法正确的有（）。",
    "t": "muti",
    "a": "在使用PCA之前，我们必须标准化数据 | 应该选择具有最大方差的主成分 | 可以使用PCA在低维空间中可视化数据"
  },
  "771": {
    "q": "下列关于降维方法的叙述正确的有（）。",
    "t": "muti",
    "a": "流形学习是一种借鉴拓扑流形概念的降维方法 | 度量学习绕过降维的过程，将学习目标转化为对距离度量计算的权重矩阵的学习"
  },
  "772": {
    "q": "特征选择方法有（）",
    "t": "muti",
    "a": "LARS嵌入式特征选择方法 | LVW包裹式特征选择方法 | Relief过滤式特征选择方法"
  },
  "773": {
    "q": "下列说法正确的有（）",
    "t": "muti",
    "a": "条件独立性假设不成立时，朴素贝叶斯分类器仍有可能产生最优贝叶斯分类器 | 在估计概率值时使用的拉普拉斯修正避免了因训练集样本不充分而导致概率估值为零的问题 | 二分类任务中两类数据满足高斯分布且方差相同时，线性判别分析产生贝叶斯最优分类器"
  },
  "774": {
    "q": "数据挖掘的主要功能包括概念描述、趋势分析、孤立点分析、（）等方面。",
    "t": "muti",
    "a": "关联分析 | 分类和预测分析 | 聚类分析 | 偏差分析"
  },
  "775": {
    "q": "下列关于特征的稀疏性的说法正确的有（）。",
    "t": "muti",
    "a": "稀疏性指的是矩阵中有许多列与当前学习任务无关 | 稀疏样本可减少学习任务的计算开销 | 学习任务难度可能有所降低"
  },
  "776": {
    "q": "在统计模式分类问题中，当先验概率未知时，可以使用（）",
    "t": "muti",
    "a": "最小最大损失准则 | N-P判决"
  },
  "777": {
    "q": "常用的代价函数有（）。",
    "t": "muti",
    "a": "均方误差 | 均方根误差 | 平均绝对误差 | 交叉熵"
  },
  "778": {
    "q": "（）是通过对无标记训练样本的学习来进行分类的。",
    "t": "muti",
    "a": "密度估计 | 异常检测 | 聚类分析"
  },
  "779": {
    "q": "下列属于数值优化算法的有（）。",
    "t": "muti",
    "a": "梯度下降法 | 牛顿法"
  },
  "780": {
    "q": "按照涉及自变量的多少，可以将回归分析分为（）。",
    "t": "muti",
    "a": "一元回归分析 | 多元回归分析"
  },
  "781": {
    "q": "鉴别多元共线特征后，下一步可能的操作有（）。",
    "t": "muti",
    "a": "不移除两个变量，而是移除一个 | 移除相关变量可能会导致信息损失，可以使用惩罚线性回归模型（如ridge或lassoregression）"
  },
  "782": {
    "q": "深度学习方法不适用的数据集有（）。",
    "t": "muti",
    "a": "数据样本不足 | 数据集没有局部相关特性"
  },
  "783": {
    "q": "下列关于神经网络的说法正确的有（）。",
    "t": "muti",
    "a": "增加网络层数，可能会增加测试集分类错误率 | 减少网络层数，可能会减少测试集分类错误率"
  },
  "784": {
    "q": "一个回归模型存在多重共线问题，在不损失过多信息的情况下，可采取的措施有()。",
    "t": "muti",
    "a": "剔除共线性变量中的一个 | 通过计算方差膨胀因子(varianceinflationfactor，VIF)来检查共线性程度，并采取相应措施 | 删除相关变量可能会有信息损失，我们可以不删除相关变量，而使用一些正则化方法来解决多重共线性问题，例如Ridge或Lasso回归"
  },
  "785": {
    "q": "特征向量的归一化方法有()。",
    "t": "muti",
    "a": "线性函数转换 | 对数函数转换 | 反余切函数转换 | 减去均值，除以方差"
  },
  "786": {
    "q": "下列属于数据挖掘方法的有()。",
    "t": "muti",
    "a": "聚类 | 回归分析 | 神经网络 | 决策树算法"
  },
  "787": {
    "q": "数据再利用的意义有()。",
    "t": "muti",
    "a": "挖掘数据的潜在价值 | 实现教据重组的创新价值 | 利用数据可拓展性拓宽业务领域"
  },
  "788": {
    "q": "下列属于数据挖掘与分析工具的有()。",
    "t": "muti",
    "a": "Tableau | Python | SPSS | Alteyx"
  },
  "789": {
    "q": "机器学习对噪声数据具有高承受能力，并能对未经过训练的数据具有分类能力，但其需要很长的训练时间，因而对于有足够长训练时间的应用更合适。()",
    "t": "judge",
    "a": "正确"
  },
  "790": {
    "q": "DBSCAN是相对抗噪声的,并且能够处理任意形状和大小的簇。()",
    "t": "judge",
    "a": "正确"
  },
  "791": {
    "q": "K均值是一种产生划分聚类的基于密度的聚类算法，簇的个数由算法自动确定。()",
    "t": "judge",
    "a": "错误"
  },
  "792": {
    "q": "在决策树中，随着树中结点数变得太大，即使模型的训练误差还在继续减低，但是检验误差开始增大，这是出现了模型拟合不足的问题。()",
    "t": "judge",
    "a": "错误"
  },
  "793": {
    "q": "Logistic回归目标函数是最小化后验概率。（）",
    "t": "judge",
    "a": "错误"
  },
  "794": {
    "q": "回归问题和分类问题都有可能发生过拟合。（）",
    "t": "judge",
    "a": "正确"
  },
  "795": {
    "q": "在机器学习中，随着树中节点数变得太大，即使模型的训练误差还在继续减低，但是检验误差开始增大，这是出现了模型拟合不足的问题。（）",
    "t": "judge",
    "a": "错误"
  },
  "796": {
    "q": "正确率、召回率取值都在0和1之间，数值越接近0，查准率或查全率就越高。（）",
    "t": "judge",
    "a": "错误"
  },
  "797": {
    "q": "L1范数比L2范数更易于获得稀疏解，即L1求得的ω会有更少的非零分量。（）",
    "t": "judge",
    "a": "正确"
  },
  "798": {
    "q": "包裹式特征选择针对给定学习器进行优化，从最终学习器性能来看，该方法比过滤式选择更好，但由于需多次训练学习器，它的特征选择的计算开销通常比前者要大得多。（）",
    "t": "judge",
    "a": "正确"
  },
  "799": {
    "q": "支持向量机是针对二分类任务设计的，也可直接应用于多分类任务。（）",
    "t": "judge",
    "a": "错误"
  },
  "800": {
    "q": "进行PCA降维时需要计算协方差矩阵。（）",
    "t": "judge",
    "a": "正确"
  },
  "801": {
    "q": "LogisticRegression和SupportVectprMachine都可以处理分类问题，且一般都用于处理线性二分类问题。（）",
    "t": "judge",
    "a": "正确"
  },
  "802": {
    "q": "SupportVectorMachine的目标是找到使得训练数据尽可能分开且分类间隔最大的超平面，应该属于结构风险最小化。（）",
    "t": "judge",
    "a": "正确"
  },
  "803": {
    "q": "分类规则的挖掘方法通常有机器学习法、贝叶斯法、人工机器学习法、粗糙集法和遗传算法。（）",
    "t": "judge",
    "a": "正确"
  },
  "804": {
    "q": "分类预测型任务从已分类的数据中学习模型，并对新的未知分类的数据使用该模型进行解释，得到这些数据的分类。根据标签的不同，分别称为分类任务和预测任务。如果标签是连续的类别，称为预测任务。（）",
    "t": "judge",
    "a": "正确"
  },
  "805": {
    "q": "机器学习可以解决给定数据的预测问题，也可以解决大数据存储和并行计算。（）",
    "t": "judge",
    "a": "错误"
  },
  "806": {
    "q": "KNN算法可以较好地避免样本的不平衡问题。（）",
    "t": "judge",
    "a": "正确"
  },
  "807": {
    "q": "k近邻学习是一种常用的无监督学习方法，其工作机制为给定测试样本，基于某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个邻居的信息来进行预测。（）",
    "t": "judge",
    "a": "错误"
  },
  "808": {
    "q": "基于邻近度的离群点检测方法不能处理具有不同密度区域的数据集。（）",
    "t": "judge",
    "a": "正确"
  },
  "809": {
    "q": "归纳与演绎是科学推理的两大基本手段，前者是从一般到特殊的特化过程，后者是从特殊到一般的泛化过程。（）",
    "t": "judge",
    "a": "错误"
  },
  "810": {
    "q": "规则通常是指语义明确、能描述数据分布所隐含的客观规律的逻辑规则。（）",
    "t": "judge",
    "a": "正确"
  },
  "811": {
    "q": "检测一元正态分布中的离群点，属于异常检测中的基于密度的离群点检测。（）",
    "t": "judge",
    "a": "错误"
  },
  "812": {
    "q": "在HMM中，如果已知观察序列和产生观察序列的状态序列，那么可以采用极大似然估计直接进行参数估计。（）",
    "t": "judge",
    "a": "正确"
  },
  "813": {
    "q": "孤立点在数据挖掘时总是被视为异常、无用数据而遭丢弃。（）",
    "t": "judge",
    "a": "错误"
  },
  "814": {
    "q": "当学习器把训练样本学得太好时，很可能把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，会导致泛化性能下降。（）",
    "t": "judge",
    "a": "正确"
  },
  "815": {
    "q": "如果一个模型使用数据集的全部特征并且能够达到100%的准确率，但在测试集上仅能达到70%左右，这说明模型欠拟合。（）",
    "t": "judge",
    "a": "错误"
  },
  "816": {
    "q": "预剪枝决策树的训练时间开销比后剪枝决策树要大得多。（）",
    "t": "judge",
    "a": "错误"
  },
  "817": {
    "q": "训练完SVM模型后，不是支持向量的那些样本我们可以丢掉，也可以继续分类。（）",
    "t": "judge",
    "a": "正确"
  },
  "818": {
    "q": "对于PCA处理后的特征，其朴素贝叶斯特征相互独立的假设一定成立，因为所有主成分都是正交的，所以不相关。（）",
    "t": "judge",
    "a": "错误"
  },
  "819": {
    "q": "阶跃函数与sigmoid函数均为典型激活函数。（）",
    "t": "judge",
    "a": "正确"
  },
  "820": {
    "q": "对于PCA（主成分分析）转化过的特征，朴素贝叶斯的不依赖假设总是成立，因为所有主要成分是正交的。（）",
    "t": "judge",
    "a": "错误"
  },
  "821": {
    "q": "两个变量相关，它们的相关系数r可能为0。（）。",
    "t": "judge",
    "a": "正确"
  },
  "822": {
    "q": "考察一个由三个卷积层组成的CNN: kemel=3 x 3, stride=2, padding=SAMEo最低层输出100个特征映射(featuremap ),中间层200个特征映射，最高层400个特征映射。输入是200 x300的RGB图片,则总参数的数量是()。",
    "t": "single",
    "a": "903400"
  },
  "823": {
    "q": "考虑某个具体问题时可能只有少量数据，但如果有一个类似问题已经预先训练好的神经网络，则可以有很靠谱的先验。可以利用这个预先训练好的网络的方法是()",
    "t": "single",
    "a": "只对最后几层进行训练调参(fine tune )"
  },
  "824": {
    "q": "如果训练一个RNN网络时发现权重与激活值都是NaN,则导致这个问题最有可能<br>的原因是()。",
    "t": "single",
    "a": "梯度爆炸"
  },
  "825": {
    "q": "设计为8层的卷积神经网络AlexNet网络成功使用（），其效果远远地超过了Sigmoid 函数。",
    "t": "single",
    "a": "ReLU 函数"
  },
  "826": {
    "q": "深度学习是当前很热门的机器学习算法，深度学习涉及大量的矩阵相乘，现在需要计算三个稠密矩阵",
    "t": "single",
    "a": "C的乘积ABC，假设三个矩阵的尺寸分别为mxn, nxp, pxq, 且m小于n小于p小于q, 则下列计算顺序效率最高的是（\t）。<br>A.（AB） C<br>B.AC（B）"
  },
  "827": {
    "q": "输入图像为 37x37,经过第一层卷积（the number of filters=25, kemelsize=5 x 5, padding=valid, stride= 1)与池化层 maxpooling (kernel size=3 x 3, padding=valid), 输出特征图 大小为（   ）。",
    "t": "single",
    "a": "11 x 11"
  },
  "828": {
    "q": "输入图像为32 X 32, 经过步长为1、 不进行padding、卷积核为5x5的卷积层后，得到的特征图尺寸是（   ）。",
    "t": "single",
    "a": "28 x 28"
  },
  "829": {
    "q": "输入图像已被转换为大小为28x28的矩阵和大小为7x7的步幅为1的核心/滤波<br>器，则卷积矩阵的大小是（）。",
    "t": "single",
    "a": "22 x 22"
  },
  "830": {
    "q": "属于卷积神经网络应用方向的是（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "831": {
    "q": "（）不是神经网络的代表。",
    "t": "single",
    "a": "xgboost算法"
  },
  "832": {
    "q": "下列不属于深度学习内容的是（）。",
    "t": "single",
    "a": "贝叶斯学习"
  },
  "833": {
    "q": "下列关于Sigmoid函数的说法错误的是（）。",
    "t": "single",
    "a": "存在梯度爆炸的问题"
  },
  "834": {
    "q": "下列关于BP网络的说法不正确的是（）。",
    "t": "single",
    "a": "晚停策略可用来缓解BP网络的欠拟合问题"
  },
  "835": {
    "q": "下列关于LSTM的说法错误的是（  ）。",
    "t": "single",
    "a": "RNN是LSTM的变种"
  },
  "836": {
    "q": "下列关于RBM的说法错误的是（）。",
    "t": "single",
    "a": "学习过程很快"
  },
  "837": {
    "q": "下列关于RNN的说法正确的是（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "838": {
    "q": "下列关于核函数特性的描述错误的是（）。",
    "t": "single",
    "a": "核函数是一种降维模型"
  },
  "839": {
    "q": "下列关于极大似然估计的描述错误的是（）。",
    "t": "single",
    "a": "极大似然估计没有确定的概率分布形式"
  },
  "840": {
    "q": "（）不是专门用于可视化时间空间数据的技术。",
    "t": "single",
    "a": "饼图"
  },
  "841": {
    "q": "与HMM和MEMM模型相比，CRF模型的优势不包含（）。",
    "t": "single",
    "a": "速度快"
  },
  "842": {
    "q": "（）会发生权重共享。",
    "t": "single",
    "a": "A.B"
  },
  "843": {
    "q": "下列关于模型能力（modelcapacity,指神经网络模型能拟合复杂函数的能力）的描述正确的是（）。",
    "t": "single",
    "a": "隐藏层层数增加，模型能力增加"
  },
  "844": {
    "q": "在神经网络中引入了非线性的是（）。",
    "t": "single",
    "a": "修正线性单元（ReLU ）"
  },
  "845": {
    "q": "有反馈连接的架构是（）。",
    "t": "single",
    "a": "循环神经网络"
  },
  "846": {
    "q": "下列算法中:①KNN算法；②线性回归；③逻辑回归。可以用神经网络构建的算<br>法是（）。",
    "t": "single",
    "a": "②③"
  },
  "847": {
    "q": "下列属于卷积网络类型分类的是（    ）",
    "t": "single",
    "a": "以上都正确"
  },
  "848": {
    "q": "下列关于词袋模型的说法错误的是（）。",
    "t": "single",
    "a": "词袋模型可以应用于文档分类和检索，同时受到编码信息的限制"
  },
  "849": {
    "q": "下列不属于循环神经网络的输出模式是（）。<br>",
    "t": "single",
    "a": "同步多输出"
  },
  "850": {
    "q": "循环神经网络适合处理的数据是（）。",
    "t": "single",
    "a": "序列数据"
  },
  "851": {
    "q": "下列问题与RNN相关的是（）。",
    "t": "single",
    "a": "以上都正确"
  },
  "852": {
    "q": "下列关于DNN的说法不正确的是（）。",
    "t": "single",
    "a": "广义上包含CNN.DBN.SVM等"
  },
  "853": {
    "q": "下列关于人工神经网络（ANN）的描述错误的是（）。",
    "t": "single",
    "a": "神经网络对训练数据中的噪声非常鲁棒"
  },
  "854": {
    "q": "下列算法中:①KNN；②线性回归；③对数几率回归。可以用神经网络去构造的（ ）。",
    "t": "single",
    "a": "②③"
  },
  "855": {
    "q": "（）不是长短时记忆神经网络三个门中的一个门。",
    "t": "single",
    "a": "进化门"
  },
  "856": {
    "q": "（）属于浅层学习模型。",
    "t": "single",
    "a": "SVM"
  },
  "857": {
    "q": "属于深度学习框架的是（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "858": {
    "q": "下列说法不正确的是（）。",
    "t": "single",
    "a": "长短时记忆神经网络是和循环神经网络完全不同的一种新型神经网络"
  },
  "859": {
    "q": "下列说法有错误的是（）。",
    "t": "single",
    "a": "沿负梯度下降的方向一定是最优的方向"
  },
  "860": {
    "q": "在深度学习中，我们经常会遇到收敛到localminimum,下列不属于解决localminimum问题的方法是（  ）。",
    "t": "single",
    "a": "增大batch size"
  },
  "861": {
    "q": "下列关于深度学习中sigmoid函数的说法错误的是（  ）",
    "t": "single",
    "a": "存在梯度爆炸的问题"
  },
  "862": {
    "q": ".在神经网络学习中，感知机输出层中的M-P神经元通常被称为（  ）。",
    "t": "single",
    "a": "阈值逻辑单元"
  },
  "863": {
    "q": "选择神经网络的深度时，对于下面参数:①神经网络的类型（如MLP, CNN）；<br>②输入数据；③计算能力（硬件和软件能力决定）；④学习速率；⑤映射的输出函 数。需要考虑的是（ ）。",
    "t": "single",
    "a": "都需要考虑"
  },
  "864": {
    "q": "在一个神经网络中，可以用来处理过拟合的方法是（）。",
    "t": "single",
    "a": "都可以"
  },
  "865": {
    "q": "在支持向量机中，核函数的主要作用是（）。",
    "t": "single",
    "a": "将低维空间中线性不可分的数据映射到高维空间，使其线性可分"
  },
  "866": {
    "q": "长短时记忆神经网络被设计用来解决的问题是（）。",
    "t": "single",
    "a": "传统RNN存在的梯度消失/爆炸问题"
  },
  "867": {
    "q": "长短时记忆神经网络缓解梯度消失问题采取的措施是（   ）。",
    "t": "single",
    "a": "增加一个用来保存长期状态的单元"
  },
  "868": {
    "q": "长短时记忆网络属于一种（   ）。",
    "t": "single",
    "a": "门控RNN"
  },
  "869": {
    "q": "自然语言处理、语音识别、股票交易、气象预测等应用适合釆用（）处理。",
    "t": "single",
    "a": "循环神经网络"
  },
  "870": {
    "q": "最早被提出的循环神经网络门控算法是（）。",
    "t": "single",
    "a": "长短期记忆网络"
  },
  "871": {
    "q": "神经网络感知机只有（）神经元进行激活函数处理，即只拥有一层功能神经元。",
    "t": "single",
    "a": "输出层"
  },
  "872": {
    "q": "下列关于多层前馈神经网络的描述错误的是（）。",
    "t": "single",
    "a": "神经元之间存在同层连接以及跨层连接"
  },
  "873": {
    "q": "下列关于SOM神经网络的描述错误的是（）。",
    "t": "single",
    "a": "SOM寻优目标为每个输出神经元找到合适的权重"
  },
  "874": {
    "q": "下列关于深度神经网络的说法正确的是（）。",
    "t": "single",
    "a": "增加神经网络层数，可能会增加测试数据集的分类错误率"
  },
  "875": {
    "q": "()网络是一种竞争学习型的无监督神经网络，它能将高维输入数据映射到低维空间，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元。",
    "t": "single",
    "a": "SOM"
  },
  "876": {
    "q": "()不仅可用于多层前馈神经网络，还可用于其他类型的神经网络。",
    "t": "single",
    "a": "误差逆传播"
  },
  "877": {
    "q": "感知机中，()是M-P神经元，也称为阈值逻辑单元。",
    "t": "single",
    "a": "输出层"
  },
  "878": {
    "q": "()用于将非线性引入神经网络，它会将值缩小到较小的范围内。",
    "t": "single",
    "a": "激活函数"
  },
  "879": {
    "q": "BP神经网络经常遭遇（）,其训练误差持续降低，但测试误差却可能上升。",
    "t": "single",
    "a": "过拟合"
  },
  "880": {
    "q": "CNN神经网络对图像特征提取带来了变革性的变化，使之前的人工特征提取升级到数据驱动的自动特征提取，在CNN中，起到特征提取作用的网络层是（）。",
    "t": "single",
    "a": "卷积层"
  },
  "881": {
    "q": "DNN常用的激活函数有（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "882": {
    "q": "LSTM中，（）的作用是确定哪些新的信息留在细胞状态中，并更新细胞状态",
    "t": "single",
    "a": "输入门"
  },
  "883": {
    "q": "RNN不同于其他神经网络的地方在于（）。",
    "t": "single",
    "a": "实现了记忆功能"
  },
  "884": {
    "q": "Sigmoid函数作为神经元激活函数的特点是（）。",
    "t": "single",
    "a": "连续且光滑"
  },
  "885": {
    "q": "标准BP算法的目标是使训练集上的（）最小。",
    "t": "single",
    "a": "累积误差"
  },
  "886": {
    "q": "从网络的原理上来看，结构最复杂的神经网络是（）。",
    "t": "single",
    "a": "长短时记忆神经网络"
  },
  "887": {
    "q": "下列关于神经网络的说法：①增加神经网络层数，可能会增加测试数据集的分类错误率；②减少神经网络层数，总是能减小测试数据集的分类错误率；③增加神经网络层数，总是能减小训练数据集的分类错误率。正确的是（）。",
    "t": "single",
    "a": "①"
  },
  "888": {
    "q": "对于一个分类任务，如果开始时神经网络的权重不是随机赋值的，而是都设成0，则下列叙述正确的是（）。",
    "t": "single",
    "a": "神经网络可以训练，但是所有的神经元最后都会变成识别同样的东西"
  },
  "889": {
    "q": "对于一个图像识别问题（在一张照片里找出一只猫），（）可以更好地解决这个问题。",
    "t": "single",
    "a": "卷积神经网络"
  },
  "890": {
    "q": "假设给定一个长度为n的不完整单词序列，希望预测下一个字母是什么，如输入是predictio（9个字母组成），希望预测第十个字母是什么。适用于解决这个工作的是（）。",
    "t": "single",
    "a": "循环神经网络"
  },
  "891": {
    "q": "构建一个神经网络，将前一层的输出和它自身作为输入，则有反馈连接的是（）。",
    "t": "single",
    "a": "循环神经网络"
  },
  "892": {
    "q": "下列关于神经网络结构的权重共享现象的描述正确的是（）。",
    "t": "single",
    "a": "卷积神经网络和循环神经网络都会出现"
  },
  "893": {
    "q": "下列关于循环神经网络设计的叙述错误的是（）。",
    "t": "single",
    "a": "循环神经网络不可应用于图像数据"
  },
  "894": {
    "q": "下列关于深度学习框架的描述正确的是（）",
    "t": "single",
    "a": "以上答案都正确"
  },
  "895": {
    "q": "下列关于长短时神经网络的叙述错误的是（）。",
    "t": "single",
    "a": "积累的时间尺度不可以因输入序列而改变"
  },
  "896": {
    "q": "机器学习和深度学习的关系是（）。",
    "t": "single",
    "a": "机器学习包含深度学习"
  },
  "897": {
    "q": "假设有5个大小为7x7、边界值为0的卷积核，同时卷积神经网络第一层的深度为1。此时如果向这一层传入一个维度为224x224x3的数据，那么神经网络下一层所接收到的数据维度是（）。",
    "t": "single",
    "a": "218x218x5"
  },
  "898": {
    "q": "假设在卷积神经网络的第一层中有5个卷积核，每个卷积核尺寸为7x7，具有零填充且步幅为1，该层的输入图片的维度是224x224x3，那么该层输岀的维度是（）。",
    "t": "single",
    "a": "218x218x5"
  },
  "899": {
    "q": "假设正在训练一个LSTM网络，有一个10000词的词汇表，并且使用一个激活值维度为100的LSTM块，在每一个时间步中，Γu的维度是（）。",
    "t": "single",
    "a": "100"
  },
  "900": {
    "q": "将一副图像进行分割后，分割出的区域彼此之间（）重叠。",
    "t": "single",
    "a": "不可以"
  },
  "901": {
    "q": "卷积的过程是让过滤器在图像上进行（）。",
    "t": "single",
    "a": "窗口滑动"
  },
  "902": {
    "q": "卷积神经网络（convolutionalneuralnetwork,CNN）是一种专门用来处理具有类似（）的数据的神经网络。",
    "t": "single",
    "a": "网格结构"
  },
  "903": {
    "q": "卷积神经网络中每层卷积层（convolutionallayer）由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法最佳化得到，其作用是（）。",
    "t": "single",
    "a": "特征提取"
  },
  "904": {
    "q": "下列关于深度学习的实质及其与浅层学习区别的说法正确的有（）。",
    "t": "muti",
    "a": "深度学习强调模型深度 | 深度学习突出特征学习的重要性:特征变换+非人工"
  },
  "905": {
    "q": "神经网络的拓扑结构可以分为（）和随机型网络等。",
    "t": "muti",
    "a": "前向型 | 反馈型 | 自组织竞争型"
  },
  "906": {
    "q": "神经网络模型（neural network ）因受人类大脑的启发而得名。神经网络由许多神经 元（neuron）组成，每个神经元接受一个输入，对输入进行处理后给出一个输出。下列关于神经元的描述正确的有（）。",
    "t": "muti",
    "a": "每个神经元有一个输入和一个输出 | 每个神经元有多个输入和一个输出 | 每个神经元有一个输入和多个输出 | 每个神经元有多个输入和多个输出"
  },
  "907": {
    "q": "与全连接的DNN, CNN的优势有（）。",
    "t": "muti",
    "a": "参数更少 | 泛化更好 | 训练更快"
  },
  "908": {
    "q": "LSTM应用场景有（ ）。",
    "t": "muti",
    "a": "翻译语言 | 语音识别 | 股票预测"
  },
  "909": {
    "q": "RNN在NLP领域的应用包括（）。",
    "t": "muti",
    "a": "语言模型与文本生成 | 机器翻译 | 语音识别 | 图像描述生成"
  },
  "910": {
    "q": "下列关于Dropout的说法正确的有（）",
    "t": "muti",
    "a": "Dropout背后的思想其实就是把DNN当作一个集成模型来训练，之后取所有值的平均值，而不只是训练单个DNN | DNN网络将Dropout率设置为p,也就是说一个神经元被保留的概率是1-po当 一个神经元被丢弃时，无论输入或者相关的参数是什么，它的输出值就会被设置为0 | 丢弃的神经元在训练阶段，对BP算法的前向和后向阶段都没有贡献。由于这个原因，每一次训练都像是在训练一个新的网络 | Dropout方法通常和L2正则化或其他参数约束技术（比如Max Norm）—起使用，来防止神经网络的过拟合"
  },
  "911": {
    "q": "下列关于卷积神经网络的叙述正确的有（）。",
    "t": "muti",
    "a": "可用于处理时间序列数据 | 可用于处理图像数据 | 至少在网络的一层中使用卷积"
  },
  "912": {
    "q": "下列关于梯度消失和梯度爆炸的说法正确的有（）。",
    "t": "muti",
    "a": "根据链式法则，如果每一层神经元对上一层的输出的偏导乘上权重结果都小于1的话，那么即使这个结果是0.99,在经过足够多层传播之后，误差对输入层的偏导会趋于0 | 可以采用ReLU激活函数有效地解决梯度消失的情况 | 根据链式法则，如果每一层神经元对上一层的输出的偏导乘上权重结果都大于1 的话，在经过足够多层传播之后，误差对输入层的偏导会趋于无穷大 | 可以通过减小初始权重矩阵的值来缓解梯度爆炸"
  },
  "913": {
    "q": "卷积神经网络为了保证图像对位移、缩放、扭曲的鲁棒性，可采取的措施有（）。",
    "t": "muti",
    "a": "局部感受野 | 共享权值 | 池采样"
  },
  "914": {
    "q": "卷积神经网络中常用的池化函数包括（）。",
    "t": "muti",
    "a": "最大池化函数 | L2范数 | 相邻矩形区域内的平均值 | 基于据中心像素距离的加权平均函数"
  },
  "915": {
    "q": "与相同步长的卷积层相比，使用池化层的优势不包含（）。",
    "t": "muti",
    "a": "可以获得更大下采样 | 速度更快 | 有助于提升精度"
  },
  "916": {
    "q": "网络的激活函数选用双曲正切而不是Sigmod的原因有（）。",
    "t": "muti",
    "a": "使用Sigmod函数容易出现梯度消失 | Sigmod的导数形式较为复杂"
  },
  "917": {
    "q": "下列关于RNN、LSTM、GRU的说法正确的有（  ）。",
    "t": "muti",
    "a": "RNN引入了循环的概念 | LSTM可以防止梯度消失或者爆炸 | GRU是LSTM的变体"
  },
  "918": {
    "q": "下列关于极大似然估计的说法正确的有（）。",
    "t": "muti",
    "a": "MLE可能并不存在 | 如果MLE存在，那么它的解可能不是唯一的"
  },
  "919": {
    "q": "下列可以用来构造神经网络的算法有()。",
    "t": "muti",
    "a": "线性回归 | 逻辑回归"
  },
  "920": {
    "q": "下列描述属于传统循环神经网络的性质有()。",
    "t": "muti",
    "a": "上一时刻的网络状态信息将会作用于下一时刻的网络状态 | 容易梯度爆炸/消失"
  },
  "921": {
    "q": "下列属于CNN关键层的有()。",
    "t": "muti",
    "a": "输入层 | 卷积层 | 激活层 | 池化层"
  },
  "922": {
    "q": "基于核的机器学习算法有()。",
    "t": "muti",
    "a": "径向基核函数 | 线性判别分析法 | 支持向量机"
  },
  "923": {
    "q": "循环神经网络的输出模式包含（）",
    "t": "muti",
    "a": "多输出 | 单输出 | 异步多输出"
  },
  "924": {
    "q": "循环神经网络主要被应用的场景有（）",
    "t": "muti",
    "a": "语音识别 | 语音建模 | 机器翻译"
  },
  "925": {
    "q": "训练CNN时,GPU显存溢出，此时可以采取的措施有（）。",
    "t": "muti",
    "a": "减少 mini_batch大小 | 移除一些卷积层 | 减少图片输入大小"
  },
  "926": {
    "q": "下列关于神经网络模型描述正确的有（）",
    "t": "muti",
    "a": "神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量 | 神经网络模型建立在多神经元之上 | 神经网络模型中,无中间层的神经元模型的计算可用来表示逻辑运算"
  },
  "927": {
    "q": "下列说法正确的有（）。",
    "t": "muti",
    "a": "负梯度方向是使函数值下降最快的方向 | 当目标函数是凸函数时，梯度下降法的解是全局最优解 | 牛顿法不需要计算Hesse矩阵"
  },
  "928": {
    "q": "常用来缓解BP网络的过拟合的两种策略是（）",
    "t": "muti",
    "a": "早停 | 正则化"
  },
  "929": {
    "q": "在选择高斯函数作为核函数的支持向量机中，参数的选取会影响拟合的结果，如果出现过拟合的现象，则可能导致该结果的原因有（）。",
    "t": "muti",
    "a": "其他参数保持不变，C过大 | 其他参数保持不变，σ较小"
  },
  "930": {
    "q": "长短时记忆神经网络三个门是（）。",
    "t": "muti",
    "a": "输出门 | 输入门 | 遗忘门"
  },
  "931": {
    "q": "递归神经网络不允许网络中岀现环形结构。（）",
    "t": "judge",
    "a": "错误"
  },
  "932": {
    "q": "多隐层神经网络可以直接用经典算法进行训练。（）",
    "t": "judge",
    "a": "错误"
  },
  "933": {
    "q": "减少神经网络层数，可能会降低测试集分类错误率。（）",
    "t": "judge",
    "a": "正确"
  },
  "934": {
    "q": "沿负梯度下降的方向一定是最优的方向。（）",
    "t": "judge",
    "a": "错误"
  },
  "935": {
    "q": "误差逆传播算法（BP）仅可用于多层前馈神经网络的学习算法。（）",
    "t": "judge",
    "a": "错误"
  },
  "936": {
    "q": "gated recurrent units的出现可以帮助防止RNN中的梯度消失问题。（）",
    "t": "judge",
    "a": "正确"
  },
  "937": {
    "q": "卷积神经网络可以对一个输入进行多种变换（旋转、平移、缩放）。（）",
    "t": "judge",
    "a": "错误"
  },
  "938": {
    "q": "增加卷积核的大小对于改进卷积神经网络的效果是必要的。()",
    "t": "judge",
    "a": "错误"
  },
  "939": {
    "q": "当在卷积神经网络中加入池化层(poolinglayer)时，变换的不变性会被保留。()",
    "t": "judge",
    "a": "正确"
  },
  "940": {
    "q": "下列关于分词的说法正确的是（）。",
    "t": "single",
    "a": "中文分词是将一系列无空格间隔字符串分割成一系列单词的过程"
  },
  "941": {
    "q": "下列关于关键词提取的说法错误的是（）。",
    "t": "single",
    "a": "文本中出现次数最多的词最能代表文本的主题"
  },
  "942": {
    "q": "下列关于文本分类的说法不正确的是（）。",
    "t": "single",
    "a": "文本的向量形式一般基于词袋模型构建，该模型考虑了文本词语的行文顺序"
  },
  "943": {
    "q": "下列模型中与文本分类相关的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "944": {
    "q": "下列特征选择算法中不属于常用的文本分类的是（）。",
    "t": "single",
    "a": "主成分分析"
  },
  "945": {
    "q": "下列方法中不属于情感分析评测的是（）。",
    "t": "single",
    "a": "Cifar10数据集评测"
  },
  "946": {
    "q": "下列方法中不属于图像分割方法的是（）。",
    "t": "single",
    "a": "特征提取法"
  },
  "947": {
    "q": "下列描述中不属于情感分析的具体任务是（）。",
    "t": "single",
    "a": "段落匹配"
  },
  "948": {
    "q": "下列项目中:①水平翻转(Horizontalflipping)；②随机裁剪(Randomcropping)；③随机放缩(Randomscaling)；④颜色抖动(Colorjittering)；⑤随机平移(Randomtranslation)；⑥随机剪切(Randomshearing)。在图像识别任务中使用的数据扩增技术(dataaugmentationtechnique)有()",
    "t": "single",
    "a": "所有项目"
  },
  "949": {
    "q": "下列去噪方法中能较好地保持图像边缘的是()。",
    "t": "single",
    "a": "中值滤波"
  },
  "950": {
    "q": "下列算法中属于图像平滑处理的是()",
    "t": "single",
    "a": "中值滤波"
  },
  "951": {
    "q": "下列图像边缘检测算子中抗噪性能最好的是()",
    "t": "single",
    "a": "Prewitt算子"
  },
  "952": {
    "q": "下列色彩空间中最接近人的视觉系统特征的是()。",
    "t": "single",
    "a": "HSI空间"
  },
  "953": {
    "q": "下列方法中属于映射数据到新的空间的是（）",
    "t": "single",
    "a": "傅里叶变换"
  },
  "954": {
    "q": "下列算法中属于局部处理的是（）。",
    "t": "single",
    "a": "中值滤波"
  },
  "955": {
    "q": "下列算法中属于图像锐化处理的是（）。",
    "t": "single",
    "a": "高通滤波"
  },
  "956": {
    "q": "协同过滤分析用户兴趣，在用户群中找到指定用户的相似（兴趣）用户，综合这些用户对某一信息的评价，形成系统对该指定用户对此信息的喜好程度（）,并将这些用户喜欢的项推荐给有相似兴趣的用户。",
    "t": "single",
    "a": "预测"
  },
  "957": {
    "q": "一幅512x512的图像，若灰度级数为16，则该图像大小为（）。",
    "t": "single",
    "a": "128kB"
  },
  "958": {
    "q": "一幅灰度均匀分布的图像，其灰度范围为［0,255］,则该图像的信息量为（）。",
    "t": "single",
    "a": "8"
  },
  "959": {
    "q": "一幅数字图像是（）。",
    "t": "single",
    "a": "一个2D数组中的元素"
  },
  "960": {
    "q": "一幅图像在采样时，行、列的采样点与量化级数（）。",
    "t": "single",
    "a": "既影响数字图像的质量，也影响该数字图像数据量的大小"
  },
  "961": {
    "q": "一篇文章中某些名词的TF-IDF值比较大，则说明（）。",
    "t": "single",
    "a": "这些名词对这篇文章的区分度比较高"
  },
  "962": {
    "q": "以P（w）表示词条w的概率，假设已知P（南京）=0.8，P（市长）=0.6,P（江大桥）=0.4；P（南京市）=0.3,P（长江大桥）=0.5。如果假设前后两个词的岀现是独立的，那么分词结果就是（）。",
    "t": "single",
    "a": "南京*市长*江大桥"
  },
  "963": {
    "q": "下列不属于基于区域的图像分割方法的是（）。",
    "t": "single",
    "a": "大津算法"
  },
  "964": {
    "q": "下列不属于基于图像灰度分布的阈值分割方法的是（）。",
    "t": "single",
    "a": "区域生长法"
  },
  "965": {
    "q": "下列不属于有监督的词义消歧方法的是（）。",
    "t": "single",
    "a": "基于词典的消歧"
  },
  "966": {
    "q": "下列处理方法能获得像素级标注的是（）。",
    "t": "single",
    "a": "语义分割<br>参考"
  },
  "967": {
    "q": "下列分割方法中不属于区域算法的是（）。",
    "t": "single",
    "a": "边缘检测"
  },
  "968": {
    "q": "下列关于关键点的检测描述正确的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "969": {
    "q": "下列关于情感分析的说法错误的是（）。",
    "t": "single",
    "a": "以上都不对"
  },
  "970": {
    "q": "81.下列关于图像的平滑处理的说法错误的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "971": {
    "q": "下列关于图像平滑的叙述错误的是（）。",
    "t": "single",
    "a": "图像的细节部分可以不保持原有特征"
  },
  "972": {
    "q": "下列关于图像识别任务的叙述错误的是（）。",
    "t": "single",
    "a": "图像的采集和传输方式对图像识别结果没有影响"
  },
  "973": {
    "q": "下列关于图像中的噪声特性的说法错误的是（）。",
    "t": "single",
    "a": "具有规律性"
  },
  "974": {
    "q": "下列可以应用关键词提取的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "975": {
    "q": "下列可以作为文本分类准则的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "976": {
    "q": "下列滤波器中对图像中的椒盐噪声滤波效果最好的是()。",
    "t": "single",
    "a": "中值滤波"
  },
  "977": {
    "q": "下列描述不属于图像分割内容的是()。",
    "t": "single",
    "a": "对未处理图像进行平滑"
  },
  "978": {
    "q": "下列方法不属于汉语分词方法的是()。",
    "t": "single",
    "a": "词向量匹配法"
  },
  "979": {
    "q": "下列内容符合物体识别任务的是()。",
    "t": "single",
    "a": "遵守误差最小准则和最佳近似准则"
  },
  "980": {
    "q": "下列模型属于考虑词语位置关系的是()。",
    "t": "single",
    "a": "词向量模型"
  },
  "981": {
    "q": "下列属于图像处理常用方法的是（）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "982": {
    "q": "下列算法中不属于基于深度学习的图像分割算法的是（）。",
    "t": "single",
    "a": "KNN"
  },
  "983": {
    "q": "下列现象不能直接通过低通滤波器解决的是（）。",
    "t": "single",
    "a": "指纹图像中的去污染问题"
  },
  "984": {
    "q": "由于不同类别的关键词对排序的贡献不同，检索算法一般把查询关键词分为几类,下列不属于此关键词类型的是（）。",
    "t": "single",
    "a": "高频词汇"
  },
  "985": {
    "q": "语音识别的应用场景包括（）。",
    "t": "single",
    "a": "以上都对"
  },
  "986": {
    "q": "在TF-IDF算法中，在计算完词频与逆文档频率后，将两者（）后得到最终的结果。",
    "t": "single",
    "a": "相乘"
  },
  "987": {
    "q": "在大规模的语料中，挖掘词的相关性是一个重要的问题。下列不能用于确定两个词的相关性的是（",
    "t": "single",
    "a": "最大炳"
  },
  "988": {
    "q": "在情感分析任务中，其目的是将无结构化的情感文本转化成计算机容易识别和处理的结构化文本，进而供情感分析上层的研究和应用服务的是（）。",
    "t": "single",
    "a": "情感信息抽取"
  },
  "989": {
    "q": "在情感分析中不属于影响词的是（）。",
    "t": "single",
    "a": "识别"
  },
  "990": {
    "q": "直方图均衡化适用于增强直方图呈（）分布的图像。",
    "t": "single",
    "a": "尖峰"
  },
  "991": {
    "q": "中文同义词替换时，常用到Word2veC，则下列说法错误的是（）。",
    "t": "single",
    "a": "Word2vec得到的都是语义上的同义词"
  },
  "992": {
    "q": "中心极限定理是噪声抑制的中的统计原理，其内容是均值分布总会收敛于一个（）。",
    "t": "single",
    "a": "正态分布"
  },
  "993": {
    "q": "自然语言理解是人工智能的重要应用领域，下列描述中不属于它要实现的目标的是（）。",
    "t": "single",
    "a": "欣赏音乐"
  },
  "994": {
    "q": "卷积神经网络能通过卷积以及池化等操作将不同种类的鸟归为一类，下列关于卷积神经网络能达到该效果的原因的描述不正确的是（）",
    "t": "single",
    "a": "池化作用能使不同种类鸟变得相似"
  },
  "995": {
    "q": "文档是待处理的数据对象，它由一组词组成，这些词在文档中不计顺序’如一篇论文、一个网页都可以看作一个文档。这样的表示方式称为（）。",
    "t": "single",
    "a": "词袋"
  },
  "996": {
    "q": "对文本数据处理通常采用（）核函数。",
    "t": "single",
    "a": "线性"
  },
  "997": {
    "q": "<br>（  ）是指通过训练而得到一种识别规则，通过此识别规则可以得到一种特征分类，使图像识别技术能够得到高识别率。",
    "t": "single",
    "a": "分类器设计"
  },
  "998": {
    "q": "jieba分词包含的分词模式是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "999": {
    "q": "pynlpir是一种常用的自然语言理解工具包，其中进行分词处理的函数是（ ）。",
    "t": "single",
    "a": "segment ( )"
  },
  "1000": {
    "q": "SLIC算法的主要目的是（）。",
    "t": "single",
    "a": "超像素提取"
  },
  "1001": {
    "q": "TF-IDF 中的 TF 是指（）。",
    "t": "single",
    "a": "某个词在文档中出现的次数/文章的总次数"
  },
  "1002": {
    "q": "把图像分割问题与图的最小割（mincut）问题相关联的方法是（）。",
    "t": "single",
    "a": "基于图论的分割方法"
  },
  "1003": {
    "q": "采用蓦次变换进行灰度变换时，当藉次大于1时，该变换是针对（）的图像进行增强。",
    "t": "single",
    "a": "图像整体偏亮"
  },
  "1004": {
    "q": "采用模板［-1 1］主要检测（）方向的边缘。",
    "t": "single",
    "a": "垂直"
  },
  "1005": {
    "q": "彩色图像增强时，（）处理可以采用RGB。",
    "t": "single",
    "a": "均值滤波"
  },
  "1006": {
    "q": "常见的图像预处理方法不包括（）。",
    "t": "single",
    "a": "图像标注"
  },
  "1007": {
    "q": "常用的灰度内插值法不包括（    ）。",
    "t": "single",
    "a": "三次样条插值法"
  },
  "1008": {
    "q": "常用的图像去噪方法包括（    ）。",
    "t": "single",
    "a": "以上答案都正确"
  },
  "1009": {
    "q": "传统目标检测流程包括（）。",
    "t": "single",
    "a": "以上都对"
  },
  "1010": {
    "q": "词袋模型、TF-IDF. Word2vec等模型都有的作用是（）。",
    "t": "single",
    "a": "文本特征向量化"
  },
  "1011": {
    "q": "词袋模型中的文本向量每个元素表示该词的（）。",
    "t": "single",
    "a": "频率"
  },
  "1012": {
    "q": "从连续图像到数字图像需要采取的措施是（ ）",
    "t": "single",
    "a": "采样和量化"
  },
  "1013": {
    "q": "当构建一个神经网络进行图片的语义分割时，通常采用的顺序是（）",
    "t": "single",
    "a": "先用卷积神经网络处理输入,再用反卷积神经网络得到输出"
  },
  "1014": {
    "q": "当图像通过信道传输时，噪声一般与（）无关。",
    "t": "single",
    "a": "出现的图像信号"
  },
  "1015": {
    "q": "对连续图像的离散化采样决定了图像的（）。",
    "t": "single",
    "a": "空间分辨率"
  },
  "1016": {
    "q": "对一幅100 x 100像素的图像，若像元用8bit表示灰度值，霍夫曼编码压缩后的图像数据量为40000bit,则图像压缩比例为（）。",
    "t": "single",
    "a": "2 : 1"
  },
  "1017": {
    "q": "多分类图像识别任务常采用（）作为输出的编码方式。",
    "t": "single",
    "a": "one-hot编码"
  },
  "1018": {
    "q": "二维图像可用二维函数表示，则下列说法正确的是（）。",
    "t": "single",
    "a": "二维函数值表示点的灰度值"
  },
  "1019": {
    "q": "二值图像中的分支点的连接数为（ ）。",
    "t": "single",
    "a": "3"
  },
  "1020": {
    "q": "傅里叶变换得到的频谱中， 低频系妏对应于（）。",
    "t": "single",
    "a": "变化平缓部分"
  },
  "1021": {
    "q": "高通滤波后的图像通常较暗,为改善这种情况，将高通滤波器的转移函数加上一常数量以便引入一些低频分量。这样滤波器叫（   ）。",
    "t": "single",
    "a": "高频提升滤波器"
  },
  "1022": {
    "q": "给定词汇表如下:｛Bob，ok, likes, football, car｝。则下面句子 Bob likes football 的词袋模型表示为（   ）。",
    "t": "single",
    "a": "[1 0 1 1 0]"
  },
  "1023": {
    "q": "构造了一个词表:｛1.小明2.喜欢3.踢4.看5.足球6.篮球7.电影｝，利用上述词表的索引号，文档｛小明喜欢踢足球｝可以用一个7维向量表示为（）。",
    "t": "single",
    "a": "[1 1 1 0 1 0 0]"
  },
  "1024": {
    "q": "下列关于情感分析的描述正确的是（ ）",
    "t": "single",
    "a": "情感分析的难点是语句太长导致精度降低"
  },
  "1025": {
    "q": "下列关于图像分割的说法正确的是（）。",
    "t": "single",
    "a": "以上都对"
  },
  "1026": {
    "q": "基于N-最短路径分词算法，其最后的粗分结果集合大小（）No",
    "t": "single",
    "a": "不小于"
  },
  "1027": {
    "q": "基于统计的分词方法为（   ）。",
    "t": "single",
    "a": "条件随机场"
  },
  "1028": {
    "q": "假设拥有一个已完成训练的、用来解决车辆检测问题的深度神经网络模型，训练所 用的数据集由汽车和卡车的照片构成，而训练目标是检测出每种车辆的名称（车辆共有10种类型）。现在想要使用这个模型来解决另外一个问题，问题数据集中 仅包含一种车（福特野马）而目标变为定位车辆在照片中的位置，则应采取的方法是（    ）。",
    "t": "single",
    "a": "对神经网络中的最后几层进行微调，同时将最后一层（分类层）更改为回归层"
  },
  "1029": {
    "q": "建立一个词典[Alex, wants, to, go, play, football, shopping],下面的句子:Alex<br>wants to go to play football 可以用向量表示为（  ）。",
    "t": "single",
    "a": "[1, 1, 2, 1, 1, 1, 0]"
  },
  "1030": {
    "q": "将两篇文本通过词袋模型变为向量模型，通过计算向量的（）来计算两个文本间的相似度。",
    "t": "single",
    "a": "余弦距离"
  },
  "1031": {
    "q": "（）能使图像亮度得到平缓渐变富减小突变梯度，改善图像质量。",
    "t": "single",
    "a": "图像平滑"
  },
  "1032": {
    "q": "情感信息抽取不包括（）。",
    "t": "single",
    "a": "基于重复段落的识别方法"
  },
  "1033": {
    "q": "情感信息归纳常见的存在形式是（）。",
    "t": "single",
    "a": "情感文摘"
  },
  "1034": {
    "q": "锐化（高通）滤波器的作用（）。",
    "t": "single",
    "a": "能消减或削弱傅里叶空间的低频分量，但不影响高频分量"
  },
  "1035": {
    "q": "视觉编码的前提是分析了解目标用户的（）,尽量降低目标用户的（ ）",
    "t": "single",
    "a": "视觉感知特征；感知障碍"
  },
  "1036": {
    "q": "图像的形态学处理方法包括（）",
    "t": "single",
    "a": "腐蚀"
  },
  "1037": {
    "q": "图像灰度方差说明了图像的（）属性。",
    "t": "single",
    "a": "图像对比度"
  },
  "1038": {
    "q": "图像平滑会造成（）。",
    "t": "single",
    "a": "图像边缘模糊化"
  },
  "1039": {
    "q": "图像与灰度直方图的对应关系为（）。",
    "t": "single",
    "a": "多对一"
  },
  "1040": {
    "q": "图像中虚假轮廓的岀现就其本质而言是（）",
    "t": "single",
    "a": "图像的灰度级数不够多而造成的"
  },
  "1041": {
    "q": "文本信息往往包含客观事实和主观情感，对于文本的情感分析主要是识别文章中的 主观类词语，其中（）不适用于情感分析。<br />\r\n<br />",
    "t": "single",
    "a": "表达客观事实的关键词"
  },
  "1042": {
    "q": "下列场景中最有可能应用人工智能的是___。",
    "t": "single",
    "a": "以上都对"
  },
  "1043": {
    "q": "下列关于TF-IDF的说法正确的是()。",
    "t": "single",
    "a": "该值与特征项在文档中出现的频率成正比"
  },
  "1044": {
    "q": "HIS表色系的三属性包含（）。",
    "t": "muti",
    "a": "色调 | 饱和度 | 亮度"
  },
  "1045": {
    "q": "Web内容挖掘实现技术包括（）。",
    "t": "muti",
    "a": "文本总结 | 文本分类 | 文本机器学习 | 关联规则"
  },
  "1046": {
    "q": "常见的图像分割算法有（）。",
    "t": "muti",
    "a": "基于区域的分割方法 | 基于边缘的分割方法 | 基于阈值的分割方法"
  },
  "1047": {
    "q": "常见的图像降噪方式包括（）。",
    "t": "muti",
    "a": "中值滤波 | 均值滤波 | 平均滤波 | 加权平均滤波"
  },
  "1048": {
    "q": "处理图像平滑的滤波有（）。",
    "t": "muti",
    "a": "盒式滤波 | 均值滤波 | 高斯滤波 | 中值滤波"
  },
  "1049": {
    "q": "对于不同场景内容，一般数字图像可以分为",
    "t": "muti",
    "a": "二值图像 | 灰度图像 | 彩色图像"
  },
  "1050": {
    "q": "空间域滤波是直接以图像中的像素操作为基础的滤波，空间滤波器有时也可称为（）。",
    "t": "muti",
    "a": "空间掩模 | 核 | 模板 | 窗口"
  },
  "1051": {
    "q": "下列关于TF-IDF模型的描述正确的有（）。",
    "t": "muti",
    "a": "TF是词频 | IDF是逆文本频率 | 该模型基于统计方法"
  },
  "1052": {
    "q": "图像处理中的去噪方法有（）。",
    "t": "muti",
    "a": "中值滤波 | 均值滤波"
  },
  "1053": {
    "q": "图像分割中常使用的邻域有（）。",
    "t": "muti",
    "a": "4邻域 | 8邻域"
  },
  "1054": {
    "q": "影响图像识别的精度的因素有（）。",
    "t": "muti",
    "a": "数据类别数量不平衡 | 图像中存在类标之外的环境干扰 | 图像中存在随机噪声"
  },
  "1055": {
    "q": "图像识别的一般步骤包括（）。",
    "t": "muti",
    "a": "预处理 | 特征提取 | 识别分类"
  },
  "1056": {
    "q": "图像数字化应该包括的过程有（）。",
    "t": "muti",
    "a": "采样 | 量化"
  },
  "1057": {
    "q": "图像压缩是建立在图像存在（）之上。",
    "t": "muti",
    "a": "编程冗余 | 像素间冗余 | 心理视觉冗余"
  },
  "1058": {
    "q": "文本分类过程包括（）。",
    "t": "muti",
    "a": "选择训练文本 | 选择文本特征 | 建立文本表示模型 | 选择分类方法"
  },
  "1059": {
    "q": "下列与人工智能场景相关的有（）。",
    "t": "muti",
    "a": "图像识别 | 人脸识别 | 语音识别 | 语义分析"
  },
  "1060": {
    "q": "下列关于词袋模型的说法正确的有（）。",
    "t": "muti",
    "a": "词袋模型可以忽略每个词出现的顺序 | TensorFlow支持词袋模型"
  },
  "1061": {
    "q": "下列关于情感分析的说法正确的有（）。",
    "t": "muti",
    "a": "简单而言，情感分析是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程 | 情感分析的发展得益于社交媒体的兴起 | 按照处理文本的粒度不同，情感分析大致可分为词语级、句子级、篇章级三个 | 情感分析可以应用于文本挖掘"
  },
  "1062": {
    "q": "下列关于自然语言处理中的关键词提取的说法正确的有（）。",
    "t": "muti",
    "a": "TF-IDF模型是关键词提取的经典方法 | 这个问题涉及数据挖掘、文本处理、信息检索等领域"
  },
  "1063": {
    "q": "TF-IDF的缺点包含（）。",
    "t": "muti",
    "a": "将一些生僻字误当作文档关键词 | 只考虑特征词和文本之间的关系，忽略了一个特征项在不同类别间的分布情况 | 没有考虑特征词的位置因素对文本的区分度"
  },
  "1064": {
    "q": "常用分词方法包含（）。",
    "t": "muti",
    "a": "基于HMM的分词方法 | 基于CRF的分词方法"
  },
  "1065": {
    "q": "下列方法属于词语情感分析的有（）。",
    "t": "muti",
    "a": "基于网络的分析方法 | 基于词典的分析"
  },
  "1066": {
    "q": "情感分析的途径有（）。",
    "t": "muti",
    "a": "关键词识别 | 词汇关联 | 统计方法 | 概念词技术"
  },
  "1067": {
    "q": "情感分析的应用场景有（）。",
    "t": "muti",
    "a": "数据挖掘 | 信息检索 | 市场营销"
  },
  "1068": {
    "q": "下列属于TF-IDF的应用有（）。",
    "t": "muti",
    "a": "搜索引擎 | 关键词提取 | 文本相似性"
  },
  "1069": {
    "q": "下列现象属于乘性噪声有（）.",
    "t": "muti",
    "a": "电视光栅的退化 | 胶片材料的退化"
  },
  "1070": {
    "q": "下列属于文本处理流程的有（）。",
    "t": "muti",
    "a": "normalization | tokenizationstopwords | part-of-speechtagging | namedentityrecognition"
  },
  "1071": {
    "q": "下列属于字符串匹配的分词方法的有（）。",
    "t": "muti",
    "a": "正向最大匹配法（由左到右的方向） | 逆向最大匹配法（由右到左的方向） | 最少切分法（使每一句中切出的词数最小） | 双向最大匹配法（进行由左到右、由右到左两次扫描）"
  },
  "1072": {
    "q": "下列属于可视化高维数据技术的有（）",
    "t": "muti",
    "a": "矩阵 | 平行坐标系 | 星形坐标系"
  },
  "1073": {
    "q": "下列属于词袋模型缺点的有（）。",
    "t": "muti",
    "a": "词汇表的词汇需要经过精心设计 | 具有稀疏性 | 丢失词序忽略了上下文"
  },
  "1074": {
    "q": "下列算法可用于图像分割的有（）。",
    "t": "muti",
    "a": "分水岭算法 | K-means | 区域生长"
  },
  "1075": {
    "q": "下列与图像处理相关的有（）。",
    "t": "muti",
    "a": "图像识别 | 人脸识别 | 视频分析"
  },
  "1076": {
    "q": "下列可用于处理由于光照不均带来的影响的图像处理方法有（）。",
    "t": "muti",
    "a": "同态滤波 | 顶帽变换 | 基于移动平均的局部阈值处理"
  },
  "1077": {
    "q": "下列属于汉语未登录词类型的有（）。",
    "t": "muti",
    "a": "新出现的普通词汇 | 专有名词 | 专业名词和研究领域名称"
  },
  "1078": {
    "q": "下列方法是TF-IDF的变种的有（）",
    "t": "muti",
    "a": "TFC | ITC"
  },
  "1079": {
    "q": "能在卷积窗口的边界上使卷积掩膜中心像素和它的4-邻接点的系数降至0附近的<br>滤波器有（）。",
    "t": "muti",
    "a": "高斯滤波 | 巴特沃斯滤波"
  },
  "1080": {
    "q": "下列属于关键词提取算法的有（）。",
    "t": "muti",
    "a": "TF-IDF算法 | TextRank算法 | LSA（潜在语义分析） | LDA"
  },
  "1081": {
    "q": "下列属于规则的分词方法的有（）。",
    "t": "muti",
    "a": "正向最大匹配法 | 逆向最大匹配法 | 双向最大匹配法"
  },
  "1082": {
    "q": "下列属于频率域图像滤波方法的有（）",
    "t": "muti",
    "a": "布特沃斯滤波 | 高斯滤波"
  },
  "1083": {
    "q": "下列属于图像分割的算法的有（）。",
    "t": "muti",
    "a": "阈值分割方法（thresholdsegmentationmethod） | 区域增长细分（regionalgrowthsegmentation） | 边缘检测分割方法（edgedetectionsegmentationmethod） | 基于聚类的分割（segmentationbasedonclustering） | 基于CNN中弱监督学习的分割"
  },
  "1084": {
    "q": "下列属于图像平滑算法的有（）。",
    "t": "muti",
    "a": "中值滤波 | 均值滤波 | 邻域平均法 | 高斯滤波"
  },
  "1085": {
    "q": "下列属于自然语言处理范畴的有（）。",
    "t": "muti",
    "a": "情感倾向分析 | 评论观点抽取 | 文章分类 | 新闻摘要抽取"
  },
  "1086": {
    "q": "下列算法可以应用于图像分割的有（）。",
    "t": "muti",
    "a": "[{\"A\":\"边缘检测技术\"},{\"B\":\"阈值分割技术\"},{\"C\":\"基于区域的分割技术D•区域生长方法\"}] | ！题错！选A,B,C,D"
  },
  "1087": {
    "q": "下列图像技术中属于图像处理技术的有（）。",
    "t": "muti",
    "a": "图像编码 | 图像增强"
  },
  "1088": {
    "q": "下列网络结构中可以应用于图像识别任务的有（）。",
    "t": "muti",
    "a": "LeNet-5 | AlexNet | CNN | VGG-net"
  },
  "1089": {
    "q": "语音识别的方法包括（）。",
    "t": "muti",
    "a": "声道模型方法 | 模板匹配的方法 | 利用人工神经网络的方法 | 语音知识的方法"
  },
  "1090": {
    "q": "在词袋模型中使用单个的单词来构建词向量这样的序列被称为（）。",
    "t": "muti",
    "a": "1元组（1-gram） | 单元组（unigram）模型"
  },
  "1091": {
    "q": "直方图修正法包括（）。",
    "t": "muti",
    "a": "直方图均衡 | 直方图规定化"
  },
  "1092": {
    "q": "最常见的分词算法可以分为（）。",
    "t": "muti",
    "a": "基于字符串匹配的分词方 | 基于理解的分词方法 | 基于统计的分词方法"
  },
  "1093": {
    "q": "图像分割方法主要可以分为()。",
    "t": "muti",
    "a": "基于阈值的分割方法 | 基于区域的分割方法 | 基于边缘的分割方法 | 基于特定理论的分割方法"
  },
  "1094": {
    "q": "图像噪声一般可分为（）。",
    "t": "muti",
    "a": "加性噪声 | 乘性噪声 | 量化噪声"
  },
  "1095": {
    "q": "下列属于小波去噪步骤的有()。",
    "t": "muti",
    "a": "对图像信号进行小波分解 | 对经过层次分解后的高频系数进行阈值量化 | 利用二维小波重构图像信号"
  },
  "1096": {
    "q": "wordembedding指的是把文本转换成计算机能处理的向量。（）",
    "t": "judge",
    "a": "正确"
  },
  "1097": {
    "q": "词袋模型最重要的是构造词表，然后通过文本为词表中的词赋值，但词袋模型严重缺乏相似词之间的表达。（）",
    "t": "judge",
    "a": "正确"
  },
  "1098": {
    "q": "对于文本分类来说，最重要的是如何将一句话映射到向量空间，同时保持其语义特征。",
    "t": "judge",
    "a": "正确"
  },
  "1099": {
    "q": "均值滤波存在不希望的边缘模糊负面效应。（）",
    "t": "judge",
    "a": "正确"
  },
  "1100": {
    "q": "情感分析任务其实是个分类任务，给模型输入一句话，让它判断这句话的情感是积极的、消极的，还是中性的。（）",
    "t": "judge",
    "a": "正确"
  },
  "1101": {
    "q": "情感分析这个任务还有一个升级版——细腻度的情感分析。细腻度的情感分析不仅能识别岀情感的好坏，而且能识别出是由于什么原因导致这种情感发生。（）",
    "t": "judge",
    "a": "正确"
  },
  "1102": {
    "q": "文本挖掘又称信息检索，是从大量文本数据中提取以前未知的、有用的、可理解的、可操作的知识的过程。（）",
    "t": "judge",
    "a": "错误"
  },
  "1103": {
    "q": "早期wordembedding使用的是bagofwords、TF-IDF等，没有考虑语序以及上下文关系。而近几年发展出来的Word2vector、Glove等考虑到了文本的上下文关系。（）",
    "t": "judge",
    "a": "正确"
  },
  "1104": {
    "q": "中值滤波是一种线性空间滤波器。（）",
    "t": "judge",
    "a": "错误"
  },
  "1105": {
    "q": "假设已经在ImageNet数据集（物体识别）上训练好了一个卷积神经网络，然后给这张卷积神经网络输入一张全白的图片，对于这个输入的输出结果为任何种类的物体的可能性都是一样的。（）\u0015",
    "t": "judge",
    "a": "错误"
  },
  "1106": {
    "q": "词w在文档d中的词频tf（termfrequency）的计算公式是 ___ 。",
    "t": "fill",
    "a": "tf{w&d)=count(w&d)/size(d)"
  },
  "1107": {
    "q": "词w在整个文档集合中的逆向文档频率idf（inversedocumentfrequency）的计算公式是 ___ 。",
    "t": "fill",
    "a": "idf=log[n/docs(w&d)]"
  },
  "1108": {
    "q": "对于一个文本，忽略其词法、语法、语义，仅将其看做是一个词的集合，文本中每个词的出现都是独立的，那么就得到了 ___ 。",
    "t": "fill",
    "a": "词袋模型"
  },
  "1109": {
    "q": "文本的向量化就是涉及___技术和___技术。",
    "t": "fill",
    "a": "词嵌入向量(wordembedding)|深度学习(deeplearning)"
  },
  "1110": {
    "q": "关键词提取的提取过程总共分两步，第一步是对文章分词、去停用词、postag之后，得到 ___ ;第二步是使用关键词提取算法提取关键词。",
    "t": "fill",
    "a": "候选关键词列表L"
  },
  "1111": {
    "q": "人工智能一文本处理中分词的两种方法是 ___ 。",
    "t": "fill",
    "a": "N-最短路径法、基于词的n元语法模型的分词方法"
  },
  "1112": {
    "q": "使用关键词提取算法提取关键词，提取的关键词应具有 ___ 三个特点。",
    "t": "fill",
    "a": "易于理解、关联性好、覆盖面广"
  },
  "1113": {
    "q": "图像噪声的种类有___、___。",
    "t": "fill",
    "a": "椒盐噪声(脉冲噪声)|高斯噪声<br>"
  },
  "1114": {
    "q": "（）适合连续特征，它假设每个特征对于每个类都符合正态分布。",
    "t": "single",
    "a": "GaussianNB"
  },
  "1115": {
    "q": "Scikit-Learn 中，（）可以更好帮助参数调优和选择模型。",
    "t": "single",
    "a": "交叉验证"
  },
  "1116": {
    "q": "Scikit-Learn 中，（）可以实现评估回归模型。",
    "t": "single",
    "a": "mean_squared_error"
  },
  "1117": {
    "q": "（）是Scikit-Learn中的支持向量机模块。",
    "t": "single",
    "a": "SVC"
  },
  "1118": {
    "q": "Gensim 库中，（）是指一组电子文档的集合，这个集合是Gensim的输入。",
    "t": "single",
    "a": "语料"
  },
  "1119": {
    "q": "Jieba的（）会把文本精确切分，不存在冗余单词。",
    "t": "single",
    "a": "精准模式"
  },
  "1120": {
    "q": "针对以下数组，从一个数组中移除存在于另一个数组中的项时可进行的操作是()。<br />\r\na=np.array([1,2,3,4,5])<br />\r\nb=np.array([5,6,7,8,9])<br />\r\n期望输出:array([1,2,3,4])",
    "t": "single",
    "a": "np.setdiffld(A.b)"
  },
  "1121": {
    "q": "使用Numpy读取CSV文件应使用的函数是()。",
    "t": "single",
    "a": "loadtxt()"
  },
  "1122": {
    "q": "random库的seed(a)函数的作用是()。",
    "t": "single",
    "a": "设置初始化随机数种子a"
  },
  "1123": {
    "q": "在Python中，导入random包后random.random()可能的运行结果为()",
    "t": "single",
    "a": "0.0965639318571762"
  },
  "1124": {
    "q": "random库中用于生成随机小数的函数是()",
    "t": "single",
    "a": "random()"
  },
  "1125": {
    "q": "下列关于random.uniform(a，b)作用的描述正确的是()",
    "t": "single",
    "a": "[{\"A\":\"生成一个均值为a、方差为b的正态分布\"},{\"B\":\"生成一个(a，b)之间的随机数\"},{\"C\":\"生成一个［a，b］之间的随机整数<br />\r\nD生成一个［a，b］之间的随机小数\"}] | ！题错！选D"
  },
  "1126": {
    "q": "Python中用于生成随机数的模块是random,则下列描述错误的是()。",
    "t": "single",
    "a": "random.choice(sequence):随机生成任意一个整数"
  },
  "1127": {
    "q": "在Python中可以通过调用random库来产生随机数。a=random.randint(1,99),并赋值给变量a、则下列描述正确的是()",
    "t": "single",
    "a": "随机产生一个1〜99的整数"
  },
  "1128": {
    "q": "下列程序执行后可以查看Python版本的是()。",
    "t": "single",
    "a": "importsys<br>print(sys.version)"
  },
  "1129": {
    "q": "假设函数中不包括global保留字，对于改变参数值的方法，下列描述错误的是()。",
    "t": "single",
    "a": "参数的值是否改变与函数中对变量的操作有关，与参数类型无关"
  },
  "1130": {
    "q": "()模块是Python标准库中最常用的模块之一。通过它可以获取命令行参数,从而实现从程序外部向程序内部传递参数的功能，也可以获取程序路径和当前系统平台等信息。",
    "t": "single",
    "a": "sys"
  },
  "1131": {
    "q": "os.path模块可以用来判断指定路径是否存在的函数是()。",
    "t": "single",
    "a": "exists()"
  },
  "1132": {
    "q": "下列关于Python中的os模块常见方法的描述错误的是()。",
    "t": "single",
    "a": "os.walk()读取所有的目录名"
  },
  "1133": {
    "q": "下列关于Python的sys模块常用方法的描述错误的是()",
    "t": "single",
    "a": "sys.modules.keys()返回所有字典中的keys"
  },
  "1134": {
    "q": "下列关于PythonNumpy.Scipy、Pandas这些库的区别的描述不正确的是()",
    "t": "single",
    "a": "三个模块分别独立"
  },
  "1135": {
    "q": "Scipy库中用于物理和数学常量计算的模块是（）。",
    "t": "single",
    "a": "scipy.constants"
  },
  "1136": {
    "q": "Scipy中模块integrate的作用是（）。",
    "t": "single",
    "a": "积分计算"
  },
  "1137": {
    "q": "Scipy中模块io的作用是（）。",
    "t": "single",
    "a": "程序输入输出"
  },
  "1138": {
    "q": "Scipy中模块signal的作用是（）。",
    "t": "single",
    "a": "信号处理"
  },
  "1139": {
    "q": "Scipy中，（）是空间数据结构和算法模块。",
    "t": "single",
    "a": "spatial"
  },
  "1140": {
    "q": "Scipy中模块stats的作用是（）。",
    "t": "single",
    "a": "统计"
  },
  "1141": {
    "q": "Scipy中包含对随机变量计算期望和方差等函数的模块是（）。",
    "t": "single",
    "a": "stats"
  },
  "1142": {
    "q": "scipy.stats模块中随机变量的概率密度函数是()",
    "t": "single",
    "a": "pdf"
  },
  "1143": {
    "q": "scipy.stats.cdf函数的作用是（）。",
    "t": "single",
    "a": "随机变量的累积分布函数"
  },
  "1144": {
    "q": "scipy.stats模块中累积分布的反函数是（）。",
    "t": "single",
    "a": "ppf"
  },
  "1145": {
    "q": "scipy.stats模块中随机变量的残存函数是（）。",
    "t": "single",
    "a": "sf"
  },
  "1146": {
    "q": "scipy.stats.isf()函数的作用是（）。",
    "t": "single",
    "a": "scipy.stats.sf()的逆"
  },
  "1147": {
    "q": "282.scipy.stats.moment()函数的作用是()。",
    "t": "single",
    "a": "计算分布的非中心矩"
  },
  "1148": {
    "q": "scipy.stats模块中对随机变量进行随机取值的函数是（）",
    "t": "single",
    "a": "rvs"
  },
  "1149": {
    "q": "scipy.stats.fit（）函数的作用是（）。",
    "t": "single",
    "a": "对数据进行拟合，找出最适合采样数据的概率密度函数系数"
  },
  "1150": {
    "q": "Scipy的stats包中提供了产生连续性分布的函数，其中用于均匀分布的函数是（）。",
    "t": "single",
    "a": "uniform"
  },
  "1151": {
    "q": "Scipy包中（）用于数值积分例程和微分方程求解。",
    "t": "single",
    "a": "integrate"
  },
  "1152": {
    "q": "scipy.stats,()表示泊松分布。",
    "t": "single",
    "a": "poisson"
  },
  "1153": {
    "q": "scipy.stats 中,（）表示二项分布。",
    "t": "single",
    "a": "binom"
  },
  "1154": {
    "q": "Scipy库不包含（)功能。",
    "t": "single",
    "a": "提供机器学习等算法"
  },
  "1155": {
    "q": "scipy.integrate模块的主要作用是()",
    "t": "single",
    "a": "可以求多重积分、高斯积分，解常微分方程"
  },
  "1156": {
    "q": "Scipy中，线性模块是()模块。",
    "t": "single",
    "a": "linalg"
  },
  "1157": {
    "q": "scipy.io模块不可以读取()。",
    "t": "single",
    "a": "CSV文件"
  },
  "1158": {
    "q": "()不是Scipy库中的模块。",
    "t": "single",
    "a": "random"
  },
  "1159": {
    "q": "Scipy中的图像处理模块是()。",
    "t": "single",
    "a": "ndimage"
  },
  "1160": {
    "q": "Scipy通常与（）同时使用。",
    "t": "single",
    "a": "Numpy"
  },
  "1161": {
    "q": "Scipy中计算偏度的函数是()。",
    "t": "single",
    "a": "scipy.stats.skewtest()"
  },
  "1162": {
    "q": "在Scipy中，想要生成20个服从正态分布的随机数使用函数（）。",
    "t": "single",
    "a": "stats.norm.rvs ( size=20 )"
  },
  "1163": {
    "q": "在Scipy中，生成二项式离散随机变量使用函数()。",
    "t": "single",
    "a": "stats.binom()"
  },
  "1164": {
    "q": "scipy.stats.describe()函数的作用是()。",
    "t": "single",
    "a": "计算所传递数组的几个描述性统计信息"
  },
  "1165": {
    "q": "()不是scipy.stats模块中的功能。",
    "t": "single",
    "a": "线性方程求解"
  },
  "1166": {
    "q": "scipy.stats()函数不能求()。",
    "t": "single",
    "a": "众数"
  },
  "1167": {
    "q": "若X的值为1~11(包含1、11),能用Scipy输岀标准正态分布的概率密度函数在若5处的值的是()。",
    "t": "single",
    "a": "scipy.stats.nomi(loc=0,scale=1).pdf(5)"
  },
  "1168": {
    "q": "df.tail()这个函数是用来()。",
    "t": "single",
    "a": "用来展现数据"
  },
  "1169": {
    "q": "下列关于Pandas数据读写的说法错误的是()",
    "t": "single",
    "a": "read_csv()函数能够读取数据库的数据"
  },
  "1170": {
    "q": "下列关于Pandas中groupby方法的说法正确的是()。",
    "t": "single",
    "a": "groupby是Pandas提供的一个用来分组的方法"
  },
  "1171": {
    "q": "在Pandas中，使用pivotjable()函数制作透视表时，用()设置行分组键。",
    "t": "single",
    "a": "index"
  },
  "1172": {
    "q": "在Pandas中，使用其本身可以达成数据透视功能的函数是()",
    "t": "single",
    "a": "pivot_table()"
  },
  "1173": {
    "q": "在Pandas中，描述统计信息的是()",
    "t": "single",
    "a": "describe()"
  },
  "1174": {
    "q": "在Pandas中，()可以统计Series每个唯一值出现的次数。",
    "t": "single",
    "a": "value_counts ()"
  },
  "1175": {
    "q": "Python中statsmodels库适用于()场景。",
    "t": "single",
    "a": "统计分析"
  },
  "1176": {
    "q": "Python中statsmodel库和()库关系密切。",
    "t": "single",
    "a": "Pandas"
  },
  "1177": {
    "q": "（）不属于statsmodels模块的主要特点。",
    "t": "single",
    "a": "插值运算"
  },
  "1178": {
    "q": "plt.plot()函数的功能是()。",
    "t": "single",
    "a": "展现变量的趋势变化"
  },
  "1179": {
    "q": "pit.scatter()函数中的参数c表示的含义是()。",
    "t": "single",
    "a": "散点图中的标记颜色"
  },
  "1180": {
    "q": "当我们需要在一张图表中加上文字标注达到提醒读者的目的时，需要用到()函数。",
    "t": "single",
    "a": "plt.text()"
  },
  "1181": {
    "q": "在pit中通常的lw参数代表的是()",
    "t": "single",
    "a": "线条的宽度"
  },
  "1182": {
    "q": "当我们需要在一张图表中特意指出某个特殊点，并加上标注达到醒目的目的时，需要用到()函数。",
    "t": "single",
    "a": "plt.annotate()"
  },
  "1183": {
    "q": "Matplotlib中的barh()函数可以绘制()",
    "t": "single",
    "a": "条形图"
  },
  "1184": {
    "q": "在Matplotlib中，调用直方图的函数是()。",
    "t": "single",
    "a": "hist()"
  },
  "1185": {
    "q": "在Matplotlib中，调用柱状图的函数是()。",
    "t": "single",
    "a": "bar()"
  },
  "1186": {
    "q": "在Matplotlib中调整后可以显示中文的参数是()。",
    "t": "single",
    "a": "font.sans-serif"
  },
  "1187": {
    "q": "在Matplotlib中可以绘制散点图的代码是()。",
    "t": "single",
    "a": "pit.scatter(x,y)"
  },
  "1188": {
    "q": "下列关于在Matplotlib的说法正确的是()",
    "t": "single",
    "a": "折线图可以用作查看特征间的趋势关系"
  },
  "1189": {
    "q": "下列字符串中表示plot线条颜色、点的形状和类型为红色五角星点短虚线的<br>是()。",
    "t": "single",
    "a": "'r*-.'"
  },
  "1190": {
    "q": "下列关于Matplotlib中绘图标准流程的说法错误的是()。",
    "t": "single",
    "a": "添加图例可以在绘制图形之前"
  },
  "1191": {
    "q": "Matplotlib中的axvspan()函数作用是()。",
    "t": "single",
    "a": "绘制垂直于x的参考区域"
  },
  "1192": {
    "q": "Matplotlib中的legend()函数的作用是()。",
    "t": "single",
    "a": "标示不同图形的文本标签图例"
  },
  "1193": {
    "q": "Matplotlib中的step()函数绘制的是()。",
    "t": "single",
    "a": "阶梯图"
  },
  "1194": {
    "q": "Matplotlib中调用堆积折线图的函数是()。",
    "t": "single",
    "a": "stackplot()"
  },
  "1195": {
    "q": "Matplotlib中设置x轴数值显示范围的函数是()。",
    "t": "single",
    "a": "xlim()"
  },
  "1196": {
    "q": "Python代码中mpl.rcParams['font.sans-serif]=['SimHei']的作用是()。",
    "t": "single",
    "a": "设置图表中文显示的字体"
  },
  "1197": {
    "q": "Matplotlib的主要功能是()。",
    "t": "single",
    "a": "绘图库"
  },
  "1198": {
    "q": "Matplotlib的核心是面向()。",
    "t": "single",
    "a": "对象"
  },
  "1199": {
    "q": "在Matplotlib中，创建一个新图可以用函数()。",
    "t": "single",
    "a": "figure()"
  },
  "1200": {
    "q": "在Matplotlib中设置x轴、y轴的刻度位置可用函数()。",
    "t": "single",
    "a": "xticks()、yticks()"
  },
  "1201": {
    "q": "在Matplotlib中，plt.title()函数的作用是()。",
    "t": "single",
    "a": "为图设置标题"
  },
  "1202": {
    "q": "在Matplotlib中，在当前图形上添加一个子图需要用到的函数是()。",
    "t": "single",
    "a": "plt.subplot()"
  },
  "1203": {
    "q": "在Matplotlib中，imread()函数读取到图像后是以()类型进行存储。",
    "t": "single",
    "a": "数组"
  },
  "1204": {
    "q": "plt.plot()函数输入参数b修改的是图形的()。",
    "t": "single",
    "a": "颜色"
  },
  "1205": {
    "q": "plt.show()函数的作用是()。",
    "t": "single",
    "a": "展示图像"
  },
  "1206": {
    "q": "pyplot.pie()函数所画的图像是()。",
    "t": "single",
    "a": "饼图"
  },
  "1207": {
    "q": "使用pyplot.plot画图时，x、y的参数的值的数据类型是()。",
    "t": "single",
    "a": "array"
  },
  "1208": {
    "q": "343.在使用pyplot画图时，线条相关属性标记不能设置()",
    "t": "single",
    "a": "‘T’"
  },
  "1209": {
    "q": "绘图通过()函数为项目设置matplotlib参数。",
    "t": "single",
    "a": "rc()"
  },
  "1210": {
    "q": "345.Skleam库中对数据进行预处理和规范化主要依靠()模块。",
    "t": "single",
    "a": "preprocessing模块"
  },
  "1211": {
    "q": "生成多项式和交互特征使用preprocessing模块中的()函数。",
    "t": "single",
    "a": "preprocessing.PolynomialFeatures()"
  },
  "1212": {
    "q": "Scikit-Learn中，（）可以实现整数分类值转化为独热向量。",
    "t": "single",
    "a": "OneHotEncoder"
  },
  "1213": {
    "q": "对矩阵[[0,0,3],[1,1,0],[0,2,1],[1,0,2]]进行独热编码训练后，对矩阵[[0,1,3]]进行独热编码输出结果为()",
    "t": "single",
    "a": "[1,0,0,1,0,0,0,0,1]"
  },
  "1214": {
    "q": "Scikit-Leam中StandardScaler是将特征数据的分布调整成(),也就是使得数据的均值为0,方差为1。",
    "t": "single",
    "a": "正态分布"
  },
  "1215": {
    "q": "对于一组数据，将每个要素缩放到［-1，1］范围，而不会破坏稀疏性应该采取的函数()。",
    "t": "single",
    "a": "使用preprocessing.maxabs_scale()"
  },
  "1216": {
    "q": "正则化是将样本在向量空间模型上的一个转换，经常被使用在分类与聚类中，正<br>则化在preprocessing模块的实现函数是()。",
    "t": "single",
    "a": "preprocessing.normalize()"
  },
  "1217": {
    "q": "要弥补缺失值，可以使用均值、中位数、众数等，preprocessing模块中()函数可以实现。",
    "t": "single",
    "a": "preprocessing.Imputer()"
  },
  "1218": {
    "q": "如果数据有许多异常值，那么便不能使用数据的均值与方差去做标准化，在preprocessing模块中定义()可以解决这个问题。",
    "t": "single",
    "a": "robust_scale()"
  },
  "1219": {
    "q": "Skleam中对模型进行选择主要是依靠()模块。",
    "t": "single",
    "a": "model__selection"
  },
  "1220": {
    "q": "K折交叉验证器是()函数。",
    "t": "single",
    "a": "model_selection.KFold()"
  },
  "1221": {
    "q": "对模型进行交叉验证可以使用()方法。",
    "t": "single",
    "a": "cross_val_score()"
  },
  "1222": {
    "q": "对模型进行超参数优化，详尽搜索指定参数的估计值使用()函数。",
    "t": "single",
    "a": "GridSearchCV()"
  },
  "1223": {
    "q": "线性回归算法主要在Skleam中的()模块中。",
    "t": "single",
    "a": "linear_model"
  },
  "1224": {
    "q": "逻辑回归的实现采用的方法是（）。",
    "t": "single",
    "a": "LogisticRegression()"
  },
  "1225": {
    "q": "随机森林等树状算法通过()模块进行调用。",
    "t": "single",
    "a": "ensemble"
  },
  "1226": {
    "q": "skleam.decomposition.PCA()的作用是()。",
    "t": "single",
    "a": "数据降维"
  },
  "1227": {
    "q": "()模块提供了用于加载和获取流行的参考数据集的方法。",
    "t": "single",
    "a": "skleam.datasets"
  },
  "1228": {
    "q": "skleam.cluster模块实现的功能是().",
    "t": "single",
    "a": "聚类"
  },
  "1229": {
    "q": "模型构建完毕需要对模型进行评估量化，需要用到的模块是（）。",
    "t": "single",
    "a": "metrics"
  },
  "1230": {
    "q": "sklearn.naive__bayes模块实现了朴素贝叶斯算法，基于贝叶斯定理和特征独立性假设的监督学习方法，下列模型不是朴素贝叶斯分类器的是（）。",
    "t": "single",
    "a": "NeighborsNB（）"
  },
  "1231": {
    "q": "scikit-learn中的K-means类，用来调节k值的参数是（）.",
    "t": "single",
    "a": "n_clusters"
  },
  "1232": {
    "q": "下列算法中sklearn中未提及的是（）。",
    "t": "single",
    "a": "Apriori关联规则算法"
  },
  "1233": {
    "q": "ordinalencoder将属性转化为（）。",
    "t": "single",
    "a": "附带特性的数字"
  },
  "1234": {
    "q": "实现One-Hot编码可以用Pandas中()函数。",
    "t": "single",
    "a": "get_dummies()"
  },
  "1235": {
    "q": "下列关于train_test__split()函数的说法正确的是().",
    "t": "single",
    "a": "train_test_split()函数可以自行决定训练集和测试集的占比"
  },
  "1236": {
    "q": "下列不属于scik.it-le",
    "t": "single",
    "a": "MeanScaler"
  },
  "1237": {
    "q": "用OneHot对某个只有一个属性的样本进行编码,则编码结果可能是()",
    "t": "single",
    "a": "1000"
  },
  "1238": {
    "q": "Scikit-Learn中，()可以实现计算模型准确率。",
    "t": "single",
    "a": "accuracy_score"
  },
  "1239": {
    "q": "在Python中，调用open （    ）时需要将内容附加到文件末尾，而不是覆盖文件原来内容，则第二个实参应该使用（  ）。",
    "t": "single",
    "a": "'a'"
  },
  "1240": {
    "q": "在Python文件操作中，使用关键字(   )可以在文件访问后自动将其关闭。",
    "t": "single",
    "a": "with"
  },
  "1241": {
    "q": "下列不是Python对文件的打开模式的是(   )。",
    "t": "single",
    "a": "'c'"
  },
  "1242": {
    "q": "执行下面程序，打开文件的位置应该在(   )。<br>f=open ('itheima.txt', 'w')",
    "t": "single",
    "a": "与源文件在相同的目录下"
  },
  "1243": {
    "q": "下列用于关闭文件的是(   )。",
    "t": "single",
    "a": "close（ ）"
  },
  "1244": {
    "q": "下列函数用于向文件中写内容的是(   )。",
    "t": "single",
    "a": "write（ ）"
  },
  "1245": {
    "q": "如果只写open (filename ),那就是用()模式打开。",
    "t": "single",
    "a": "r"
  },
  "1246": {
    "q": "如果要清空文件，需要使用的命令是()。",
    "t": "single",
    "a": "truncate ( 0 )"
  },
  "1247": {
    "q": "如果要将读写位置移动到文件开头，需要使用的命令是()。",
    "t": "single",
    "a": "seek ( 0 )"
  },
  "1248": {
    "q": "下列关于两次调用文件的write方法的描述正确的是( )。",
    "t": "single",
    "a": "连续写入的数据之间无分隔符"
  },
  "1249": {
    "q": "假设文件不存在，如果使用open (  )打开文件会报错，那么该文件的打开方式是（  ）。",
    "t": "single",
    "a": "'r'"
  },
  "1250": {
    "q": "下列关于文件的打开方式的描述正确的是（ ）",
    "t": "single",
    "a": "所有文件都可能以二进制方式打开"
  },
  "1251": {
    "q": "下列关于数据的存储结构的描述正确的是（ ）。",
    "t": "single",
    "a": "数据的逻辑结构在计算机中的表示"
  },
  "1252": {
    "q": "下列关于二维数据CSV存储问题的描述错误的是（）。",
    "t": "single",
    "a": "CSV文件不能包含二维数据的表头信息"
  },
  "1253": {
    "q": "下列关于Python文件处理的描述错误的是（）",
    "t": "single",
    "a": "Python不可以处理PDF文件"
  },
  "1254": {
    "q": "txt=open ( filename )返回的是( )。",
    "t": "single",
    "a": "文件对象"
  },
  "1255": {
    "q": "下列关于Python语句:f=open (    )中f的描述错误的是( )。",
    "t": "single",
    "a": "表达式print ( f )执行将报错"
  },
  "1256": {
    "q": "open (   )函数中，参数'wb'的含义是()。",
    "t": "single",
    "a": "创建并二进制写入"
  },
  "1257": {
    "q": "在页面中看不见的表单元素是(   )。",
    "t": "single",
    "a": "&lt;input type=\"hidden\"&gt;&lt;/input&gt;"
  },
  "1258": {
    "q": "通过代理服务器进行爬虫的方法是()。",
    "t": "single",
    "a": "个人发送访问请求到代理服务器，代理服务器转发到网站，网站反馈给代理服 务器，代理服务器再发送给个人"
  },
  "1259": {
    "q": "连续不断地爬取网页信息，较容易被网站识别，想要实现间隔15s来爬取网页需要使用的指令是()。",
    "t": "single",
    "a": "timesleep ( 15 )"
  },
  "1260": {
    "q": "HTML的表格中，如果需要定义表格的单元格内文字和边缘的空间，需要通过()<br>来实现。",
    "t": "single",
    "a": "cellpadding 属性"
  },
  "1261": {
    "q": "下列关于Python模块的理解错误的是(  )。",
    "t": "single",
    "a": "不可以使用操作符访问模块中的函数和变量"
  },
  "1262": {
    "q": "下列不属于Python内置模块的是(  )。",
    "t": "single",
    "a": "image"
  },
  "1263": {
    "q": "下列关于模块的描述不正确的是（    ）。",
    "t": "single",
    "a": "模块使得代码更复杂，可读性变差"
  },
  "1264": {
    "q": "下列关于模块的定义与导入方法的说法错误的是（   ）。",
    "t": "single",
    "a": "from * import modname"
  },
  "1265": {
    "q": "下列关于模块的说法不正确的是（  ）。",
    "t": "single",
    "a": "模块不能定义类"
  },
  "1266": {
    "q": "下列关于_name_的说法错误的是（ ）。",
    "t": "single",
    "a": "它是Python提供的一个方法"
  },
  "1267": {
    "q": "导入模块的方式错误的是（     ）。",
    "t": "single",
    "a": "import m from mo"
  },
  "1268": {
    "q": "下列关于模块的说法错误的是(    )。",
    "t": "single",
    "a": "模块文件的扩展名不一定是.py"
  },
  "1269": {
    "q": "正确导入日期模块的语句是（    ）。",
    "t": "single",
    "a": "import datetime"
  },
  "1270": {
    "q": "time库的time.time (    )函数的作用是（    ）。",
    "t": "single",
    "a": "返回系统当前时间戳"
  },
  "1271": {
    "q": "下列关于常用模块功能的描述错误的是（     ）。",
    "t": "single",
    "a": "datetime: datetime对象没有可将日期对象格式化为可读字符串的方法"
  },
  "1272": {
    "q": "time 库的 time.mktime(t)函数的作用是(  )。",
    "t": "single",
    "a": "将struct_time对象变量t转换为时间戳"
  },
  "1273": {
    "q": "运行下面代码，则下列描述错误的是（    ）。<br>import time<br>print (time.time)",
    "t": "single",
    "a": "time.sleep ( 5 )推迟调用线程的运行，单位为毫秒"
  },
  "1274": {
    "q": "Numpy库的主要功能是()。",
    "t": "single",
    "a": "科学计算"
  },
  "1275": {
    "q": "下列关于Numpy的简单介绍不正确的是(  )。",
    "t": "single",
    "a": "Numpy不开放源代码"
  },
  "1276": {
    "q": "Numpy.array数组的简称是(   )。",
    "t": "single",
    "a": "Ndarray"
  },
  "1277": {
    "q": "Ndarray是一个通用的（      ）数据容器。",
    "t": "single",
    "a": "多维同类"
  },
  "1278": {
    "q": "数组允许批量计算而无须任何for循环，这种特性叫(    )。",
    "t": "single",
    "a": "矢量化"
  },
  "1279": {
    "q": "下列关于Numpy的数组Ndarray对象属性的描述错误的是()。",
    "t": "single",
    "a": "Ndarray.itemsize Ndarray 对象的元素类型"
  },
  "1280": {
    "q": "下列关于Numpy的数组Ndarray对象属性的描述错误的是(     )。",
    "t": "single",
    "a": "Ndarray.dtype Ndarray对象中每个元素的大小以字节为单位"
  },
  "1281": {
    "q": "下列关于Numpy中秩（rank）的说法正确的是（   ）。",
    "t": "single",
    "a": "在Numpy数组中，维数称为秩（rank），一维数组的秩为1,二维数组的秩为2，以此类推"
  },
  "1282": {
    "q": "下列关于NdaiTay.itemsize的描述错误的是（     ）。",
    "t": "single",
    "a": "一个元素类型为complex64的数组，itemsize属性为4"
  },
  "1283": {
    "q": "运行下面代码，输出结果是（     ）。<br>import numpy as np<br>n = np.array （[[1, 2, 3], [4, 5, 6]]）<br>print （n.size）",
    "t": "single",
    "a": "6"
  },
  "1284": {
    "q": "Numpy默认产生的数据类型是（   ）。",
    "t": "single",
    "a": "float64"
  },
  "1285": {
    "q": "有数组 arr= Numpy.array （[1, 2, 3, 4]）,执行 arr.dtype 后输出结果为（     ）。",
    "t": "single",
    "a": "int32"
  },
  "1286": {
    "q": "下列数据类型中Numpy不支持的是( )。",
    "t": "single",
    "a": "byte"
  },
  "1287": {
    "q": "Numpy中使用不同类型的数组进行操作时，结果数组的类型会进行(    )。",
    "t": "single",
    "a": "向上转换"
  },
  "1288": {
    "q": "Numpy中结构化数组不能使用( )数据类型创建。",
    "t": "single",
    "a": "整数"
  },
  "1289": {
    "q": "下列方法不能成功创建一个Numpy数组的是（     ）。",
    "t": "single",
    "a": "c= np.ones ( 1, 2, 3, 4 )"
  },
  "1290": {
    "q": "Numpy中，利用函数自动创建数组不包括的函数是( )。",
    "t": "single",
    "a": "dtype (    )"
  },
  "1291": {
    "q": "np.eye (2)函数的作用是（    ）。",
    "t": "single",
    "a": "输出一个二维单位矩阵"
  },
  "1292": {
    "q": "np.diag (   )函数的作用是（     ）。",
    "t": "single",
    "a": "根据一个向量创建斜对角线方阵"
  },
  "1293": {
    "q": "下列关于Numpy.arange参数的描述错误的是(   )。",
    "t": "single",
    "a": "step:步长，默认为-1"
  },
  "1294": {
    "q": "np.linspace (0, 3, 3)的运行结果是（    ）。",
    "t": "single",
    "a": "[0, 1.5, 3]"
  },
  "1295": {
    "q": "下面程序的运行结果是（    ）。<br>import numpy as np<br>a= np.logspace (0, 9, 10,base=2)<br>print (a)",
    "t": "single",
    "a": "[1.2.4.8.16.32.64.128.256.512.]"
  },
  "1296": {
    "q": "Numpy中确定随机数生成种子使用的函数是（      ）。",
    "t": "single",
    "a": "np.random.seed (    )"
  },
  "1297": {
    "q": "语句 np.random.randn (5, 4 )的运算结果是（     ）。",
    "t": "single",
    "a": "生成一个5行4列的随机矩阵"
  },
  "1298": {
    "q": "可以使数组计算沿指定轴进行应用操作的参数是（      ）。",
    "t": "single",
    "a": "axis"
  },
  "1299": {
    "q": "a= np.arange ( 24 ) .reshape(2, 3, 4 )的输出结果是( )数据。",
    "t": "single",
    "a": "三维"
  },
  "1300": {
    "q": "对a= np.array ([[1,2, 3], [4, 5, 6]]),下列操作会改变数组本身形状的是（     ）。",
    "t": "single",
    "a": "a.resize (    )"
  },
  "1301": {
    "q": "有数组n= np.arange ( 24) .reshape (2, -1,2, 2 ),则 np.shape 的返回结果是(  )。",
    "t": "single",
    "a": "(2, 3, 2, 2)"
  },
  "1302": {
    "q": "已知 data = np.array ( [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]),则data 的形状(shape )为（     ）。",
    "t": "single",
    "a": "(2, 2, 3 )"
  },
  "1303": {
    "q": "a=np.arange ( 10 ), a[2: 4]截取到的数组为(   )。",
    "t": "single",
    "a": "[2, 3]"
  },
  "1304": {
    "q": "arrl = np.arange ( 0, 20, 1 ), arr2 = arrl.reshape (4, 5 ),则arr2[l :3，1]的输出结果为（     ）。",
    "t": "single",
    "a": "[6，11]"
  },
  "1305": {
    "q": "若arrl = np.array( [[1, 2,3]，[4, 5, 6]，[7, 8, 9] ] )，则arr[:2，1:]的输出为（      ）。",
    "t": "single",
    "a": "([[2, 3], [5, 6]])"
  },
  "1306": {
    "q": "对于一个二维数组 n = np. array ([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),n[[0，1], [0，1]]，输出的结果是（       ）。",
    "t": "single",
    "a": "[1, 5]"
  },
  "1307": {
    "q": "arr=np.arange ( 9 ) .reshape ( 3, 3 ),使数组 arr 交换列 1 和列 2 的操作是（     ）。",
    "t": "single",
    "a": "arr[:, [1, 0, 2]]"
  },
  "1308": {
    "q": "运行下面程序的输出的结果是(    )。<br>x=np.arange ( 32 ) .reshape ( 8, 4 )<br>print (x[[-4, -2, -1, -7]])",
    "t": "single",
    "a": "[[16171819][24252627][28293031][4567]]"
  },
  "1309": {
    "q": "对arr= np.arange ( 9 ) .reshape (3, 3 ),反转二维数组arr的行进行的操作是 (    )。",
    "t": "single",
    "a": "arr[:: -1]"
  },
  "1310": {
    "q": "下列程序满足期望输出的是(    )。<br>arr= np.array ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])<br>期望输出:array ([1, 3, 5, 7, 9])",
    "t": "single",
    "a": "arr[arr%2==l]"
  },
  "1311": {
    "q": "下列数据类型中不可以作为索引对Numpy数组进行选取的是(  )。",
    "t": "single",
    "a": "diet"
  },
  "1312": {
    "q": "已知数组 a=np.array ([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]])<br>b=np.array ([1, 2, 3]),则 a+b 的输岀结果为(   )。",
    "t": "single",
    "a": "[[1, 2, 3], [11, 12, 13], [21, 22, 23], [31, 32, 33]]"
  },
  "1313": {
    "q": "A=np.array ([[1, 1], [0, 1]]), B=np.array ([[2, 0], [3, 4]]), A*B 的结果是（    ）。",
    "t": "single",
    "a": "[[2, 0], [0, 4]]"
  },
  "1314": {
    "q": "运行下面代码的输出结果为( arr = np.array ([1, 5, 3]) arrl = np.array ([2, 4, 6]) print ( arr &lt; arrl )",
    "t": "single",
    "a": "[Ture, False, Ture]"
  },
  "1315": {
    "q": "在Numpy中，数组拼接的函数不包括(   )。",
    "t": "single",
    "a": "where (     )"
  },
  "1316": {
    "q": "运行下面代码的输出结果为(   )。<br>a=np.array ( [[1, 2], [3, 4]] )<br>b=np.array ([[1, 2], [3, 4]] )<br>np.vstack ( a, b)",
    "t": "single",
    "a": "[[1,2], [3, 4], [1,2], [3, 4]]"
  },
  "1317": {
    "q": "下列关于连接数组的描述不正确的是(    )。",
    "t": "single",
    "a": "hstack ( ) 3D堆叠序列中的数组(行方向)"
  },
  "1318": {
    "q": "运行下面代码的输出结果为(    )。<br>a= np.array ([[1,2,3], [4, 5, 6]]) <br>print( np.append ( a, [7, 8, 9]))",
    "t": "single",
    "a": "[1 2 3 4 5 6 7 8 9]"
  },
  "1319": {
    "q": "运行下面代码的输出结果为(    )。<br>a= np.array( [[1, 2], [3,4], [5, 6]])<br>print( np.insert ( a, 3, [11, 12]))",
    "t": "single",
    "a": "[1 2 3 11 12 4 5 6]"
  },
  "1320": {
    "q": "运行下面代码的输出结果为(    )。<br>np.concatenate ([[[1 2 3] [2 3 4]], [[3 4 5]]], axis=0 )",
    "t": "single",
    "a": "[[12 3] [2 3 4] [3 4 5]]"
  },
  "1321": {
    "q": "Numpy数组分割使用的函数是(  )。",
    "t": "single",
    "a": "split (    )"
  },
  "1322": {
    "q": "运行下面代码的输出结果为(    )。<br>a = np.arange ( 9 )<br>b = np.split ( a, 3 )<br>print (b)",
    "t": "single",
    "a": "[array ([0, 1, 2]), array ([3, 4, 5]), array ([6, 7, 8]) ]"
  },
  "1323": {
    "q": "Numpy数组输出的原则是(      )。",
    "t": "single",
    "a": "从左到右,从上到下"
  },
  "1324": {
    "q": "三维以上数组是以（     ）的形式输岀的。",
    "t": "single",
    "a": "按矩阵列表输出"
  },
  "1325": {
    "q": "下列关于副本和视图的描述错误的是（     ）。",
    "t": "single",
    "a": "调用Ndarray的copy (   )函数产生—个视图"
  },
  "1326": {
    "q": "运行下面代码的输出结果为(    )。<br />\r\nimport numpy as np<br />\r\na = np.arange ( 4 )<br />\r\nb = a[:] <br />\r\na[1] = 9<br />\r\nprint (a) <br />\r\nprint (b)",
    "t": "single",
    "a": "[0, 9, 2, 3][0, 9, 2, 3]"
  },
  "1327": {
    "q": "np.sort (  )函数返回的是(   )。",
    "t": "single",
    "a": "排好序的数组拷贝"
  },
  "1328": {
    "q": "运行下面代码的输出结果为(    )。<br>a = np.array ([[5,3,2], [2, 4, 0]] )<br>n = np.sort ( a, axis=None )<br>print (n)",
    "t": "single",
    "a": "[0, 2, 2, 3, 4, 5]"
  },
  "1329": {
    "q": "若 a=np.array ([5, 1, 2, 3]), a.sort (   ),则数组 a 的结果是（     ）。",
    "t": "single",
    "a": "[1, 2, 3, 5]"
  },
  "1330": {
    "q": "矩阵相减使用的函数是(    )。",
    "t": "single",
    "a": "np.subtract (    )"
  },
  "1331": {
    "q": "np.floor (   )函数的作用是(  )。",
    "t": "single",
    "a": "计算小于每个元素的最大整数值"
  },
  "1332": {
    "q": "np.floor ([-1.7, 1.5, -0.2, 0.6, 10])的输出结果是(    )。",
    "t": "single",
    "a": "[-2., 1., -1., 0., 10.]"
  },
  "1333": {
    "q": "np.dot ([[1, 2, 3], [1,2, 3], [1, 2, 3]], [[2, 1, 1], [2, 1, 1], [2, 1,1]])的输出结果是(    )。",
    "t": "single",
    "a": "[[l, 2, 6, 6], [12, 6, 6], [12, 6, 6]]"
  },
  "1334": {
    "q": "Numpy中对数组进行转置的函数是(     )。",
    "t": "single",
    "a": "transpose (   )"
  },
  "1335": {
    "q": "np.argmax (  )函数的作用是(   )。",
    "t": "single",
    "a": "输出数组最大值的索引下标"
  },
  "1336": {
    "q": "a = np.arange ( 1, 13 , 1 ).reshape ( 3 , 4 ), np.mean ( a, axis=O ) 的输出结果是（    ）。",
    "t": "single",
    "a": "[5, 6, 7, 8]"
  },
  "1337": {
    "q": "运行下面代码的输出结果为(    )。<br>import numpy as np<br>a = np.array ([[3, 7, 5], [8, 4, 3], [2, 4, 9]])<br>print ( np.ptp ( a ))",
    "t": "single",
    "a": "7"
  },
  "1338": {
    "q": "运行下面代码的输岀结果为（    ）。<br>import numpy as np<br>a = np.array ([[10, 7, 4], [3, 2, 1]])<br>print( np.percentile ( a, 50 ))",
    "t": "single",
    "a": "3.5"
  },
  "1339": {
    "q": "运行下面代码的输岀结果为（    ）。<br>import numpy as np<br>a = np.array ([[30, 65, 70], [80, 95, 10]5 [50, 90, 60]]) <br>print( np.median ( a, axis=l ))",
    "t": "single",
    "a": "[65.5 80., 60.]"
  },
  "1340": {
    "q": "运行下面代码的输岀结果为（    ）。<br>import numpy as np<br>a = np.array ([[1, 2, 3], [3, 4, 5], [4, 5, 6]] )<br>print(np.mean ( a, axis=0 ) )",
    "t": "single",
    "a": "[2.66666667 3.66666667 4.66666667]"
  },
  "1341": {
    "q": "运行下面代码的输岀结果为（    ）。<br>import numpy as np<br>a = np.arange ( 6 ) .reshape ( 3, 2 )<br>wt= np.array ([3, 5] )<br>print( np.average ( a, axis^l, weights^wt))",
    "t": "single",
    "a": "[0.625 2.625 4.625]"
  },
  "1342": {
    "q": "np.where ([[True, False], [True, True]], [[1,2], [3, 4]], [[9, 8], [7, 6]])的输出结果是（ ）。",
    "t": "single",
    "a": "[[1, 8], [3,4]]"
  },
  "1343": {
    "q": "a = np.array ([1, 0, 0, 3, 4, 5, 0, 8]), b = np.nonzero ( a),则 b[0]的值为（   ）。",
    "t": "single",
    "a": "[0, 3, 4, 5, 7]"
  },
  "1344": {
    "q": "运行下面代码的输出结果为（     ）。<br />\r\narrl = np.arange (0, 16, 1 ) .reshape(4,4)<br />\r\nnp.delete ( arr1, 1, axis=1 )<br />\r\nprint (arr1 )",
    "t": "single",
    "a": "[[0, 1,2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]"
  },
  "1345": {
    "q": "运行下面程序，可以获得两个数组元素匹配的位置的操作是（     ）。<br>输入:a = np.array ([1,2, 3, 2, 3, 4, 3, 4, 5, 6] )<br>b = np.array ([7, 2, 10, 2, 7, 4, 9, 4, 9, 8] )<br>期望输出:(array ([1, 3, 5, 7]), )",
    "t": "single",
    "a": "np.where ( a == b )"
  },
  "1346": {
    "q": "运行下面代码的输出结果为（     ）。<br>import numpy as np<br>a = np.arange ( 12 ) .reshape(3,4)<br>print( np.delete ( a, 5 ))",
    "t": "single",
    "a": "[0 1 2 3 4 6 7 8 9 10 11]"
  },
  "1347": {
    "q": "运行下面代码的输出结果为（    ）。<br>import numpy as np<br>a = np.array ([-1.7, 1.5, -0.2, 0.6, 10] )<br>print( np.ceil ( a ) )",
    "t": "single",
    "a": "[-1.2. -0. 1. 10.]"
  },
  "1348": {
    "q": "运行下面代码的输出结果为（    ）。<br>import numpy as np<br>a = np.array ([0.25, 1.33, 1, 100])<br>print ( np.reciprocal (a))",
    "t": "single",
    "a": "[4. 0.7518797 1. 0.01 ]"
  },
  "1349": {
    "q": "运行下面代码的输出结果为（    ）。<br>import numpy as np<br>a = np.array ([10, 100, 1000])<br>print( np.power ( a, 2 ))",
    "t": "single",
    "a": "[100 10000 1000000]"
  },
  "1350": {
    "q": "运行下面代码的输出结果为（    ）。<br>import numpy as np<br>x = np.array ([3, 1,2] )<br>y = np.argsort ( x )<br>print (y)",
    "t": "single",
    "a": "[1 2 0]"
  },
  "1351": {
    "q": "运行下面代码的输出结果为（    ）。<br>import numpy as np<br>nm=( 'raju', 'anil', 'ravi', 'amar')<br>dv=('f.y.', 's.y.', 's.y.', 'f.y.')<br>ind = np.lexsort ( nm, dv )<br>print (ind)",
    "t": "single",
    "a": "[3 0 1 2]"
  },
  "1352": {
    "q": "np.exp ( x ) .round ( 5 )的结果是 2.71828,则 x 的值是()。",
    "t": "single",
    "a": "2.71828"
  },
  "1353": {
    "q": "Numpy包中meshgrid (  )函数实现的功能是（     ）。",
    "t": "single",
    "a": "数组融合"
  },
  "1354": {
    "q": "运行下面程序，下列结果不正确的是（     ）。<br>import numpy as np<br>x = np.array ([[1, 2], [3, 4]])<br>y = np.linalg.inv ( x )<br>print (y)",
    "t": "single",
    "a": "[[-2. 1.] [ 1.5 -0.5]]"
  },
  "1355": {
    "q": "np.linalg.svd (  )函数可以实现（     ）功能。",
    "t": "single",
    "a": "实现奇异值分解"
  },
  "1356": {
    "q": "在 Numpy 中,（    ）模块可以计算逆矩阵、求特征值、解线性方程组以及求解<br>行列式。",
    "t": "single",
    "a": "linalg"
  },
  "1357": {
    "q": "np.setdiffld (Ndarray 1, Ndarray2 )函数的作用是（    ）。",
    "t": "single",
    "a": "返回二者的差集"
  },
  "1358": {
    "q": "针对以下数组，可以获取两个Python Numpy数组之间的公共项的是（     ）。<br />\r\na = np.array ([1, 2, 3, 2, 3, 4, 3, 4, 5, 6] )<br />\r\nb = np.array ([7, 2, 10, 2, 7, 4, 9, 4, 9, 8] )<br />\r\n期望输出:array ([2,4] )",
    "t": "single",
    "a": "np. Intersectld ( a, b )"
  },
  "1359": {
    "q": "下列关于Python语言特点的描述错误的是（）。",
    "t": "single",
    "a": "Python语言是非开源语言"
  },
  "1360": {
    "q": "下列说法不正确的是（）。",
    "t": "single",
    "a": "静态语言采用解释方式执行，脚本语言采用编译方式执行"
  },
  "1361": {
    "q": "下列不属于python特点的是（）。",
    "t": "single",
    "a": "运行效率高"
  },
  "1362": {
    "q": "下列关于计算机编程语言的说法错误的是（）",
    "t": "single",
    "a": "计算机能识别和执行所有编程语言写的程序"
  },
  "1363": {
    "q": "下列关于Python的说法不正确的是（）。",
    "t": "single",
    "a": "Python只能在Windows系统下编写"
  },
  "1364": {
    "q": "下列关于Python内存管理的说法错误的是（）。",
    "t": "single",
    "a": "变量无须先创建和赋值而直接使用"
  },
  "1365": {
    "q": "将Python中的.py文件转换为.pyc文件的组件为（）。",
    "t": "single",
    "a": "编译器"
  },
  "1366": {
    "q": "下列关于缩进格式的描述不正确的是（）。",
    "t": "single",
    "a": "平级的语句行（代码块）的缩进可以不相同"
  },
  "1367": {
    "q": "Python中用（）快捷键表示运行当前程序。",
    "t": "single",
    "a": "Ctrl+Shift+F10"
  },
  "1368": {
    "q": "IDLE环境的退出命令是( )。",
    "t": "single",
    "a": "exit ()"
  },
  "1369": {
    "q": "下列关于Python注释的描述错误的是()。",
    "t": "single",
    "a": "Python注释语句不被解释器过滤掉，也不被执行"
  },
  "1370": {
    "q": "在Linux下预装了 Python2、Python3且默认Python版本为Python3,则下列描述可以正确启动Python的是( )。",
    "t": "single",
    "a": "在 Linux 应用程序 Terminal, 打开一个终端窗口，输入 Python2 或 Python3"
  },
  "1371": {
    "q": "在Windows系统中，关闭Python终端会话常用的快捷键是( )。",
    "t": "single",
    "a": "Ctrl+Z"
  },
  "1372": {
    "q": "下列不属于Python IDE的是()。",
    "t": "single",
    "a": "R studio"
  },
  "1373": {
    "q": "Python解释器的提示符为（）。",
    "t": "single",
    "a": "&gt;&gt;&gt;"
  },
  "1374": {
    "q": "下列关于IPython的说法错误的是（）。",
    "t": "single",
    "a": "与标准的Python相比，IPython缺少内置的功能和函数"
  },
  "1375": {
    "q": "下列关于Python包的说法正确的是（）。",
    "t": "single",
    "a": "下载安装、更新、查看、移除包等行为既可以用pipX具，也可以用conda工具"
  },
  "1376": {
    "q": "pip install scipy== 1.7 与 pip install scipy 的区别是（）。",
    "t": "single",
    "a": "前者安装指定版本的包,后者安装最新版本的包"
  },
  "1377": {
    "q": "使用pip工具查看当前已安装的Python扩展库的完整命令是（）",
    "t": "single",
    "a": "pip list"
  },
  "1378": {
    "q": "在Python3中安装第三方模块的指令是(  )。",
    "t": "single",
    "a": "pip install skleam"
  },
  "1379": {
    "q": "Python安装扩展库常用的是（  )工具。",
    "t": "single",
    "a": "pip"
  },
  "1380": {
    "q": "列表中可以放（）个字符串。",
    "t": "single",
    "a": "无限个"
  },
  "1381": {
    "q": "Python使用（   ）符号标7K注释。",
    "t": "single",
    "a": "#"
  },
  "1382": {
    "q": "(   )不是Python合法标识符。",
    "t": "single",
    "a": "40XL"
  },
  "1383": {
    "q": "下列关于Python程序格式框架的描述错误的是（）。",
    "t": "single",
    "a": "Python语言不采用严格的缩进来表明程序的格式框架"
  },
  "1384": {
    "q": "下列Python赋值语句中不合法的是（    ）。",
    "t": "single",
    "a": "x= （ y=1 ）"
  },
  "1385": {
    "q": "下列语句在Python3中合法的是（）。",
    "t": "single",
    "a": "print （'Hello, World! '）"
  },
  "1386": {
    "q": "下列语句在Python中不合法的是（）。",
    "t": "single",
    "a": "i=\"A\"+2"
  },
  "1387": {
    "q": "当需要在字符串中使用特殊字符时，Pyfhoii使用（）作为转义字符。",
    "t": "single",
    "a": "\\"
  },
  "1388": {
    "q": "T列关于Python程序中缩进的说法正确的是()。",
    "t": "single",
    "a": "缩进在程序中长度统一且强制使用"
  },
  "1389": {
    "q": "下列关于代码规范的描述错误的是()。",
    "t": "single",
    "a": "建议把所有方法都放在一个类中"
  },
  "1390": {
    "q": "下列关于python注释的描述正确的是()。",
    "t": "single",
    "a": "python中单行注释采用#开头"
  },
  "1391": {
    "q": "下列语句中不能创建一个字典的是()。",
    "t": "single",
    "a": "dict3 = { [1, 2, 3]: \"uestc\"}"
  },
  "1392": {
    "q": "PHOTO__PATH - \"./photo/{}.jpg\"指令可以实现( )",
    "t": "single",
    "a": "定义一个名为photo的存储路径"
  },
  "1393": {
    "q": "Python对not、or、and求值的优先顺序是( )。",
    "t": "single",
    "a": "not and or"
  },
  "1394": {
    "q": "Python 语句 print ( 0xA+0xB )的输出结果是()。",
    "t": "single",
    "a": "21"
  },
  "1395": {
    "q": "Python运算符中用来计算集合并集的是()。",
    "t": "single",
    "a": "|"
  },
  "1396": {
    "q": "a=[1，2，3.4, 5],切片时如果要取[2, 3.4],则下列结果正确的是(    )。",
    "t": "single",
    "a": "a[1: -1]"
  },
  "1397": {
    "q": "a=1, b=2, c=3,则下列表达式结果为True的是()。",
    "t": "single",
    "a": "a and a+b&gt;=c"
  },
  "1398": {
    "q": "a=[[l., 2., 1.], [1., 2., 1.]], a+3 的值为（）。",
    "t": "single",
    "a": "以上都不对"
  },
  "1399": {
    "q": "info='abc‘<br />\r\ninfo[2]='d'的输出结果是（）。",
    "t": "single",
    "a": "TypeError: 'str'object does not support item assignment"
  },
  "1400": {
    "q": "python字符串切片时，S[0, 10] 下标的取值范围为（ ）。",
    "t": "single",
    "a": "[0, 10）"
  },
  "1401": {
    "q": "type （le6）的结果为（   ）",
    "t": "single",
    "a": "&lt;class 'float'&gt; <class 'float'=\"\">"
  },
  "1402": {
    "q": "下列数据中不属于字符串的是（  ）",
    "t": "single",
    "a": "abc"
  },
  "1403": {
    "q": "代码 print ( 0.1+0.2==0.3 )的输出结果是()。",
    "t": "single",
    "a": "False"
  },
  "1404": {
    "q": "下列关于浮点数0.0和整数0相同性的描述正确的是()",
    "t": "single",
    "a": "它们具有相同的值"
  },
  "1405": {
    "q": "下列代码中输岀结果是False的是()。",
    "t": "single",
    "a": "&gt; &gt; &gt;  False ! = 0"
  },
  "1406": {
    "q": "假设有列表 a = ['name', 'age', 'sex']和 b = ['Dong', 38, 'Male'],请使用一个语句将这两个列表的内容转换为字典，并且以列表a中的元素为键，以列表b中的元素为值，则这个语句可以写为(   )。",
    "t": "single",
    "a": "c = dict ( zip ( a, b ))"
  },
  "1407": {
    "q": "下列关于eval ()函数的描述错误的是()。",
    "t": "single",
    "a": "执行eval (\"Hello\")和执行eval ( \" 'Hello'\")得到相同的结果"
  },
  "1408": {
    "q": "下列关于Python布尔值的描述正确的是（）。",
    "t": "single",
    "a": "0+0j可以表示False"
  },
  "1409": {
    "q": "列表是Python语言中基本数据类型之一。我们可以通过list国获取列表中第z.个元素的值，那么list[i: j]的作用是（）。",
    "t": "single",
    "a": "返回一个列表切片\t由原列表第i个到第j-1个元素组成的新列表"
  },
  "1410": {
    "q": "单独使用多层索引时，（ ）。",
    "t": "single",
    "a": "只有最外层的索引可以单独使用"
  },
  "1411": {
    "q": "在Python中，下列不是int整型数据的是（ ）。",
    "t": "single",
    "a": "010"
  },
  "1412": {
    "q": "执行下列代码后5 list2的值是( )。<br />\r\nlist1=[4, 5, 6]<br />\r\nlist2=list1<br />\r\nlist1[2]=3",
    "t": "single",
    "a": "[4, 5, 3]"
  },
  "1413": {
    "q": "运行下面代码段，输岀结果为( )。<br />\r\nprint ( bool ( 'False'))<br />\r\nprint (bool)",
    "t": "single",
    "a": "True False"
  },
  "1414": {
    "q": "查看变量内存地址的Python内置函数是()。",
    "t": "single",
    "a": "id ()"
  },
  "1415": {
    "q": "表达式int ('101', 2)的值为( )。",
    "t": "single",
    "a": "5"
  },
  "1416": {
    "q": "运行代码n= ｛｝后，变量为的类型是( )。",
    "t": "single",
    "a": "dict"
  },
  "1417": {
    "q": "运行下面代码，输出结果是( )<br />\r\nd={-2, -1, 0, 1, 2, 3) <br />\r\nn=d.pop ( ) <br />\r\nprint (n)",
    "t": "single",
    "a": "[{\"A\":\"-2\"},{\"B\":\"2<br />\r\nC,不确定        D.3\"}] | ！题错！选C"
  },
  "1418": {
    "q": "在编写程序时经常要对某一个条件进行判断，条件只有成立或不成立两种结果。成立 用True表示，不成立用False表示。则下列关系表达式中结果为True的是()。",
    "t": "single",
    "a": "3&gt;=3"
  },
  "1419": {
    "q": "运行下列代码，输出结果是()。<br />\r\n1 = [i if i%2==0 else i*10 for i in range ( 5 )] <br />\r\nprint (1)",
    "t": "single",
    "a": "[0, 10, 2, 30, 4]"
  },
  "1420": {
    "q": "下列不属于函数作用的是(  )。",
    "t": "single",
    "a": "提高代码执行速度"
  },
  "1421": {
    "q": "下列叙述正确的是(  )。",
    "t": "single",
    "a": "只能在循环体内使用break语句"
  },
  "1422": {
    "q": "下列关于break、continue的说法正确的是()。",
    "t": "single",
    "a": "continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下 一轮循环；在循环中break的作用是终止当前循环结构的后续操作，一旦程序运 行了 break,循环也就终止了"
  },
  "1423": {
    "q": "下列表述正确的是()。",
    "t": "single",
    "a": "if语句分支嵌套实现多分支"
  },
  "1424": {
    "q": "下列for语句结构中，total初始值为0,不能完成1 ~ 10的累加功能的是()。",
    "t": "single",
    "a": "for i in range ( 10, 0 ):<br />\r\ntotal +=i"
  },
  "1425": {
    "q": "下列语句会无限循环下去的是( )。",
    "t": "single",
    "a": "while i&lt;10:<br>timesleep ( 10)"
  },
  "1426": {
    "q": "下面python循环体执行的次数与其他不同的是()。",
    "t": "single",
    "a": "i=0<br />\r\nwhile (i&lt;=0 ): <br />\r\nprint (i) <br />\r\ni=i+1"
  },
  "1427": {
    "q": "下列if语句能实现统计“成绩(score)优秀的男生以及不及格的男生的人数”功能<br />\r\n的是()。",
    "t": "single",
    "a": "if( gender==n 男\"and ( score&lt;60 or score&gt;=90 ):<br />\r\nn+=1"
  },
  "1428": {
    "q": "下列关于运算符优先级的说法不正确的是( )。",
    "t": "single",
    "a": "同一优先级的运算符在表达式中都是按照从右到左的顺序进行运算的"
  },
  "1429": {
    "q": "下面程序段执行后的输出结果是()。<br />\r\nn-1<br />\r\nwhile n&lt;5:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s=s*n<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; n=n+1<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; print (s)",
    "t": "single",
    "a": "24"
  },
  "1430": {
    "q": "下列表达式中[print ( x, y, 100-x-y ) for x in range ( 21 ) for y in range ( 34 ) if ( 100- x-y ) %3==0 and 5*x+3*y+ ( 100-x-y) //3==100],第三次输出的结果是(   )。",
    "t": "single",
    "a": "8 11 81"
  },
  "1431": {
    "q": "使用While循环语句时，如果想要使程序无限循环运行，则可作为循环的〈条件〉 判断语句的是（）。",
    "t": "single",
    "a": "31&gt;23"
  },
  "1432": {
    "q": "如果x = 5.5,则表达式x &gt; 0 and x==int ( x )的运算结果和表达式x &gt; 0 or x==int (x )的运算结果分别为(       )。",
    "t": "single",
    "a": "False； True"
  },
  "1433": {
    "q": "下列关于队列的描述正确的是（     ）。",
    "t": "single",
    "a": "队列是先进先出的线性表"
  },
  "1434": {
    "q": "运行代码，输出结果为(    )。<br />\r\n#! /usr/bin/env python3<br />\r\nn=100<br />\r\nsum = 0<br />\r\ncounter = 1<br />\r\nwhile counter &lt;= n:<br />\r\nsum + counter<br />\r\ncounter += 1<br />\r\nprint (\"1 到 %d 之和为:%d\" % (  n, sum))",
    "t": "single",
    "a": "1到100之和为:0"
  },
  "1435": {
    "q": "python中while的中止的关键字是(  )。",
    "t": "single",
    "a": "break"
  },
  "1436": {
    "q": "Python 语句 list ( range ( 1, 10, 3 )的执行结果为(     )。",
    "t": "single",
    "a": "[1, 4, 7]"
  },
  "1437": {
    "q": "下列语句在Python中非法的是( )。",
    "t": "single",
    "a": "x= ( y=z+1)"
  },
  "1438": {
    "q": "for语句是一种常用的循环语句。下列程序运行后，变量sum的值为<br />\r\nsum=0<br />\r\nfor i in range ( 10 ):<br />\r\n&nbsp; &nbsp; &nbsp;sum=sum+i",
    "t": "single",
    "a": "45"
  },
  "1439": {
    "q": "Python中自定义函数的关键字为(     )。",
    "t": "single",
    "a": "def"
  },
  "1440": {
    "q": "Python的内置函数( )函数可以返回列表、元组、字典、集合、字符串以及对象中元素个数。",
    "t": "single",
    "a": "len ()"
  },
  "1441": {
    "q": "Python变量作为实参时，它和对应形参之间的数据传递方式是(     )。",
    "t": "single",
    "a": "在用户干预情况下，实参形参能相互传递"
  },
  "1442": {
    "q": "[i**i for iin range(3)]的运行结果是(  )。",
    "t": "single",
    "a": "[1, 1, 4]"
  },
  "1443": {
    "q": "tuple函数可以达到的效果是(  )。",
    "t": "single",
    "a": "将列表转换成元组"
  },
  "1444": {
    "q": "T列关于Python中的函数的说法正确的是()。",
    "t": "single",
    "a": "默认参数值可以在传递参数时修改"
  },
  "1445": {
    "q": "下列关于Python全局变量和局部变量的描述不正确的是()。",
    "t": "single",
    "a": "nonlocal变量不可以在内嵌函数中使用"
  },
  "1446": {
    "q": "下列关于Python函数调用的说法错误的是()。",
    "t": "single",
    "a": "由于栈的大小是无限的，所以，递归调用的次数过多，也不会导致栈溢出"
  },
  "1447": {
    "q": "下列函数中可以计算字典元素个数的是()。",
    "t": "single",
    "a": "len ()"
  },
  "1448": {
    "q": "下列关于函数的说法正确的是()。",
    "t": "single",
    "a": "函数定义后需要调用才会执行"
  },
  "1449": {
    "q": "下列说法正确的是哪个()。",
    "t": "single",
    "a": "带有默认值的参数一定位于参数列表的末尾"
  },
  "1450": {
    "q": "下列代码会输出1, 2, 3三个数字的是()。",
    "t": "single",
    "a": "a_list=[0, 1, 2]<br />\r\nfor i in a_list: <br />\r\n&nbsp; &nbsp; &nbsp;print (i + 1 )"
  },
  "1451": {
    "q": "下列代码中最适合接受系统输入是一个整数的是()。",
    "t": "single",
    "a": "num = int (input)"
  },
  "1452": {
    "q": "下列代码中能够打印出138-9922-0202这个电话号码(注意格式需要完全一致)<br>的是()。",
    "t": "single",
    "a": "print (\"138\", end=\"-\")print (\"9922\", end=\"-\")print (\"0202\")"
  },
  "1453": {
    "q": "须以正确的顺序传入函数，调用时的数量必须和声明时的一样的参数是()。",
    "t": "single",
    "a": "位置参数"
  },
  "1454": {
    "q": "在局部生效，岀了这个变量的作用域这个变量就失效了的变量是()。",
    "t": "single",
    "a": "局部变量"
  },
  "1455": {
    "q": "假设已从标准库functools导入reduce ()函数，那么表达式reduce (lambda x, y:x+y, [1, 2, 3])的值为()。",
    "t": "single",
    "a": "6"
  },
  "1456": {
    "q": "下列关于Python的lambda ()函数的描述错误的是()。",
    "t": "single",
    "a": "f = lambda x, y: x+y执行后，f的类型为数字类型"
  },
  "1457": {
    "q": "下列关于Python的全局变量和局部变量的描述错误的是()。",
    "t": "single",
    "a": "局部变量指在函数内部使用的变量，当函数退出时，变量依然存在，下次函数调 用可以继续使用"
  },
  "1458": {
    "q": "下列关于函数的关键字参数使用限制的描述错误的是()。",
    "t": "single",
    "a": "关键字参数必须位于位置参数之前"
  },
  "1459": {
    "q": "下列关于函数的参数的描述错误的是( )。",
    "t": "single",
    "a": "可选参数可以定义在非可选参数的前面"
  },
  "1460": {
    "q": "可变参数\"args传入函数时存储的类型是(    )。",
    "t": "single",
    "a": "tuple"
  },
  "1461": {
    "q": "运行下面程序，输出的结果是( )<br />\r\ndef chanagelnt (number2 ):<br />\r\nnumber2=number2+1<br />\r\nprint ( \"changeInt: number2= \", number2 ) <br />\r\n#调用 <br />\r\nnumber 1 =2； Chanagelnt ( number 1 ) <br />\r\nprint (\"number:\", number 1 )",
    "t": "single",
    "a": "changeInt: number2= 3 number: 2"
  },
  "1462": {
    "q": "在Python中,函数(     )。",
    "t": "single",
    "a": "以上都不对"
  },
  "1463": {
    "q": "已知列表对象x=['11' , '2' , '3' ],则表达式max (x, key=len)的值为( )",
    "t": "single",
    "a": "'11'"
  },
  "1464": {
    "q": "下列关于异常说法正确的是（     ）。",
    "t": "single",
    "a": "程序中抛出异常不一定终止程序"
  },
  "1465": {
    "q": "Python用于异常处理结构中捕获特定类型的异常的保留字是（   ）。",
    "t": "single",
    "a": "except"
  },
  "1466": {
    "q": "下列关于异常处理的描述正确的是（ ）。",
    "t": "single",
    "a": "Python中允许利用raise语句由程序主动引发异常"
  },
  "1467": {
    "q": "运行下面代码，输出结果为（ ）。<br />\r\na=1<br />\r\ntry:<br />\r\na+=1<br />\r\nexcept:<br />\r\na+=1<br />\r\nelse:<br />\r\n&nbsp; &nbsp;a+=1<br />\r\nfinally:<br />\r\n&nbsp; &nbsp;a+=1<br />\r\nprint（a）",
    "t": "single",
    "a": "4"
  },
  "1468": {
    "q": "下列用于触发异常的是（）。",
    "t": "single",
    "a": "raise"
  },
  "1469": {
    "q": "（）是唯一不在运行时发生的异常。",
    "t": "single",
    "a": "SyntaxError"
  },
  "1470": {
    "q": "如果python程序中包括零运算，解释器将在运行时抛出（）错误信息。",
    "t": "single",
    "a": "ZeroDivisionError"
  },
  "1471": {
    "q": "下列关于抛出异常的说法错误的是（）。",
    "t": "single",
    "a": "使用raise抛出异常时，无法指定描述信息"
  },
  "1472": {
    "q": "对下面程序的描述错误的是（）。<br />\r\ntry:<br />\r\n&nbsp; &nbsp;#语句块1<br />\r\nexcept IndexError as i:<br />\r\n&nbsp; &nbsp;#语句块2",
    "t": "single",
    "a": "该程序对异常处理了，因此一定不会终止程序"
  },
  "1473": {
    "q": "当try子句中没有任何错误时，一定不会执行（）语句。",
    "t": "single",
    "a": "except"
  },
  "1474": {
    "q": "下列关于__new__和__init__区别的说法不正确的是（）。",
    "t": "single",
    "a": "__new__是一个实例方法，而__init__是一个静态方法"
  },
  "1475": {
    "q": "@app.route 的作用是（    ）。",
    "t": "single",
    "a": "flask装饰器，返回本地网络测试地址"
  },
  "1476": {
    "q": "Python中定义私有属性的方法是（）。",
    "t": "single",
    "a": "使用__x x__定义属性名"
  },
  "1477": {
    "q": "下列关于Python单下划线_foo与双下划线__foo与__foo__的说法错误的是()。",
    "t": "single",
    "a": "__foo可以直接用于'from module import'"
  },
  "1478": {
    "q": "Python解释器环境中，用于表示上一次运算结果的特殊变量为()。",
    "t": "single",
    "a": "_"
  },
  "1479": {
    "q": "Python语言定义的class的初始化函数的函数名是( )",
    "t": "single",
    "a": "__init__"
  },
  "1480": {
    "q": "下列方法不可以使用类名访问的是()。",
    "t": "single",
    "a": "实例方法"
  },
  "1481": {
    "q": "下列函数能够让所有单词的首字母变成大写的是( )。",
    "t": "single",
    "a": "title ()"
  },
  "1482": {
    "q": "下列函数能够返回某个子串在字符串中岀现次数的是(  )。",
    "t": "single",
    "a": "count ()函数"
  },
  "1483": {
    "q": "运行下面程序，a、b、c、d四个变量的值错误的是(  )。<br />\r\nimport copy<br />\r\na=[1, 2, 3, 4, ['a','b']]<br />\r\nb=a <br />\r\nc=copy.copy (a) <br />\r\nd=copy. deepcopy ( a) <br />\r\na.append ( 5 ) <br />\r\na[4].append ('c')",
    "t": "single",
    "a": "d==[1,2,3,4,['a', 'b', 'c']]"
  },
  "1484": {
    "q": "假设函数中不包括global保留字，则下列关于改变参数值的方法的说法错误的是( )。",
    "t": "single",
    "a": "参数的值是否改变与函数中对变量的操作有关，与参数类型无关"
  },
  "1485": {
    "q": "下列关于python的类的说法错误的是()。",
    "t": "single",
    "a": "类的实例方法必须创建对象前才可以调用"
  },
  "1486": {
    "q": "下列关于面向过程和面向对象的说法错误的是(  )。",
    "t": "single",
    "a": "面向过程是基于面向对象的"
  },
  "1487": {
    "q": "列表对象的sort ()函数用来对列表元素进行原地排序，该函数返回值为(  )。",
    "t": "single",
    "a": "None"
  },
  "1488": {
    "q": "执行下面代码段时，输岀结果为(    )。<br>motorcycles=['honda', 'yamaha', 'suzuki'] <br>motorcycles.append ('ducati') <br>motorcycles.pop ( 1 ) <br>print (motorcycles )",
    "t": "single",
    "a": "['honda', 'suzuki', 'ducati']"
  },
  "1489": {
    "q": "构造方法的作用是（）。",
    "t": "single",
    "a": "对象的初始化"
  },
  "1490": {
    "q": "运行下面代码，输出结果是（）。<br>s=\"The python is python.\"<br>print （ s.find （'python', 10 ））",
    "t": "single",
    "a": "14"
  },
  "1491": {
    "q": "如果字符串中有*需要匹配，需要输入的正则表达式为（ ）。",
    "t": "single",
    "a": "\\*"
  },
  "1492": {
    "q": "运行下面程序，输出结果为（）。<br />\r\nimportre<br />\r\nstrl=\"Python's features\"<br />\r\nstr2=re.match ( r' (.* ) on (.*? ).*', strl, re.M|re.I)<br />\r\nprint ( str2.group ( 1 ))",
    "t": "single",
    "a": "Pyth"
  },
  "1493": {
    "q": "Python的特点和优点有（）。",
    "t": "muti",
    "a": "解释性强 | 使用动态特性 | 面向对象 | 语法简洁"
  },
  "1494": {
    "q": "下列场景适合使用Python的有（）。",
    "t": "muti",
    "a": "可作为脚本语言，快速编写小型程序、脚本等 | 可应用在数据科学、交互式计算及可视化领域 | 可作为胶水语言，整合如C++等语言代码"
  },
  "1495": {
    "q": "下列关于Python语言的特点的描述不正确的有（）。",
    "t": "muti",
    "a": "Python语言不支持面向对象 | Python语言是编译型语言 | Python语言是非跨平台语言"
  },
  "1496": {
    "q": "Python支持运行的平台有（）。",
    "t": "muti",
    "a": "Windows | MacOS | CentOS | Ubuntu"
  },
  "1497": {
    "q": "在Windows系统中通过Geany编写Python程序，运行Python程序的常用步骤有（）。",
    "t": "muti",
    "a": "菜单Build&gt;Execute | 按F5"
  },
  "1498": {
    "q": "下列是Python注释语句的有（）。",
    "t": "muti",
    "a": "'''hello''' | #"
  },
  "1499": {
    "q": "下列不是Python关键字的有（）。",
    "t": "muti",
    "a": "no | null | none"
  },
  "1500": {
    "q": "Python变量命名规则包含（）。",
    "t": "muti",
    "a": "变量名只能包含字母、数字和下划线。变量名可以字母或下划线开头，但不能以数字开头。例如，可将变量命名为message_1，但不能将其命名为1_message | 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名 greeting_message可行，但变量名greeting message会引发错误 | 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print | 变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好"
  },
  "1501": {
    "q": "下列不是Python语言保留字的有（）。",
    "t": "muti",
    "a": "do | until"
  },
  "1502": {
    "q": "下列是Python关键字的有（）。",
    "t": "muti",
    "a": "as | global | not"
  },
  "1503": {
    "q": "下列关于Python中标识符的命名规则的说法正确的有（）。",
    "t": "muti",
    "a": "只能以下划线或者A-Z/a-z中的字母开头 | 关键字不能作为标识符 | Python标识符区分大小写 | 不能以数字开头"
  },
  "1504": {
    "q": "变量名可以包含（）。",
    "t": "muti",
    "a": "字母 | 数字 | 下划线"
  },
  "1505": {
    "q": "Python的优点有（）。",
    "t": "muti",
    "a": "变量不用预定义类型 | 数据结构功能强大 | 语言可解释性强"
  },
  "1506": {
    "q": "Python中，复合赋值运算符包括（）。",
    "t": "muti",
    "a": "简单的赋值运算符 | 乘法赋值运算符 | 取模赋值运算符 | 取整除赋值运算符"
  },
  "1507": {
    "q": "下列Python逻辑表达式结果是False的有（）。",
    "t": "muti",
    "a": "not (True or False) | 1 == 0"
  },
  "1508": {
    "q": "下列关于Python的描述正确的有（）。",
    "t": "muti",
    "a": "pass语句不会执行任何操作，一般作为占位符或者创建占位程序 | sorted 可以对列表进行排序，如i = [5, 1, 2, 3, 4] i = sorted（i） | 内建的数据类型丰富，除了字典和列表外，还有集合（set）元组（tuple）等类型"
  },
  "1509": {
    "q": "下列关于Python中的列表和字典的说法正确的有（）。",
    "t": "muti",
    "a": "字典和列表都可以通过“[]”操作符访问元素的值 | 列表的索引必须是整型数或者切片"
  },
  "1510": {
    "q": "下列关于Python组合数据类型的描述正确的有（）。",
    "t": "muti",
    "a": "Python的str、tuple和list类型都属于序列类型 | Python组合数据类型能够将多个同类型或不同类型的数据组织起来，通过单一的表示使数据操作更有序更容易 | 组合数据类型可以分为序列类型、集合类型和映射类型3类"
  },
  "1511": {
    "q": "下列关于字典的遍历的描述正确的有（）。",
    "t": "muti",
    "a": "for变量iin字典:使用i遍历所有的键，有键就可以通过变量访问其值 | for变量i,变量jin字典items):使用变量i遍历所有键，通过变量j遍历所有值"
  },
  "1512": {
    "q": "字符串的格式化可以使用（）。",
    "t": "muti",
    "a": "% | format"
  },
  "1513": {
    "q": "下列关于函数的递归调用的描述正确的有（）。",
    "t": "muti",
    "a": "必须有一个明确的结束条件 | 每次进入更深一层递归时，问题规模相比上次递归都应有所减少 | 递归调用效率不高，递归层次过多会导致栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧 | 由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出"
  },
  "1514": {
    "q": "下列关于Python中的for语句的描述正确的有（）。",
    "t": "muti",
    "a": "Python中for语句只有一种写法:forin | continue语句可以跳过循环的当前—步 | for语句可以有else部分"
  },
  "1515": {
    "q": "下列选项是数值数据类型（即可用于算术表达式）的有（）。",
    "t": "muti",
    "a": "0xff | 99 | 122"
  },
  "1516": {
    "q": "Python逻辑表达式中，（）会导致逻辑短路，即不会继续向下推算而直接返回结果。",
    "t": "muti",
    "a": "False开头的and语句 | True开头的or语句"
  },
  "1517": {
    "q": "下列字符串正确的有（）。",
    "t": "muti",
    "a": "’abc’’ab’ | ’’abc\\’’ab’’"
  },
  "1518": {
    "q": "Python函数包括（）。",
    "t": "muti",
    "a": "函数名称 | 参数 | 执行语句 | 返回值"
  },
  "1519": {
    "q": "下列关于json数据格式的说法正确的有（）。",
    "t": "muti",
    "a": "具有数据结构紧凑可读性强的优点 | Python中可以使用json模块把json格式字符串解码转换成Python对象 | 网络中交换数据最常见的格式之一"
  },
  "1520": {
    "q": "下列关于reduce函数功能的描述正确的有（）。",
    "t": "muti",
    "a": "合并value值，形成较小集合 | 采用迭代器将中间值提供给reduce （）函数 | map （）函数处理后结果才会传输给reduce （）函数 | 内存中不会存储大量的value值"
  },
  "1521": {
    "q": "下面定义函数正确的有（）。",
    "t": "muti",
    "a": "def calc ( *numbers ): sum=0 for n in numbers: sum=sum+n*n return sum | def calc ( **numbers ): sum=0 for n in numbers: sum=sum+n*n return sum"
  },
  "1522": {
    "q": "下列函数属于二元通用函数（binary universal functions）的有（）。",
    "t": "muti",
    "a": "add | substract | multiply | power"
  },
  "1523": {
    "q": "任何函数都可以修改，所以尽量少用全局变量，主要原因包括（）。",
    "t": "muti",
    "a": "不够安全 | 一直占用内存"
  },
  "1524": {
    "q": "Python中，字符串格式化的方式是（）。",
    "t": "muti",
    "a": "% | format"
  },
  "1525": {
    "q": "Python中字典的内置方法包括（）。",
    "t": "muti",
    "a": "radiansdictkeys （） | radiansdictsetdefault ( key, default=None ) | radiansdictupdate ( dict2 ) | radiansdictvalues （）"
  },
  "1526": {
    "q": "下列集合操作结果正确的有（）。",
    "t": "muti",
    "a": "name={'d', 's’}nameadd ('sd'), name值为{'sd','d','s'} | name={'sd', d','s'}nameremove ('s'), name值为{'sd','d’} | name={'sd', d','s'}nameclear ), name值为{ }"
  },
  "1527": {
    "q": "面向对象技术的特征包含（）。",
    "t": "muti",
    "a": "封装 | 继承 | 多态"
  },
  "1528": {
    "q": "下列关于字符串函数或方法的说法正确的有（）。",
    "t": "muti",
    "a": "istitle（）如果字符串是标题化的(见title)则返回True,否则返回False | max (str)返回字符串str中最大的字母。 | replace ( old, new, max )把将字符串中的str1替换成str2,如果max指定，则替换不超过max次"
  },
  "1529": {
    "q": "下列函数中是有效的类构造函数的有（）。",
    "t": "muti",
    "a": "def _Init_ ( self ): | def _init_ ( self, var=0 ): | def _init_ ( self, a,b,c ):"
  },
  "1530": {
    "q": "类的特点有（）。",
    "t": "muti",
    "a": "封装 | 继承 | 多态"
  },
  "1531": {
    "q": "下列关于CSV文件的描述正确的有（）。",
    "t": "muti",
    "a": "CSV文件可用于不同工具间进行数据交换 | CSV文件格式是一种通用的、相对简单的文件格式，应用于程序之间转移表格 数据 | CSV文件的每一行是一维数据,可以使用Python中的列表类型表示"
  },
  "1532": {
    "q": "文件基本操作的函数有()。",
    "t": "muti",
    "a": "close ( ) | read（） | rename ( ) | remove（）"
  },
  "1533": {
    "q": "下列关于数据组织的维度的描述正确的有（）。",
    "t": "muti",
    "a": "高维数据有键值对类型的数据构成，采用对象方式组织 | 二维数据采用表格方式组织，对应于数学中的矩阵 | 一维数据采用线性方式组织，对应于数学中的数组和集合等概念"
  },
  "1534": {
    "q": "下列可以用于实现爬虫功能的有（）。",
    "t": "muti",
    "a": "BeautifulSoup库 | Scrapy框架 | urllibrequest库"
  },
  "1535": {
    "q": "下列关于HTML标签嵌套规则的说法正确的有（）。",
    "t": "muti",
    "a": "HTML标签包括块级元素和内嵌元素 | 内嵌元素一般用在网站内容之中的某些细节或部位，用以强调区分样式上标下标锚点等，通常包括 a、abbr、bbr、font、i、img、input、kbd、labek、q、s、select、small、span、sub、tt、u、var等 | 其中块级元素一般用来搭建网络架构布局承载内容，通常包括的标签有address、dir、divd、dl、dt、dd、form、hl ~ h6、hr、is、index、menu、noframes、noscript、ol、p、pre、table、ul等"
  },
  "1536": {
    "q": "下列关于API爬虫的说法错误的有（）。",
    "t": "muti",
    "a": "基于API的爬虫任务中，速度一般较慢 | 基于API的爬虫，爬取的好处是没有次数的限制 | 基于API的爬取能够覆盖网站所有信息"
  },
  "1537": {
    "q": "下列关于HTML的叙述正确的有（）。",
    "t": "muti",
    "a": "一个HTML文件可以用记事本来编辑 | HTML的意思是超文本标记语言 | 一个HTML文件必须是一个以htm或html为扩展名的文件"
  },
  "1538": {
    "q": "下列说法正确的有（）。",
    "t": "muti",
    "a": "cookielib库提供可存储cookie的对象，以便与urllirequest库配合使用来进行访问 | 使用split（）可以进行字符串的拆分 | 正则表达式可以实现对爬取信息的快速过滤"
  },
  "1539": {
    "q": "常用的爬虫技巧有（）。",
    "t": "muti",
    "a": "更改header，伪装成浏览器进行爬取 | 设置爬取的时间间隔 | 应用神经网络算法识别网站验证码 | 通过代理服务器进行爬取"
  },
  "1540": {
    "q": "下列说法正确的有（）。",
    "t": "muti",
    "a": "网站服务器可以识别你使用的访问软件，因为在发送访问请求中有特定位置的字符串和软件类型相关 | 低级别的代理服务器十分容易被识别"
  },
  "1541": {
    "q": "下列关于超链接的说法正确的有()。",
    "t": "muti",
    "a": "语句&lt;a href=\"formhtml\"&gt;Fill Our Form&lt;/a&gt;指向的是同一服务器同—目录下的 formhtml | 语句&lt;a href=\"stuff7cathtml\"&gt;Catalog&lt;/a&gt;指向的是同一服务器子目录stuff下的 cathtml | 语句&lt;a href=\"/parenthtml\"&gt;Parent&lt;/a&gt;指向的是同一服务器父目录下的parenthtml"
  },
  "1542": {
    "q": "在Python中查看关键字，需要在Python解释器中执行（）两条命令。",
    "t": "muti",
    "a": "import keyword | keyword"
  },
  "1543": {
    "q": "python标准库包含（）。",
    "t": "muti",
    "a": "os | sys | re"
  },
  "1544": {
    "q": "下列关于Python分隔代码块的描述错误的有（）。",
    "t": "muti",
    "a": "代码以“begin”开头，“end”结尾 | 每行代码的缩进都一致 | 代码块被封装在花括号中"
  },
  "1545": {
    "q": "下列导入模块正确的有（）。",
    "t": "muti",
    "a": "import numpy | import numpy as np | from matplotlib import pyplot | from matplotlib import pyplot as plt"
  },
  "1546": {
    "q": "在Python中，下列导入模块方式正确的有（）。",
    "t": "muti",
    "a": "import模块名 | import模块名as模块的别名 | from模块名import函数名 | from模块名import函数名A.函数名B"
  },
  "1547": {
    "q": "下列关于负荷Python的模块的说法正确的有（）。",
    "t": "muti",
    "a": "模块能够用来有逻辑地组织Python代码段 | 把相关的代码分配到一个模块里能让代码更好用、更易懂 | 模块能定义函数、类和变量，模块里也能包含可执行的代码"
  },
  "1548": {
    "q": "模块的通用类别包含（）。",
    "t": "muti",
    "a": "使用Python编写的.py文件 | 已被编译为共享库或DLL的C或C++扩展 | 把一系列模块组织到一起的文件夹 | 使用C编写并链接到Python解释器的内置模块"
  },
  "1549": {
    "q": "（）是scipy.stats可实现的连续随机变量方法。",
    "t": "muti",
    "a": "rvs | pdf | ppf | cdf"
  },
  "1550": {
    "q": "（）是Scipy中的模块。",
    "t": "muti",
    "a": "cluster | constants | integrate | io"
  },
  "1551": {
    "q": "下列关于使用Python操作目录的说法正确的有（）。",
    "t": "muti",
    "a": "mkdir:用于以数字权限模式创建目录 | getcwd:用于返回当前工作目录 | chdir:用于改变当前工作目录到指定的路径 | rmdir:用于删除指定路径的目录，仅当这文件夹是空的才可以，否则抛出<br>OSError"
  },
  "1552": {
    "q": "在Python中，执行import datetime as dt语句后，下列关于时间或日期的定义方式正确的有（）。",
    "t": "muti",
    "a": "dt.datetime (2019, 12, 12, 23, 23, 23 ) | dt.datetime ( 2019, 12, 12, 0 )"
  },
  "1553": {
    "q": "name = np.array (['Liu', 'Wang', 'Zhu', 'Wang', 'Zhu', 'Wang', 'Zhu']),则下列可以 得到['Liu', 'Wang', 'Zhu']的代码是（）。",
    "t": "muti",
    "a": "np.unique ( name ) | sorted ( set ( name ))"
  },
  "1554": {
    "q": "Numpy支持的统计函数有（）。",
    "t": "muti",
    "a": "min | max | median | mean"
  },
  "1555": {
    "q": "a = np.array ([1, 2, 3, 4, 5, 6, 7, 8])下列命令可以使输出结果为([5, 6, 7])的有（）。",
    "t": "muti",
    "a": "a[4: 7] | a[4: -1]"
  },
  "1556": {
    "q": "下列函数是一元通用函数的有（）。",
    "t": "muti",
    "a": "np.exp ( ) | np.sqrt（）"
  },
  "1557": {
    "q": "下列函数是累积函数的有（）。",
    "t": "muti",
    "a": "cumsum | cumprod"
  },
  "1558": {
    "q": "若b = np.amy ([True, False, False])，下列能输岀[False True True]的有（）。",
    "t": "muti",
    "a": "print (~b ) | print ( np.Iogical_not ( b ))"
  },
  "1559": {
    "q": "Numpy数组中将一个数组分割成多个小数组的分割函数包括（）。",
    "t": "muti",
    "a": "hsplit | vsplit | split | dsplit"
  },
  "1560": {
    "q": "Numpy中计算数组的标准差和方差的函数有（）。",
    "t": "muti",
    "a": "std ( ) | var（）"
  },
  "1561": {
    "q": "Scikit-Learn中可以实现（）算法。",
    "t": "muti",
    "a": "分类 | 聚类 | 回归 | 降维"
  },
  "1562": {
    "q": "Scikit-Learn中包含的算法有（）。",
    "t": "muti",
    "a": "SVM | 随机森林 | Lasso回归 | 密度聚类"
  },
  "1563": {
    "q": "可能导致交叉检验模型评估较差的原因有（）。",
    "t": "muti",
    "a": "模型过拟合 | 模型欠拟合 | 模型过度复杂 | 模型过度简单"
  },
  "1564": {
    "q": "关于下列代码的说法正确的有()。<br>x=np.linspace ( 0.05, 10, 1000 )<br>y=np.sin (x)<br>plt.plot ( x, y, ls=\"-.\", 1=2, c=\"c\", label=\"plot figure\")<br>plt.legend （）<br>pit.grid (linestyle=\": \", color=\"r\")<br>plt.show （）",
    "t": "muti",
    "a": "图表中有图例 | 该图画的是sin曲线"
  },
  "1565": {
    "q": "plt.axhline (y=0.0, c=\"r\", ls=\"--\", lw=2 ),下列关于该代码的说法正确的有（）。",
    "t": "muti",
    "a": "添加水平参考线 | 参考线是虚线形式"
  },
  "1566": {
    "q": "Python中Jieba库支持模式有（）。",
    "t": "muti",
    "a": "精准模式 | 全模式 | 搜索引擎模式"
  },
  "1567": {
    "q": "Python中Jieba库的基本实现原理包含()。",
    "t": "muti",
    "a": "分析汉字与汉字之间的关联概率 | 分析汉字词组的关联概率 | 根据用户自定义的词组进行分析"
  },
  "1568": {
    "q": "下列属于Gensim库的特性的有（）。",
    "t": "muti",
    "a": "训练语料的预处理 | 主题向量的变换 | 文档相似度的计算"
  },
  "1569": {
    "q": "与自然语言处理相关的工具包Jieba、Gensim、NETK、Scikit-Leam的区别有（）。",
    "t": "muti",
    "a": "Jieba专注于中文分词操作 | NLTK主要用于一般自然语言处理任务(标记化、POS标记、解析等) | Gensim主要用于题和向量空间建模、文档集合相似性等 | Scikit-learn为机器学习提供了一个大型库，其中包含了用于文本预处理的工具，例如词频一逆文档频率特征提取(TfidfVectorizer)等。"
  },
  "1570": {
    "q": "Pandas中主要的数据结构有（）。",
    "t": "muti",
    "a": "DataFrame | Series"
  },
  "1571": {
    "q": "Pandas中删除列的方式有（）。",
    "t": "muti",
    "a": "df.drop (\"列名\"]，axis=1 ) | df.drop ( columns=[\"列名\"])"
  },
  "1572": {
    "q": "Python中Jieba 库是一个（）库。",
    "t": "muti",
    "a": "第三方中文分词词库"
  },
  "1573": {
    "q": "Python循环效率低的根本原因是Python运行程序时逐行翻译。",
    "t": "judge",
    "a": "正确"
  },
  "1574": {
    "q": "Linux系统是为编程而设计的，因此在大多数Linux计算机中，都默认安装了Python。",
    "t": "judge",
    "a": "正确"
  },
  "1575": {
    "q": "为确定是否安装了 Python，执行命令python（请注意，其中的p是小写的）。",
    "t": "judge",
    "a": "正确"
  },
  "1576": {
    "q": "Geany不是文本编辑器。",
    "t": "judge",
    "a": "错误"
  },
  "1577": {
    "q": "pip命令也支持扩展名为.whl的文件直接安装Python扩展库。",
    "t": "judge",
    "a": "正确"
  },
  "1578": {
    "q": "单引号所围字符串中的双引号不用转义，同理，双引号所围字符串中的单引号不用转义。",
    "t": "judge",
    "a": "正确"
  },
  "1579": {
    "q": "Python中，&lt;返回x是否小于y，这分另与特殊的变量True和False等价，需要注意这些变量名的大写。",
    "t": "judge",
    "a": "正确"
  },
  "1580": {
    "q": "Python 中，c %= a 等效于 c = c % a。",
    "t": "judge",
    "a": "正确"
  },
  "1581": {
    "q": "Python中，c = a + b表示将a + b的运算结果赋值为c。",
    "t": "judge",
    "a": "正确"
  },
  "1582": {
    "q": "Python中，元组不支持像列表那样通过索引方式进行访问。",
    "t": "judge",
    "a": "错误"
  },
  "1583": {
    "q": "Python中，可以通过在引号前加r来表示原始输出。",
    "t": "judge",
    "a": "正确"
  },
  "1584": {
    "q": "Python中，集合也支持通过索引访问指定元素。",
    "t": "judge",
    "a": "错误"
  },
  "1585": {
    "q": "str (x)是将对象x转换为表达式字符串。",
    "t": "judge",
    "a": "错误"
  },
  "1586": {
    "q": "假设x是含有5个元素的列表，那么切片操作x[10:]是无法执行的，会抛出异常。",
    "t": "judge",
    "a": "正确"
  },
  "1587": {
    "q": "关于布尔值:整型、浮点型的0和复数0+0j也可以表示False，浮点数不可以精确表示。",
    "t": "judge",
    "a": "正确"
  },
  "1588": {
    "q": "在Python中，元组与列表类似，区别是在列表中任意元素可以通过索引进行修改，而元组中元素不可更改只能读取。",
    "t": "judge",
    "a": "正确"
  },
  "1589": {
    "q": "已知列表x中包含超过5个以上的元素，那么语句x = x[: 5]+x[5:]的作用是将列表x中的元素循环左移5位。",
    "t": "judge",
    "a": "错误"
  },
  "1590": {
    "q": "在循环中continue语句的作用是跳出当前循环。",
    "t": "judge",
    "a": "错误"
  },
  "1591": {
    "q": "如果仅仅是用于控制循环次数，那么使用for i in range（20）和for i in range（20,40）的作用是等价的。",
    "t": "judge",
    "a": "正确"
  },
  "1592": {
    "q": "带有else子句的循环如果因为执行了break语句而退出的话，则会执行else子句中的代码。",
    "t": "judge",
    "a": "错误"
  },
  "1593": {
    "q": "Python根据条件测试的值来决定是否执行if语句中的代码，如果条件测试的值为True , Python就执行紧跟在if语句后面的代码；如果False , Python就忽略这些代码。",
    "t": "judge",
    "a": "正确"
  },
  "1594": {
    "q": "for语句以遍历对象的方式构造循环，有时却需要构造一种类似无限循环的程序控制<br>结构或某种不确定运行次数的循环，此时就需要使用while语句。",
    "t": "judge",
    "a": "正确"
  },
  "1595": {
    "q": "break语句用在while和for循环中，break语句用来终止循环语句，即循环条件没有<br>False条件或者序列还没被完全递归完，也会停止执行循环语句。",
    "t": "judge",
    "a": "正确"
  },
  "1596": {
    "q": "Python中使用lambda定义的函数是匿名函数。",
    "t": "judge",
    "a": "正确"
  },
  "1597": {
    "q": "def是定义函数的关键字。",
    "t": "judge",
    "a": "正确"
  },
  "1598": {
    "q": "eval（str）是计算在字符串中的有效Python表达式，并返回一个对象。",
    "t": "judge",
    "a": "正确"
  },
  "1599": {
    "q": "全局变量会增加不同函数之间的隐式耦合度，从而降低代码可读性，因此应尽量避<br>免过多使用全局变量。",
    "t": "judge",
    "a": "正确"
  },
  "1600": {
    "q": "关键字参数可以和其他类型的参数一起来使用，如果要一起使用的话，关键字参数<br>必须在最后面。",
    "t": "judge",
    "a": "正确"
  },
  "1601": {
    "q": "关键字参数返回的是字典。",
    "t": "judge",
    "a": "正确"
  },
  "1602": {
    "q": "函数的递归调用效率不高，递归层次过多会导致栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧；每当函数返回，栈就会减一层栈帧。",
    "t": "judge",
    "a": "正确"
  },
  "1603": {
    "q": "在while和for循环中，continue语句跳出本次循环，而break跳岀整个循环。",
    "t": "judge",
    "a": "正确"
  },
  "1604": {
    "q": "在函数中，传入列表、字典等可变对象属于引用传递。",
    "t": "judge",
    "a": "正确"
  },
  "1605": {
    "q": "在函数中，传入数字、字符或者元组等不可变对象属于值传递。",
    "t": "judge",
    "a": "正确"
  },
  "1606": {
    "q": "在函数内部没有办法定义全局变量。",
    "t": "judge",
    "a": "错误"
  },
  "1607": {
    "q": "在同一个作用域内，局部变量会隐藏同名的全局变量。",
    "t": "judge",
    "a": "正确"
  },
  "1608": {
    "q": "在编写函数时，建议首先对形参进行类型检查和数值范围检查之后再编写功能代码，或者使用异常处理结构，尽量避免代码抛出异常而导致程序崩溃。",
    "t": "judge",
    "a": "正确"
  },
  "1609": {
    "q": "如果一定要一起用的话，要按下面的顺序写，不能换顺序，否则会出错:①位置参数；②默认值参数；③可变参数；④关键字参数。",
    "t": "judge",
    "a": "正确"
  },
  "1610": {
    "q": "生成器推导式比列表推导式具有更高的效率，推荐使用。",
    "t": "judge",
    "a": "正确"
  },
  "1611": {
    "q": "返回值执行完函数后，返回给调用者的数据默认为None，所以没有返回值时，可以不写 return。",
    "t": "judge",
    "a": "正确"
  },
  "1612": {
    "q": "在异常处理结构中，不论是否发生异常，finally子句中的代码总是会执行的。",
    "t": "judge",
    "a": "正确"
  },
  "1613": {
    "q": "在try...except...else结构中，如果try块的语句引发了异常则会执行else块中的代码。",
    "t": "judge",
    "a": "错误"
  },
  "1614": {
    "q": "异常处理结构也不是万能的，处理异常的代码也有引发异常的可能。",
    "t": "judge",
    "a": "正确"
  },
  "1615": {
    "q": "带有else子句的异常处理结构，如果不发生异常则执行else子句中的代码。",
    "t": "judge",
    "a": "正确"
  },
  "1616": {
    "q": "在GBK和CP936编码中一个汉字需要2个字节。",
    "t": "judge",
    "a": "正确"
  },
  "1617": {
    "q": "以写模式打开的文件无法进读操作。",
    "t": "judge",
    "a": "正确"
  },
  "1618": {
    "q": "相同内容的字符串使用不同的编码格式进行编码得到的结果并不完全相同。",
    "t": "judge",
    "a": "正确"
  },
  "1619": {
    "q": "相对路径使用的特殊符号”./”状代表目前所在的目录。",
    "t": "judge",
    "a": "正确"
  },
  "1620": {
    "q": "文件’w+’模式可以读写，文件不存在时先建立文件。",
    "t": "judge",
    "a": "正确"
  },
  "1621": {
    "q": "文件’r+’模式可以读写，但文件一定要存在。",
    "t": "judge",
    "a": "正确"
  },
  "1622": {
    "q": "使用内置函数open（）且以’w’模式打开的文件，文件指针默认指向文件尾。",
    "t": "judge",
    "a": "错误"
  },
  "1623": {
    "q": "readlines（）函数可以一次读取整个文件，自动将文件内容分析成一个行的列表。",
    "t": "judge",
    "a": "正确"
  },
  "1624": {
    "q": "fileName指定了要打开的文件名称，也包含了文件所在的存储路径，可以是相对路<br>径也可以是绝对路径。",
    "t": "judge",
    "a": "正确"
  },
  "1625": {
    "q": "close（）函数用于关闭一个已打开的文件，允许调用多次。",
    "t": "judge",
    "a": "正确"
  },
  "1626": {
    "q": "Python类不支持多继承。",
    "t": "judge",
    "a": "错误"
  },
  "1627": {
    "q": "Python在删除对象时会自动调用析构函数。",
    "t": "judge",
    "a": "正确"
  },
  "1628": {
    "q": "Python私有成员只能内部访问，不能从对象来访问。",
    "t": "judge",
    "a": "正确"
  },
  "1629": {
    "q": "类中的每个属性必须有初始值。",
    "t": "judge",
    "a": "正确"
  },
  "1630": {
    "q": "类多态是不同的对象调用相同的函数，产生不同的效果。",
    "t": "judge",
    "a": "错误"
  },
  "1631": {
    "q": "类方法可以访问对象变量。",
    "t": "judge",
    "a": "错误"
  },
  "1632": {
    "q": "类的封装是将抽象得到的属性和方法封装到一个类中，增强安全性和简化编程，使用者不必了解具体的实现细节，只需要通过外部接口，依据特定的访问权限来使用类的成员和方法。",
    "t": "judge",
    "a": "正确"
  },
  "1633": {
    "q": "类的继承实现代码的重用，不需要重复编写代码。",
    "t": "judge",
    "a": "正确"
  },
  "1634": {
    "q": "继承自threading.Thread类的派生类中不能有普通的成员方法。",
    "t": "judge",
    "a": "错误"
  },
  "1635": {
    "q": "静态方法、类方法都可以被对象调用。",
    "t": "judge",
    "a": "正确"
  },
  "1636": {
    "q": "静态方法不需要关键字self。",
    "t": "judge",
    "a": "正确"
  },
  "1637": {
    "q": "静态方法可以直接访问，不需要使用“类名.静态方法名”调用。",
    "t": "judge",
    "a": "错误"
  },
  "1638": {
    "q": "默认值参数就是在定义形参的时候，给函数默认赋一个值。",
    "t": "judge",
    "a": "正确"
  },
  "1639": {
    "q": "使用python编写的.py文件属于模块的通用类别。",
    "t": "judge",
    "a": "正确"
  },
  "1640": {
    "q": "尽管可以使用import语句一次导入任意多个标准库或扩展库，但是仍建议每次只导入一个标准库或扩展库。",
    "t": "judge",
    "a": "正确"
  },
  "1641": {
    "q": "os.rename (a，b)函数用于重命名文件或目录。",
    "t": "judge",
    "a": "正确"
  },
  "1642": {
    "q": "os.remove (path)方法用于删除指定路径的文件。",
    "t": "judge",
    "a": "正确"
  },
  "1643": {
    "q": "os.getcwd（）函数用于返回当前工作目录。",
    "t": "judge",
    "a": "正确"
  },
  "1644": {
    "q": "os.chdir (path)函数能用于改变当前工作目录到指定的路径。",
    "t": "judge",
    "a": "正确"
  },
  "1645": {
    "q": "removedirs（）将会删除父目录；但子目录没有成功删除，将抛出错误。",
    "t": "judge",
    "a": "正确"
  },
  "1646": {
    "q": "Python标准库os中的函数startfile（）可以启动任何已关联应用程序的文件，并自动调用关联的程序；可以用来打开外部程序或文件，系统会自动关联相应的程序来打开或执行指定的文件。",
    "t": "judge",
    "a": "正确"
  },
  "1647": {
    "q": "假设已成功导入os和sys标准库，那么表达式os.path.dirname ( sys.executable )的值为Python安装目录。",
    "t": "judge",
    "a": "正确"
  },
  "1648": {
    "q": "datatime模块重新封装了time模块、提供更多接口、提供的类有date、time、datetime timedelt、tzinfo。",
    "t": "judge",
    "a": "正确"
  },
  "1649": {
    "q": "检测数据缺失一般使用notnull方法。",
    "t": "judge",
    "a": "错误"
  },
  "1650": {
    "q": "Series和DataFrame是Pandas包中的数据结构，Series像二维数组，DataFrame像表格。",
    "t": "judge",
    "a": "错误"
  },
  "1651": {
    "q": "s2 = pD.Series ( [25, 23, 42, 21, 23], index=['Jack', 'Lucy', 'Helen', 'Milky', 'Jasper'])程序23 in s2的执行结果为False。",
    "t": "judge",
    "a": "正确"
  },
  "1652": {
    "q": "df1 = pD.DataFrame ( [[5, 2, 3], [4, 5, 6], [7, 8, 9]], index=['A‘，'B', 'D'], columns=['Cr, 'C2', 'C3']),那么 df1.loc[2, 1] = 8。",
    "t": "judge",
    "a": "错误"
  },
  "1653": {
    "q": "Pandas中head ( n )的意思是获取最后的n行数据。",
    "t": "judge",
    "a": "错误"
  },
  "1654": {
    "q": "Pandas中使用sort_index，sort_values 进行排序。",
    "t": "judge",
    "a": "正确"
  },
  "1655": {
    "q": "np.where (condition[, x, y])，基于条件condition，返回值来自x或者y。",
    "t": "judge",
    "a": "正确"
  },
  "1656": {
    "q": "Numpy数组中通用分割采用split函数，其可通过axis控制分割方向。",
    "t": "judge",
    "a": "正确"
  },
  "1657": {
    "q": "最小一最大规范化对原始数据进行线性变换，变换到［0, 1］区间。",
    "t": "judge",
    "a": "正确"
  },
  "1658": {
    "q": "缩放训练数据和测试数据的方法不必相同。",
    "t": "judge",
    "a": "错误"
  },
  "1659": {
    "q": "OneHotEncoder是一种不能够被scikit-learn的估计器使用的类别特征转换函数。",
    "t": "judge",
    "a": "错误"
  },
  "1660": {
    "q": "OrdinalEncoder会增添特征的维度。",
    "t": "judge",
    "a": "错误"
  },
  "1661": {
    "q": "Python由解释器、___和___三个主要部分组成。单行注释:在代码前加___符号；多行注释:可以在每行代码前加一个___符号，或者可以用___实行跨多行的注释。",
    "t": "fill",
    "a": "编译器|虚拟机|#|#|’\""
  },
  "1662": {
    "q": "使用pip工具升级科学计算扩展库Numpy的完整命令是___。使用pip工具查看当前已安装的Python扩展库的完整命令是___。",
    "t": "fill",
    "a": "pip install - -upgrade numpy|pip list"
  },
  "1663": {
    "q": "使用pip工具升级科学计算扩展库numpy的完整命令是___。",
    "t": "fill",
    "a": "pip install - - upgrade numpy"
  },
  "1664": {
    "q": "Python中集合主要有两个功能，一个功能是进行___，另一个功能是___。",
    "t": "fill",
    "a": "集合操作|消除重复元素"
  },
  "1665": {
    "q": "Python中，9//2的输出结果是___9.0//2.0输岀结果是___。",
    "t": "fill",
    "a": "4|4.0"
  },
  "1666": {
    "q": "Python中，&lt;返回x是否小于y，这分别与特殊的变量___和___等价。",
    "t": "fill",
    "a": "True|False"
  },
  "1667": {
    "q": "Python中，___返回除法的余数。",
    "t": "fill",
    "a": "取模"
  },
  "1668": {
    "q": "Python中，___表示两个数相乘或是返回一个被重复若干次的字符串。",
    "t": "fill",
    "a": "*"
  },
  "1669": {
    "q": "Python中，字典本身是无序的，可以通过方法___和___取字典键值对中的键和值。",
    "t": "fill",
    "a": "keys|values"
  },
  "1670": {
    "q": "Python中，有时候为避免混淆，也会使用___，用于转义其后一位的字符为原始输出。",
    "t": "fill",
    "a": "转义字符\"\\\""
  },
  "1671": {
    "q": "Python中，需要注意定义字典时，___不能重复，否则重复的键值会替代原先的键值。",
    "t": "fill",
    "a": "键"
  },
  "1672": {
    "q": "Python中，需要注意集合不支持通过___访问指定元素。",
    "t": "fill",
    "a": "索引"
  },
  "1673": {
    "q": "Python内置了字典diet，在其他语言中也称为map，使用___存储，具有极快的查找速度，其格式是用大括号｛｝括起来key和value用冒号\":\"进行对应。",
    "t": "fill",
    "a": "键-值(key- value )"
  },
  "1674": {
    "q": "可变数据包括___、Dictionary（字典）、Set（集合）。",
    "t": "fill",
    "a": "List(列表)"
  },
  "1675": {
    "q": "在Python中，取第1个到第3个位置的元素［注意这种索引取数是前包后不包的（包括0位置，但不包括3位置，即取0，1，2位置的元素）］的代码是___。",
    "t": "fill",
    "a": "list1[0:3]"
  },
  "1676": {
    "q": "在使用多个___的分支结构时，应把握好多个条件语句之间的关系，只要有一个条件成立，就会将其后的语句执行，执行后退岀整个if语句。",
    "t": "fill",
    "a": "elif语句"
  },
  "1677": {
    "q": "Python中，布尔与——如果x为False，x and y返回False，否则它返回y的___。",
    "t": "fill",
    "a": "计算值"
  },
  "1678": {
    "q": "Python语言中的___只有在测试条件为假时才会停止。",
    "t": "fill",
    "a": "while语句"
  },
  "1679": {
    "q": "Python语言中的___与其他高级程序设计语言有很大的不同，其他高级语言中通过控制变量来控制循环，Python中则是通过循环遍历某一序列对象（字符 串、列表、元组等）来构建循环，循环结束的条件就是对象被遍历完成。",
    "t": "fill",
    "a": "for语句"
  },
  "1680": {
    "q": "if语句可以使用在一个单语句中，实现___，基本形式:&lt;表达式1&gt; if&lt;条件&gt; else&lt;表达式2&gt;。",
    "t": "fill",
    "a": "三元运算符"
  },
  "1681": {
    "q": "___须以正确的顺序传入函数，调用时的数量必须和声明时的一样。",
    "t": "fill",
    "a": "位置参数"
  },
  "1682": {
    "q": "Python中的___是具有0个或多个参数，具有若干行语句并且具有返回值（返回值可有可无）的一个语句块（注意缩进）。",
    "t": "fill",
    "a": "函数"
  },
  "1683": {
    "q": "Python中,___转换字符串中小写字母为大写字母。",
    "t": "fill",
    "a": "upper()"
  },
  "1684": {
    "q": "___也叫函数体，用来进行一系列的逻辑运算。",
    "t": "fill",
    "a": "执行语句"
  },
  "1685": {
    "q": "___可以是常量、变量、表达式、函数等，无论是何种类型的量，在进行函 数调用时，它们都必须有确定的值，以便把这些值传送给形参。",
    "t": "fill",
    "a": "实参"
  },
  "1686": {
    "q": "___可以用来调用函数，不能使用关键字来命名，最好是用这个函数的功能 的英文名命名，可以采用驼峰法与下划线法。",
    "t": "fill",
    "a": "函数名称"
  },
  "1687": {
    "q": "___就是在定义形参的时候，给函数默认赋一个值。",
    "t": "fill",
    "a": "默认参数"
  },
  "1688": {
    "q": "___是在整个程序里面都生效的，在程序最前面定义的。",
    "t": "fill",
    "a": "全局变量"
  },
  "1689": {
    "q": "___只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。",
    "t": "fill",
    "a": "形参变量"
  },
  "1690": {
    "q": "只要函数里面遇到___，函数立即结束运行。",
    "t": "fill",
    "a": "return"
  },
  "1691": {
    "q": "Python中，___转换字符串中的小写字母为大写字母，转换大写字母为小写字母。",
    "t": "fill",
    "a": "swapcase ()"
  },
  "1692": {
    "q": "文件对象通过___函数得到，获取文件对象后，就可以使用文件对象提供的方法 来读写文件。",
    "t": "fill",
    "a": "open ()"
  },
  "1693": {
    "q": "Python中对文件进行写入操作之后，___函数用来在不关闭文件对象 的情况下将缓冲区内容写入文件。",
    "t": "fill",
    "a": "flush ()"
  },
  "1694": {
    "q": "open ___函数有八个参数，除了___参数外，其他都有默认值。",
    "t": "fill",
    "a": "file|"
  },
  "1695": {
    "q": "Python中线程对象的___函数用来阻塞当前线程，指定线程运行结束或超时后继续运行当前线程。",
    "t": "fill",
    "a": "join ()"
  },
  "1696": {
    "q": "___函数用于以数字权限模式创建单层目录。",
    "t": "fill",
    "a": "mkdir ()"
  },
  "1697": {
    "q": "___函数用于删除文件。",
    "t": "fill",
    "a": "os.remove (path )"
  },
  "1698": {
    "q": "用string与random模块生成4位随机验证码，包含数字、字母，字母区分大小写。则程序为___",
    "t": "fill",
    "a": "random.sample ( string.ascii_Ietters + string.digits, 4 )"
  },
  "1699": {
    "q": "在设计正则表达式时，字符___紧随任何其他限定符（*、+、? 、{n}、{n，}、<br>{n，m})时，匹配模式是“非贪心的”，匹配搜索到的、尽可能短的字符串。",
    "t": "fill",
    "a": "?"
  },
  "1700": {
    "q": "假设正则表达式模块re已导入，那么表达式re.sub ('\\d+', '1', 'al2345bbbb67c890d 0e')的值为___。",
    "t": "fill",
    "a": "'albbbblcldle'"
  },
  "1701": {
    "q": "一组数据中出现最多的变量值叫作（）。",
    "t": "single",
    "a": "众数"
  },
  "1702": {
    "q": "一组数据相加后除以数据个数得到的值叫作（）。",
    "t": "single",
    "a": "平均值"
  },
  "1703": {
    "q": "一组数据的最大值与最小值之差叫作（）。",
    "t": "single",
    "a": "极差"
  },
  "1704": {
    "q": "下列统计量可以描述数据的集中程度的是（）。",
    "t": "single",
    "a": "众数"
  },
  "1705": {
    "q": "统计描述的种类主要包括均值、百分位数、中位数、众数、全距和方差等，（   ）。是指如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值。",
    "t": "single",
    "a": "百分位数"
  },
  "1706": {
    "q": "参加奥运会前，需要对运动员模拟比赛的成绩进行统计分析，判断运动员成绩是否稳定，因此需要知道运动员模拟比赛的（）。",
    "t": "single",
    "a": "方差或极差"
  },
  "1707": {
    "q": "考虑值集｛12 24 33 2 4 55 68 26｝的四分位数极差是（）。",
    "t": "single",
    "a": "21"
  },
  "1708": {
    "q": "讨论变量之间的关系，主要有（）、方差分析和回归分析三个方法。",
    "t": "single",
    "a": "相关分析"
  },
  "1709": {
    "q": "当相关系数户γ=0时，说明（）",
    "t": "single",
    "a": "现象之间无直线相关"
  },
  "1710": {
    "q": "下列关于正态分布的说法错误的是（）",
    "t": "single",
    "a": "正态分布的偏度为0、峰度为1"
  },
  "1711": {
    "q": "标准正态分布的均数与标准差分别是（)。",
    "t": "single",
    "a": "0，1"
  },
  "1712": {
    "q": "对于正态分布的两个参数μ与σ（）对应的正态曲线越趋扁平。",
    "t": "single",
    "a": "σ越大"
  },
  "1713": {
    "q": "数据可视化的基本类型是（ ）",
    "t": "single",
    "a": "科学可视化、信息可视化、可视分析学"
  },
  "1714": {
    "q": "下列关于可视分析学的说法错误的是（）。",
    "t": "single",
    "a": "可视分析学比较典型的模型是D.Keim等（2008年）提出的数据分析模型"
  },
  "1715": {
    "q": "下列不是专门用于可视化时间空间数据的技术是（）。",
    "t": "single",
    "a": "饼图"
  },
  "1716": {
    "q": "数据可视化是利用计算机图形学和(),将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。",
    "t": "single",
    "a": "图像处理技术"
  },
  "1717": {
    "q": "()不属于广义上的数据可视化技术。",
    "t": "single",
    "a": "类别可视化"
  },
  "1718": {
    "q": "()属于数据可视化方法体系中的基础方法。",
    "t": "single",
    "a": "视觉隐喻"
  },
  "1719": {
    "q": "下列关于表述数据可视化在数据科学中重要地位的说法不正确的是()。",
    "t": "single",
    "a": "数据可视化处理结果的解读对用户知识水平的要求较高"
  },
  "1720": {
    "q": "箱形图能显示岀一组数据的最大值、最小值、（）、上四分位数及下四分位数。",
    "t": "single",
    "a": "中位数"
  },
  "1721": {
    "q": "从可视化视角看，可以将数据分为4种类型，其中不包括（）",
    "t": "single",
    "a": "定量数据"
  },
  "1722": {
    "q": "下列不是数据可视化的顺序模型内容的是（）。",
    "t": "single",
    "a": "绘图"
  },
  "1723": {
    "q": "（）技术可以将所有数据的特性通过图的方式展现出来。",
    "t": "single",
    "a": "数据可视化"
  },
  "1724": {
    "q": "数据可视化技术可以将所有数据的特性通过（）的方式展现出来",
    "t": "single",
    "a": "图"
  },
  "1725": {
    "q": "对于分类类型的变量，()是个非常好的展示工具。",
    "t": "single",
    "a": "直方图"
  },
  "1726": {
    "q": "下列不是Matplotlib三层结构的是()。",
    "t": "single",
    "a": "数据层"
  },
  "1727": {
    "q": "Windows系统下安装Matplotlib的命令是()。",
    "t": "single",
    "a": "python -m pip install matplotlib"
  },
  "1728": {
    "q": "设置图的标题的命令是()",
    "t": "single",
    "a": "plt.title （'标题 ' ）"
  },
  "1729": {
    "q": "Seaborn要求原始数据的输人类型不能是（)",
    "t": "single",
    "a": "Series"
  },
  "1730": {
    "q": "ggplot2的核心理念是（）。",
    "t": "single",
    "a": "绘图与数据分离"
  },
  "1731": {
    "q": "geoplot是（）库的扩展。",
    "t": "single",
    "a": "cartopy 禾口 matplotlib"
  },
  "1732": {
    "q": "geoplotlib是一个用于制作（）相关数据的工具箱。",
    "t": "single",
    "a": "地图和地理"
  },
  "1733": {
    "q": "下列属于可视化高维数据技术的有（）。",
    "t": "muti",
    "a": "矩阵 | 平行坐标系 | 星形坐标 | ChernofFface"
  },
  "1734": {
    "q": "数据可视化涉及（）等多个领域，成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。",
    "t": "muti",
    "a": "计算机图形学 | 图像处理 | 计算机视觉 | 计算机辅助设计"
  },
  "1735": {
    "q": "数据可视化是利用计算机图形学和图像处理技术，将数据转换成（）在屏幕上显示出来，并进行交互处理的理论、方法和技术。",
    "t": "muti",
    "a": "图形 | 图像"
  },
  "1736": {
    "q": "数据可视化中，从数据到知识的转换途径强调（）。",
    "t": "muti",
    "a": "可视化分析 | 自动化建模"
  },
  "1737": {
    "q": "可视分析学的特点包含（）。",
    "t": "muti",
    "a": "强调数据到知识的转换过程 | 强调可视化分析与自动化建模之间的相互作用 | 强调数据映射和数据挖掘的重要性 | 强调数据加工工作的必要性 | 强调人机交互的重要性"
  },
  "1738": {
    "q": "从可视化处理视角看，可以将数据分为（）四个类型并釆用不同的视觉映射方法。",
    "t": "muti",
    "a": "定类数据 | 定序数据 | 定距离数据 | 定比暑假"
  },
  "1739": {
    "q": "___ 可以将所有数据的特性通过图的方式展现出来。",
    "t": "fill",
    "a": "数据可视化技术"
  },
  "1740": {
    "q": "统计工具中经常使用的图形包括___、___、___、___箱型图。",
    "t": "fill",
    "a": "直方图|条形图|散点图|点图"
  },
  "1741": {
    "q": "acecolor可以调整画布背景颜色。（）",
    "t": "judge",
    "a": "正确"
  },
  "1742": {
    "q": "figsize可以设置画布的尺寸。（）",
    "t": "judge",
    "a": "正确"
  },
  "1743": {
    "q": "figsize可以设置画布的边线颜色。（）",
    "t": "judge",
    "a": "错误"
  },
  "1744": {
    "q": "edgecolor可以调整画布边线颜色。（）",
    "t": "judge",
    "a": "正确"
  }
}